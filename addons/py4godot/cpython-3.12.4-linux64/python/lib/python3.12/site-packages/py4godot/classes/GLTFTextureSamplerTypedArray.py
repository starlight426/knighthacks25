# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing

if typing.TYPE_CHECKING:
  import py4godot.classes.GLTFTextureSampler as py4godot_gltftexturesampler
from py4godot.classes.core import *
from py4godot.wrappers.wrappers import CPPGLTFTextureSamplerTypedArrayWrapper


class GLTFTextureSamplerTypedArray():
  r''''''


  @staticmethod
  def new0():
    _class = GLTFTextureSamplerTypedArray.construct_without_init()
    _class._ptr = constructor(19, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(base:'Array' , type:'int' , class_name:'object' , script:'object' ):
    assert(not base is None)
    assert isinstance(base, Array), 'base must be Array'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not class_name is None)
    assert isinstance(class_name, (str, StringName)), 'class_name must be str or StringName'
    

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    assert(isinstance(class_name, (str, StringName)))
    py_stringname_class_name = class_name if isinstance(class_name, StringName) else c_utils.py_string_to_string_name(class_name)


    _class.__base__ = base

    _class.py_stringname_class_name =py_stringname_class_name

    _class._ptr = constructor(19, 2, tuple([base._ptr, type, py_stringname_class_name._ptr, script]))
    return _class
  @staticmethod
  def new3(from_:'PackedByteArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedByteArray), 'from_ must be PackedByteArray'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 3, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new4(from_:'PackedInt32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt32Array), 'from_ must be PackedInt32Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 4, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new5(from_:'PackedInt64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt64Array), 'from_ must be PackedInt64Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 5, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new6(from_:'PackedFloat32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat32Array), 'from_ must be PackedFloat32Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 6, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new7(from_:'PackedFloat64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat64Array), 'from_ must be PackedFloat64Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 7, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new8(from_:'PackedStringArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedStringArray), 'from_ must be PackedStringArray'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 8, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new9(from_:'PackedVector2Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector2Array), 'from_ must be PackedVector2Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 9, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new10(from_:'PackedVector3Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector3Array), 'from_ must be PackedVector3Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 10, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new11(from_:'PackedColorArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedColorArray), 'from_ must be PackedColorArray'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 11, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new12(from_:'PackedVector4Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector4Array), 'from_ must be PackedVector4Array'

    _class = GLTFTextureSamplerTypedArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(19, 12, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(19,0, ())

  def generate_wrapper(self):
    return CPPGLTFTextureSamplerTypedArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = GLTFTextureSamplerTypedArray.__new__(GLTFTextureSamplerTypedArray)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GLTFTextureSamplerTypedArray'

  def __setitem__(self,  index, value):
    self._ptr.call_with_return(61, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(60, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = GLTFTextureSamplerTypedArray.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(2,tuple([]))

  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def assign(self, array:'Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'






    self._ptr.call_with_return(4,tuple([array._ptr]))

  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = None
    _ret = self._ptr.call_with_return(5,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    







    self._ptr.call_with_return(6,tuple([index, value]))

  @functools.native_method
  def push_back(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> None:
    r''''''

    






    self._ptr.call_with_return(7,tuple([value]))

  @functools.native_method
  def push_front(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> None:
    r''''''

    






    self._ptr.call_with_return(8,tuple([value]))

  @functools.native_method
  def append(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> None:
    r''''''

    






    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def append_array(self, array:'Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'






    self._ptr.call_with_return(10,tuple([array._ptr]))

  @functools.native_method
  def resize(self, size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([size]))
    return _ret


  @functools.native_method
  def insert(self, position:'int'   , value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'
    







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([position, value]))
    return _ret


  @functools.native_method
  def remove_at(self, position:'int'   ) -> None:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'






    self._ptr.call_with_return(13,tuple([position]))

  @functools.native_method
  def fill(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> None:
    r''''''

    






    self._ptr.call_with_return(14,tuple([value]))

  @functools.native_method
  def erase(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> None:
    r''''''

    






    self._ptr.call_with_return(15,tuple([value]))

  @functools.native_method
  def front(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(16,tuple([]))
    return _ret


  @functools.native_method
  def back(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(17,tuple([]))
    return _ret


  @functools.native_method
  def pick_random(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, what:'py4godot_gltftexturesampler.GLTFTextureSampler'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(from_, (int, float)), 'from_ must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([what, from_]))
    return _ret


  @functools.native_method
  def find_custom(self, method:'Callable'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([method._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, what:'py4godot_gltftexturesampler.GLTFTextureSampler'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(from_, (int, float)), 'from_ must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([what, from_]))
    return _ret


  @functools.native_method
  def rfind_custom(self, method:'Callable'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([method._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> typing.Union[int]:
    r''''''

    






    _ret = 0
    _ret = self._ptr.call_with_return(23,tuple([value]))
    return _ret


  @functools.native_method
  def has(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   ) -> typing.Union[bool]:
    r''''''

    






    _ret = 0
    _ret = self._ptr.call_with_return(24,tuple([value]))
    return _ret


  @functools.native_method
  def pop_back(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(25,tuple([]))
    return _ret


  @functools.native_method
  def pop_front(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(26,tuple([]))
    return _ret


  @functools.native_method
  def pop_at(self, position:'int'   ) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'






    _ret = None
    _ret = self._ptr.call_with_return(27,tuple([position]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(28,tuple([]))

  @functools.native_method
  def sort_custom(self, func:'Callable'   ) -> None:
    r''''''

    assert(not func is None)
    assert isinstance(func, Callable), 'func must be Callable'






    self._ptr.call_with_return(29,tuple([func._ptr]))

  @functools.native_method
  def shuffle(self) -> None:
    r''''''




    self._ptr.call_with_return(30,tuple([]))

  @functools.native_method
  def bsearch(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(before, bool), 'before must be bool'







    _ret = 0
    _ret = self._ptr.call_with_return(31,tuple([value, before]))
    return _ret


  @functools.native_method
  def bsearch_custom(self, value:'py4godot_gltftexturesampler.GLTFTextureSampler'   , func:'Callable'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    
    assert(not func is None)
    assert isinstance(func, Callable), 'func must be Callable'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(32,tuple([value, func._ptr, before]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(33,tuple([]))

  @functools.native_method
  def duplicate(self, deep:'bool' =False  ) -> typing.Union['Array']:
    r''''''

    assert isinstance(deep, bool), 'deep must be bool'






    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(34,tuple([deep]))
    return _ret


  @functools.native_method
  def duplicate_deep(self, deep_subresources_mode:'int' =1  ) -> typing.Union['Array']:
    r''''''

    assert isinstance(deep_subresources_mode, (int, float)), 'deep_subresources_mode must be int or float'






    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(35,tuple([deep_subresources_mode]))
    return _ret


  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  , step:'int' =1  , deep:'bool' =False  ) -> typing.Union['Array']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'
    assert isinstance(step, (int, float)), 'step must be int or float'
    assert isinstance(deep, bool), 'deep must be bool'









    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(36,tuple([begin, end, step, deep]))
    return _ret


  @functools.native_method
  def filter(self, method:'Callable'   ) -> typing.Union['Array']:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'






    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(37,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def map(self, method:'Callable'   ) -> typing.Union['Array']:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'






    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(38,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def reduce(self, method:'Callable'   , accum:'py4godot_gltftexturesampler.GLTFTextureSampler' = None  ) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''



    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    







    _ret = None
    _ret = self._ptr.call_with_return(39,tuple([method._ptr, accum]))
    return _ret


  @functools.native_method
  def any(self, method:'Callable'   ) -> typing.Union[bool]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'






    _ret = 0
    _ret = self._ptr.call_with_return(40,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def all(self, method:'Callable'   ) -> typing.Union[bool]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'






    _ret = 0
    _ret = self._ptr.call_with_return(41,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def max(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(42,tuple([]))
    return _ret


  @functools.native_method
  def min(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(43,tuple([]))
    return _ret


  @functools.native_method
  def is_typed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(44,tuple([]))
    return _ret


  @functools.native_method
  def is_same_typed(self, array:'Array'   ) -> typing.Union[bool]:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'






    _ret = 0
    _ret = self._ptr.call_with_return(45,tuple([array._ptr]))
    return _ret


  @functools.native_method
  def get_typed_builtin(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(46,tuple([]))
    return _ret


  @functools.native_method
  def get_typed_class_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(47,tuple([]))
    return _ret


  @functools.native_method
  def get_typed_script(self) -> typing.Union['py4godot_gltftexturesampler.GLTFTextureSampler']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(48,tuple([]))
    return _ret


  @functools.native_method
  def make_read_only(self) -> None:
    r''''''




    self._ptr.call_with_return(49,tuple([]))

  @functools.native_method
  def is_read_only(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([]))
    return _ret



