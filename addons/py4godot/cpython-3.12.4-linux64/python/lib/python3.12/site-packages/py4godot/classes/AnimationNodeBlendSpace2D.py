# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AnimationNodeStateMachine as py4godot_animationnodestatemachine 
  import py4godot.classes.AnimationNodeAnimation as py4godot_animationnodeanimation 
  import py4godot.classes.AnimationNodeBlendTree as py4godot_animationnodeblendtree 
  import py4godot.classes.AnimationNodeBlendSpace1D as py4godot_animationnodeblendspace1d 
import py4godot.classes.AnimationRootNode as py4godot_animationrootnode 
from py4godot.wrappers.wrappers import CPPAnimationNodeBlendSpace2DWrapper

class BlendMode:
  BLEND_MODE_INTERPOLATED = 0
  BLEND_MODE_DISCRETE = 1
  BLEND_MODE_DISCRETE_CARRY = 2


class AnimationNodeBlendSpace2D(py4godot_animationrootnode.AnimationRootNode):
  r'''
		A resource used by `AnimationNodeBlendTree`.
		`AnimationNodeBlendSpace2D` represents a virtual 2D space on which `AnimationRootNode`s are placed. Outputs the linear blend of the three adjacent animations using a `Vector2` weight. Adjacent in this context means the three `AnimationRootNode`s making up the triangle that contains the current value.
		You can add vertices to the blend space with `add_blend_point` and automatically triangulate it by setting `auto_triangles` to `true`. Otherwise, use `add_triangle` and `remove_triangle` to triangulate the blend space by hand.
	'''

  @staticmethod
  def constructor():
    class_ = AnimationNodeBlendSpace2D.construct_without_init()
    class_._ptr = constructor(82,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimationNodeBlendSpace2D.construct_without_init()
    class_._ptr = constructor(82,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimationNodeBlendSpace2DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(82,0, ())


  def generate_wrapper(self):
    return CPPAnimationNodeBlendSpace2DWrapper()
  def init_signals(self):
    super().init_signals()
    triangles_updated_name = utils.py_string_to_string_name("triangles_updated")
    self.triangles_updated = signals.BuiltinSignal(self, triangles_updated_name)

  @staticmethod
  def construct_without_init():
    cls = AnimationNodeBlendSpace2D.__new__(AnimationNodeBlendSpace2D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimationNodeBlendSpace2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNodeBlendSpace2D.construct_without_init()
    cls._ptr = CPPAnimationNodeBlendSpace2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNodeBlendSpace2D.construct_without_init()
    cls._ptr = CPPAnimationNodeBlendSpace2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def auto_triangles(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_auto_triangles()
    return _ret
  @auto_triangles.setter
  def auto_triangles(self,  value:'bool'):
    self.set_auto_triangles(value)
  @property
  def triangles(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. _get_triangles()
    return _ret
  @triangles.setter
  def triangles(self,  value:'PackedInt32Array'):
    self._set_triangles(value)
  @property
  def min_space(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_min_space()
    return _ret
  @min_space.setter
  def min_space(self,  value:'Vector2'):
    self.set_min_space(value)
  @property
  def max_space(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_max_space()
    return _ret
  @max_space.setter
  def max_space(self,  value:'Vector2'):
    self.set_max_space(value)
  @property
  def snap(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_snap()
    return _ret
  @snap.setter
  def snap(self,  value:'Vector2'):
    self.set_snap(value)
  @property
  def x_label(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_x_label()
    return _ret
  @x_label.setter
  def x_label(self,  value:'str'):
    self.set_x_label(value)
  @property
  def y_label(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_y_label()
    return _ret
  @y_label.setter
  def y_label(self,  value:'str'):
    self.set_y_label(value)
  @property
  def blend_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_blend_mode()
    return _ret
  @blend_mode.setter
  def blend_mode(self,  value:'int'):
    self.set_blend_mode(value)
  @property
  def sync(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_sync()
    return _ret
  @sync.setter
  def sync(self,  value:'bool'):
    self.set_use_sync(value)
  @functools.native_method
  def add_blend_point(self, node:'py4godot_animationrootnode.AnimationRootNode'   , pos:'Vector2'   , at_index:'int' =-1  ) -> None:
    r'''
				Adds a new point that represents a `node` at the position set by `pos`. You can insert it at a specific index using the `at_index` argument. If you use the default value for `at_index`, the point is inserted at the end of the blend points array.
			'''

    assert(not node is None)
    assert isinstance(node, get_class('AnimationRootNode')), 'node must be AnimationRootNode'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(at_index, (int, float)), 'at_index must be int or float'








    self._ptr.call_with_return(102,tuple([node._ptr, pos._ptr, at_index]))

  @functools.native_method
  def set_blend_point_position(self, point:'int'   , pos:'Vector2'   ) -> None:
    r'''
				Updates the position of the point at index `point` in the blend space.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'







    self._ptr.call_with_return(103,tuple([point, pos._ptr]))

  @functools.native_method
  def get_blend_point_position(self, point:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the point at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'






    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([point]))
    return _ret


  @functools.native_method
  def set_blend_point_node(self, point:'int'   , node:'py4godot_animationrootnode.AnimationRootNode'   ) -> None:
    r'''
				Changes the `AnimationNode` referenced by the point at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'
    assert(not node is None)
    assert isinstance(node, get_class('AnimationRootNode')), 'node must be AnimationRootNode'







    self._ptr.call_with_return(105,tuple([point, node._ptr]))

  @functools.native_method
  def get_blend_point_node(self, point:'int'   ) -> typing.Any:
    r'''
				Returns the `AnimationRootNode` referenced by the point at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AnimationRootNode
    _ret._ptr = self._ptr.call_with_return(106,tuple([point]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def remove_blend_point(self, point:'int'   ) -> None:
    r'''
				Removes the point at index `point` from the blend space.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'






    self._ptr.call_with_return(107,tuple([point]))

  @functools.native_method
  def get_blend_point_count(self) -> typing.Union[int]:
    r'''
				Returns the number of points in the blend space.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(108,tuple([]))
    return _ret


  @functools.native_method
  def add_triangle(self, x:'int'   , y:'int'   , z:'int'   , at_index:'int' =-1  ) -> None:
    r'''
				Creates a new triangle using three points `x`, `y`, and `z`. Triangles can overlap. You can insert the triangle at a specific index using the `at_index` argument. If you use the default value for `at_index`, the point is inserted at the end of the blend points array.
			'''

    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'
    assert isinstance(at_index, (int, float)), 'at_index must be int or float'









    self._ptr.call_with_return(109,tuple([x, y, z, at_index]))

  @functools.native_method
  def get_triangle_point(self, triangle:'int'   , point:'int'   ) -> typing.Union[int]:
    r'''
				Returns the position of the point at index `point` in the triangle of index `triangle`.
			'''

    assert isinstance(triangle, (int, float)), 'triangle must be int or float'
    assert isinstance(point, (int, float)), 'point must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([triangle, point]))
    return _ret


  @functools.native_method
  def remove_triangle(self, triangle:'int'   ) -> None:
    r'''
				Removes the triangle at index `triangle` from the blend space.
			'''

    assert isinstance(triangle, (int, float)), 'triangle must be int or float'






    self._ptr.call_with_return(111,tuple([triangle]))

  @functools.native_method
  def get_triangle_count(self) -> typing.Union[int]:
    r'''
				Returns the number of triangles in the blend space.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([]))
    return _ret


  @functools.native_method
  def set_min_space(self, min_space:'Vector2'   ) -> None:
    r''''''

    assert(not min_space is None)
    assert isinstance(min_space, Vector2), 'min_space must be Vector2'

    self.py__min_space = min_space






    self._ptr.call_with_return(113,tuple([min_space._ptr]))

  @functools.native_method
  def get_min_space(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(114,tuple([]))

    return _ret


  @functools.native_method
  def set_max_space(self, max_space:'Vector2'   ) -> None:
    r''''''

    assert(not max_space is None)
    assert isinstance(max_space, Vector2), 'max_space must be Vector2'

    self.py__max_space = max_space






    self._ptr.call_with_return(115,tuple([max_space._ptr]))

  @functools.native_method
  def get_max_space(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(116,tuple([]))

    return _ret


  @functools.native_method
  def set_snap(self, snap:'Vector2'   ) -> None:
    r''''''

    assert(not snap is None)
    assert isinstance(snap, Vector2), 'snap must be Vector2'

    self.py__snap = snap






    self._ptr.call_with_return(117,tuple([snap._ptr]))

  @functools.native_method
  def get_snap(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(118,tuple([]))

    return _ret


  @functools.native_method
  def set_x_label(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'

    self.py__x_label = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(119,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_x_label(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(120,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_y_label(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'

    self.py__y_label = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(121,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_y_label(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(122,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_auto_triangles(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__auto_triangles = enable






    self._ptr.call_with_return(123,tuple([enable]))

  @functools.native_method
  def get_auto_triangles(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(124,tuple([]))

    return _ret


  @functools.native_method
  def set_blend_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__blend_mode = mode






    self._ptr.call_with_return(125,tuple([mode]))

  @functools.native_method
  def get_blend_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(126,tuple([]))

    return _ret


  @functools.native_method
  def set_use_sync(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__sync = enable






    self._ptr.call_with_return(127,tuple([enable]))

  @functools.native_method
  def is_using_sync(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(128,tuple([]))

    return _ret



register_cast_function('AnimationNodeBlendSpace2D', AnimationNodeBlendSpace2D.cast)
register_class('AnimationNodeBlendSpace2D', AnimationNodeBlendSpace2D)
