# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.Shortcut as py4godot_shortcut 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPEditorContextMenuPluginWrapper

class ContextMenuSlot:
  CONTEXT_SLOT_SCENE_TREE = 0
  CONTEXT_SLOT_FILESYSTEM = 1
  CONTEXT_SLOT_SCRIPT_EDITOR = 2
  CONTEXT_SLOT_FILESYSTEM_CREATE = 3
  CONTEXT_SLOT_SCRIPT_EDITOR_CODE = 4
  CONTEXT_SLOT_SCENE_TABS = 5
  CONTEXT_SLOT_2D_EDITOR = 6


class EditorContextMenuPlugin(py4godot_refcounted.RefCounted):
  r'''
		`EditorContextMenuPlugin` allows for the addition of custom options in the editor's context menu.
		Currently, context menus are supported for three commonly used areas: the file system, scene tree, and editor script list panel.
	'''

  @staticmethod
  def constructor():
    class_ = EditorContextMenuPlugin.construct_without_init()
    class_._ptr = constructor(267,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorContextMenuPlugin.construct_without_init()
    class_._ptr = constructor(267,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorContextMenuPluginWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(267,0, ())


  def generate_wrapper(self):
    return CPPEditorContextMenuPluginWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorContextMenuPlugin.__new__(EditorContextMenuPlugin)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorContextMenuPlugin'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorContextMenuPlugin.construct_without_init()
    cls._ptr = CPPEditorContextMenuPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorContextMenuPlugin.construct_without_init()
    cls._ptr = CPPEditorContextMenuPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _popup_menu(self, paths:'PackedStringArray'   ) -> None:
    r'''
				Called when creating a context menu, custom options can be added by using the `add_context_menu_item` or `add_context_menu_item_from_shortcut` functions. `paths` contains currently selected paths (depending on menu), which can be used to conditionally add options.
			'''

    assert(not paths is None)
    assert isinstance(paths, PackedStringArray), 'paths must be PackedStringArray'






    self._ptr.call_with_return(53,tuple([paths._ptr]))

  @functools.native_method
  def add_menu_shortcut(self, shortcut:'py4godot_shortcut.Shortcut'   , callback:'Callable'   ) -> None:
    r'''
				Registers a shortcut associated with the plugin's context menu. This method should be called once (e.g. in plugin's `Object._init`). `callback` will be called when user presses the specified `shortcut` while the menu's context is in effect (e.g. FileSystem dock is focused). Callback should take single `Array` argument; array contents depend on context menu slot.
				```gdscript
				func _init():
					add_menu_shortcut(SHORTCUT, handle)
				```
			'''

    assert(not shortcut is None)
    assert isinstance(shortcut, get_class('Shortcut')), 'shortcut must be Shortcut'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'







    self._ptr.call_with_return(54,tuple([shortcut._ptr, callback._ptr]))

  @functools.native_method
  def add_context_menu_item(self, name:'str'   , callback:'Callable'   , icon:'py4godot_texture2d.Texture2D' = None  ) -> None:
    r'''
				Add custom option to the context menu of the plugin's specified slot. When the option is activated, `callback` will be called. Callback should take single `Array` argument; array contents depend on context menu slot.
				```gdscript
				func _popup_menu(paths):
					add_context_menu_item("File Custom options", handle, ICON)
				```
				If you want to assign shortcut to the menu item, use `add_context_menu_item_from_shortcut` instead.
			'''
    if icon is None:
      icon = c_utils.empty_object
    if icon is None:
      icon = c_utils.empty_object

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)



    self._ptr.call_with_return(55,tuple([py_string_name._ptr, callback._ptr, icon._ptr]))

  @functools.native_method
  def add_context_menu_item_from_shortcut(self, name:'str'   , shortcut:'py4godot_shortcut.Shortcut'   , icon:'py4godot_texture2d.Texture2D' = None  ) -> None:
    r'''
				Add custom option to the context menu of the plugin's specified slot. The option will have the `shortcut` assigned and reuse its callback. The shortcut has to be registered beforehand with `add_menu_shortcut`.
				```gdscript
				func _init():
					add_menu_shortcut(SHORTCUT, handle)

				func _popup_menu(paths):
					add_context_menu_item_from_shortcut("File Custom options", SHORTCUT, ICON)
				```
			'''
    if icon is None:
      icon = c_utils.empty_object
    if icon is None:
      icon = c_utils.empty_object

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not shortcut is None)
    assert isinstance(shortcut, get_class('Shortcut')), 'shortcut must be Shortcut'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)



    self._ptr.call_with_return(56,tuple([py_string_name._ptr, shortcut._ptr, icon._ptr]))

  @functools.native_method
  def add_context_submenu_item(self, name:'str'   , menu:'py4godot_popupmenu.PopupMenu'   , icon:'py4godot_texture2d.Texture2D' = None  ) -> None:
    r'''
				Add a submenu to the context menu of the plugin's specified slot. The submenu is not automatically handled, you need to connect to its signals yourself. Also the submenu is freed on every popup, so provide a new `PopupMenu` every time.
				```gdscript
				func _popup_menu(paths):
					var popup_menu = PopupMenu.new()
					popup_menu.add_item("Blue")
					popup_menu.add_item("White")
					popup_menu.id_pressed.connect(_on_color_submenu_option)

					add_context_submenu_item("Set Node Color", popup_menu)
				```
			'''
    if icon is None:
      icon = c_utils.empty_object
    if icon is None:
      icon = c_utils.empty_object

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not menu is None)
    assert isinstance(menu, get_class('PopupMenu')), 'menu must be PopupMenu'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)



    self._ptr.call_with_return(57,tuple([py_string_name._ptr, menu._ptr, icon._ptr]))


register_cast_function('EditorContextMenuPlugin', EditorContextMenuPlugin.cast)
register_class('EditorContextMenuPlugin', EditorContextMenuPlugin)
