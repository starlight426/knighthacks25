# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.Texture as py4godot_texture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.ImageTextureLayered as py4godot_imagetexturelayered 
  import py4godot.classes.Texture3DRD as py4godot_texture3drd 
  import py4godot.classes.Cubemap as py4godot_cubemap 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture3D as py4godot_noisetexture3d 
  import py4godot.classes.CompressedCubemapArray as py4godot_compressedcubemaparray 
  import py4godot.classes.PlaceholderCubemap as py4godot_placeholdercubemap 
  import py4godot.classes.Texture2DArray as py4godot_texture2darray 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.ImageTexture3D as py4godot_imagetexture3d 
  import py4godot.classes.TextureCubemapArrayRD as py4godot_texturecubemaparrayrd 
  import py4godot.classes.PlaceholderCubemapArray as py4godot_placeholdercubemaparray 
  import py4godot.classes.CompressedTextureLayered as py4godot_compressedtexturelayered 
  import py4godot.classes.CompressedTexture3D as py4godot_compressedtexture3d 
  import py4godot.classes.PlaceholderTexture3D as py4godot_placeholdertexture3d 
  import py4godot.classes.CompressedTexture2DArray as py4godot_compressedtexture2darray 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.VisualShader as py4godot_visualshader 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CubemapArray as py4godot_cubemaparray 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.TextureLayered as py4godot_texturelayered 
  import py4godot.classes.PlaceholderTextureLayered as py4godot_placeholdertexturelayered 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.TextureLayeredRD as py4godot_texturelayeredrd 
  import py4godot.classes.Texture2DArrayRD as py4godot_texture2darrayrd 
  import py4godot.classes.PlaceholderTexture2DArray as py4godot_placeholdertexture2darray 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.CompressedCubemap as py4godot_compressedcubemap 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.TextureCubemapRD as py4godot_texturecubemaprd 
  import py4godot.classes.Texture3D as py4godot_texture3d 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPShaderWrapper

class Mode:
  MODE_SPATIAL = 0
  MODE_CANVAS_ITEM = 1
  MODE_PARTICLES = 2
  MODE_SKY = 3
  MODE_FOG = 4


class Shader(py4godot_resource.Resource):
  r'''
		A custom shader program implemented in the Godot shading language, saved with the `.gdshader` extension.
		This class is used by a `ShaderMaterial` and allows you to write your own custom behavior for rendering visual items or updating particle information. For a detailed explanation and usage, please see the tutorials linked below.
	'''

  @staticmethod
  def constructor():
    class_ = Shader.construct_without_init()
    class_._ptr = constructor(736,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Shader.construct_without_init()
    class_._ptr = constructor(736,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPShaderWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(736,0, ())


  def generate_wrapper(self):
    return CPPShaderWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Shader.__new__(Shader)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Shader'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Shader.construct_without_init()
    cls._ptr = CPPShaderWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Shader.construct_without_init()
    cls._ptr = CPPShaderWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def code(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_code()
    return _ret
  @code.setter
  def code(self,  value:'str'):
    self.set_code(value)
  @functools.native_method
  def get_mode(self) -> typing.Union[int]:
    r'''
				Returns the shader mode for the shader.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(77,tuple([]))
    return _ret


  @functools.native_method
  def set_code(self, code:'str'   ) -> None:
    r''''''

    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'

    self.py__code = code



    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)

    py__string_code = utils.py_string_to_string(code)
    py__string_code.shouldBeDeleted = False


    self._ptr.call_with_return(78,tuple([py__string_code._ptr]))

  @functools.native_method
  def get_code(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_default_texture_parameter(self, name:'object'   , texture:'py4godot_texture.Texture'   , index:'int' =0  ) -> None:
    r'''
				Sets the default texture to be used with a texture uniform. The default is used if a texture is not set in the `ShaderMaterial`.
				**Note:** `name` must match the name of the uniform in the code exactly.
				**Note:** If the sampler array is used use `index` to access the specified texture.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture')), 'texture must be Texture'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)



    self._ptr.call_with_return(80,tuple([py_stringname_name._ptr, texture._ptr, index]))

  @functools.native_method
  def get_default_texture_parameter(self, name:'object'   , index:'int' =0  ) -> typing.Any:
    r'''
				Returns the texture that is set as default for the specified parameter.
				**Note:** `name` must match the name of the uniform in the code exactly.
				**Note:** If the sampler array is used use `index` to access the specified texture.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture
    _ret._ptr = self._ptr.call_with_return(81,tuple([py_stringname_name._ptr, index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_shader_uniform_list(self, get_groups:'bool' =False  ) -> typing.Union['Array']:
    r'''
				Returns the list of shader uniforms that can be assigned to a `ShaderMaterial`, for use with `ShaderMaterial.set_shader_parameter` and `ShaderMaterial.get_shader_parameter`. The parameters returned are contained in dictionaries in a similar format to the ones returned by `Object.get_property_list`.
				If argument `get_groups` is `true`, parameter grouping hints are also included in the list.
			'''

    assert isinstance(get_groups, bool), 'get_groups must be bool'






    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([get_groups]))
    return _ret


  @functools.native_method
  def inspect_native_shader_code(self) -> None:
    r'''
				Only available when running in the editor. Opens a popup that visualizes the generated shader code, including all variants and internal shader code. See also `Material.inspect_native_shader_code`.
			'''




    self._ptr.call_with_return(83,tuple([]))


register_cast_function('Shader', Shader.cast)
register_class('Shader', Shader)
