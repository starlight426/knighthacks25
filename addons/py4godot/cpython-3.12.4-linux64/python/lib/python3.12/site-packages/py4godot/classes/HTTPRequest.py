# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.HTTPClient as py4godot_httpclient 
  import py4godot.classes.TLSOptions as py4godot_tlsoptions 
import py4godot.classes.Node as py4godot_node 
from py4godot.wrappers.wrappers import CPPHTTPRequestWrapper

class Result:
  RESULT_SUCCESS = 0
  RESULT_CHUNKED_BODY_SIZE_MISMATCH = 1
  RESULT_CANT_CONNECT = 2
  RESULT_CANT_RESOLVE = 3
  RESULT_CONNECTION_ERROR = 4
  RESULT_TLS_HANDSHAKE_ERROR = 5
  RESULT_NO_RESPONSE = 6
  RESULT_BODY_SIZE_LIMIT_EXCEEDED = 7
  RESULT_BODY_DECOMPRESS_FAILED = 8
  RESULT_REQUEST_FAILED = 9
  RESULT_DOWNLOAD_FILE_CANT_OPEN = 10
  RESULT_DOWNLOAD_FILE_WRITE_ERROR = 11
  RESULT_REDIRECT_LIMIT_REACHED = 12
  RESULT_TIMEOUT = 13


class HTTPRequest(py4godot_node.Node):
  r'''
		A node with the ability to send HTTP requests. Uses `HTTPClient` internally.
		Can be used to make HTTP requests, i.e. download or upload files or web content via HTTP.
		**Warning:** See the notes and warnings on `HTTPClient` for limitations, especially regarding TLS security.
		**Note:** When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
		**Example:** Contact a REST API and print one of its returned fields:
		
		```gdscript
		func _ready():
			# Create an HTTP request node and connect its completion signal.
			var http_request = HTTPRequest.new()
			add_child(http_request)
			http_request.request_completed.connect(self._http_request_completed)

			# Perform a GET request. The URL below returns JSON as of writing.
			var error = http_request.request("https://httpbin.org/get")
			if error != OK:
				push_error("An error occurred in the HTTP request.")

			# Perform a POST request. The URL below returns JSON as of writing.
			# Note: Don't make simultaneous requests using a single HTTPRequest node.
			# The snippet below is provided for reference only.
			var body = JSON.new().stringify({"name": "Godette"})
			error = http_request.request("https://httpbin.org/post", ``, HTTPClient.METHOD_POST, body)
			if error != OK:
				push_error("An error occurred in the HTTP request.")

		# Called when the HTTP request is completed.
		func _http_request_completed(result, response_code, headers, body):
			var json = JSON.new()
			json.parse(body.get_string_from_utf8())
			var response = json.get_data()

			# Will print the user agent string used by the HTTPRequest node (as recognized by httpbin.org).
			print(response.headers`"User-Agent"`)
		```
		
		
		**Example:** Load an image using `HTTPRequest` and display it:
		
		```gdscript
		func _ready():
			# Create an HTTP request node and connect its completion signal.
			var http_request = HTTPRequest.new()
			add_child(http_request)
			http_request.request_completed.connect(self._http_request_completed)

			# Perform the HTTP request. The URL below returns a PNG image as of writing.
			var error = http_request.request("https://placehold.co/512.png")
			if error != OK:
				push_error("An error occurred in the HTTP request.")

		# Called when the HTTP request is completed.
		func _http_request_completed(result, response_code, headers, body):
			if result != HTTPRequest.RESULT_SUCCESS:
				push_error("Image couldn't be downloaded. Try a different image.")

			var image = Image.new()
			var error = image.load_png_from_buffer(body)
			if error != OK:
				push_error("Couldn't load the image.")

			var texture = ImageTexture.create_from_image(image)

			# Display the image in a TextureRect node.
			var texture_rect = TextureRect.new()
			add_child(texture_rect)
			texture_rect.texture = texture
		```
		
		
		**Note:** `HTTPRequest` nodes will automatically handle decompression of response bodies. An `Accept-Encoding` header will be automatically added to each of your requests, unless one is already specified. Any response with a `Content-Encoding: gzip` header will automatically be decompressed and delivered to you as uncompressed bytes.
	'''

  @staticmethod
  def constructor():
    class_ = HTTPRequest.construct_without_init()
    class_._ptr = constructor(398,0, ())
    return class_
  @staticmethod
  def new():
    class_ = HTTPRequest.construct_without_init()
    class_._ptr = constructor(398,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPHTTPRequestWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(398,0, ())


  def generate_wrapper(self):
    return CPPHTTPRequestWrapper()
  def init_signals(self):
    super().init_signals()
    request_completed_name = utils.py_string_to_string_name("request_completed")
    self.request_completed = signals.BuiltinSignal(self, request_completed_name)

  @staticmethod
  def construct_without_init():
    cls = HTTPRequest.__new__(HTTPRequest)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'HTTPRequest'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = HTTPRequest.construct_without_init()
    cls._ptr = CPPHTTPRequestWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = HTTPRequest.construct_without_init()
    cls._ptr = CPPHTTPRequestWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def download_file(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_download_file()
    return _ret
  @download_file.setter
  def download_file(self,  value:'str'):
    self.set_download_file(value)
  @property
  def download_chunk_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_download_chunk_size()
    return _ret
  @download_chunk_size.setter
  def download_chunk_size(self,  value:'int'):
    self.set_download_chunk_size(value)
  @property
  def use_threads(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_threads()
    return _ret
  @use_threads.setter
  def use_threads(self,  value:'bool'):
    self.set_use_threads(value)
  @property
  def accept_gzip(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_accepting_gzip()
    return _ret
  @accept_gzip.setter
  def accept_gzip(self,  value:'bool'):
    self.set_accept_gzip(value)
  @property
  def body_size_limit(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_body_size_limit()
    return _ret
  @body_size_limit.setter
  def body_size_limit(self,  value:'int'):
    self.set_body_size_limit(value)
  @property
  def max_redirects(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_redirects()
    return _ret
  @max_redirects.setter
  def max_redirects(self,  value:'int'):
    self.set_max_redirects(value)
  @property
  def timeout(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_timeout()
    return _ret
  @timeout.setter
  def timeout(self,  value:'float'):
    self.set_timeout(value)
  @functools.native_method
  def request(self, url:'str'   , custom_headers:'PackedStringArray' = None  , method:'int'  =0, request_data:'str' =""  ) -> typing.Union[int]:
    r'''
				Creates request on the underlying `HTTPClient`. If there is no configuration errors, it tries to connect using `HTTPClient.connect_to_host` and passes parameters onto `HTTPClient.request`.
				Returns `constant OK` if request is successfully created. (Does not imply that the server has responded), `constant ERR_UNCONFIGURED` if not in the tree, `constant ERR_BUSY` if still processing previous request, `constant ERR_INVALID_PARAMETER` if given string is not a valid URL format, or `constant ERR_CANT_CONNECT` if not using thread and the `HTTPClient` cannot connect to host.
				**Note:** When `method` is `constant HTTPClient.METHOD_GET`, the payload sent via `request_data` might be ignored by the server or even cause the server to reject the request (check `url=https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1`RFC 7231 section 4.3.1`/url` for more details). As a workaround, you can send data as a query string in the URL (see `String.uri_encode` for an example).
				**Note:** It's recommended to use transport encryption (TLS) and to avoid sending sensitive information (such as login credentials) in HTTP GET URL parameters. Consider using HTTP POST requests or HTTP headers for such information instead.
			'''
    if custom_headers is None:
      custom_headers = PackedStringArray.new0()

    if request_data is None:
      request_data = String.new0()
    if custom_headers is None:
      custom_headers = PackedStringArray.new0()

    if request_data is None:
      request_data = String.new0()

    assert(not url is None)
    assert isinstance(url, (str, String)), 'url must be str or String'
    assert isinstance(method, (int, float)), 'method must be int or float'




    assert(isinstance(url, (str, String)))
    py_string_url = url if isinstance(url, StringName) else c_utils.py_string_to_string(url)


    assert(isinstance(request_data, (str, String)))
    py_string_request_data = request_data if isinstance(request_data, StringName) else c_utils.py_string_to_string(request_data)

    _ret:int
    _ret = self._ptr.call_with_return(180,tuple([py_string_url._ptr, custom_headers._ptr, method, py_string_request_data._ptr]))
    return _ret


  @functools.native_method
  def request_raw(self, url:'str'   , custom_headers:'PackedStringArray' = None  , method:'int'  =0, request_data_raw:'PackedByteArray' = None  ) -> typing.Union[int]:
    r'''
				Creates request on the underlying `HTTPClient` using a raw array of bytes for the request body. If there is no configuration errors, it tries to connect using `HTTPClient.connect_to_host` and passes parameters onto `HTTPClient.request`.
				Returns `constant OK` if request is successfully created. (Does not imply that the server has responded), `constant ERR_UNCONFIGURED` if not in the tree, `constant ERR_BUSY` if still processing previous request, `constant ERR_INVALID_PARAMETER` if given string is not a valid URL format, or `constant ERR_CANT_CONNECT` if not using thread and the `HTTPClient` cannot connect to host.
			'''
    if custom_headers is None:
      custom_headers = PackedStringArray.new0()

    if request_data_raw is None:
      request_data_raw = PackedByteArray.new0()
    if custom_headers is None:
      custom_headers = PackedStringArray.new0()

    if request_data_raw is None:
      request_data_raw = PackedByteArray.new0()

    assert(not url is None)
    assert isinstance(url, (str, String)), 'url must be str or String'
    assert isinstance(method, (int, float)), 'method must be int or float'




    assert(isinstance(url, (str, String)))
    py_string_url = url if isinstance(url, StringName) else c_utils.py_string_to_string(url)




    _ret:int
    _ret = self._ptr.call_with_return(181,tuple([py_string_url._ptr, custom_headers._ptr, method, request_data_raw._ptr]))
    return _ret


  @functools.native_method
  def cancel_request(self) -> None:
    r'''
				Cancels the current request.
			'''




    self._ptr.call_with_return(182,tuple([]))

  @functools.native_method
  def set_tls_options(self, client_options:'py4godot_tlsoptions.TLSOptions'   ) -> None:
    r'''
				Sets the `TLSOptions` to be used when connecting to an HTTPS server. See `TLSOptions.client`.
			'''

    assert(not client_options is None)
    assert isinstance(client_options, get_class('TLSOptions')), 'client_options must be TLSOptions'






    self._ptr.call_with_return(183,tuple([client_options._ptr]))

  @functools.native_method
  def get_http_client_status(self) -> typing.Union[int]:
    r'''
				Returns the current status of the underlying `HTTPClient`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(184,tuple([]))
    return _ret


  @functools.native_method
  def set_use_threads(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__use_threads = enable






    self._ptr.call_with_return(185,tuple([enable]))

  @functools.native_method
  def is_using_threads(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(186,tuple([]))

    return _ret


  @functools.native_method
  def set_accept_gzip(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__accept_gzip = enable






    self._ptr.call_with_return(187,tuple([enable]))

  @functools.native_method
  def is_accepting_gzip(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(188,tuple([]))

    return _ret


  @functools.native_method
  def set_body_size_limit(self, bytes:'int'   ) -> None:
    r''''''

    assert isinstance(bytes, (int, float)), 'bytes must be int or float'

    self.py__body_size_limit = bytes






    self._ptr.call_with_return(189,tuple([bytes]))

  @functools.native_method
  def get_body_size_limit(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(190,tuple([]))

    return _ret


  @functools.native_method
  def set_max_redirects(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'

    self.py__max_redirects = amount






    self._ptr.call_with_return(191,tuple([amount]))

  @functools.native_method
  def get_max_redirects(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))

    return _ret


  @functools.native_method
  def set_download_file(self, path:'str'   ) -> None:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'

    self.py__download_file = path



    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    py__string_path = utils.py_string_to_string(path)
    py__string_path.shouldBeDeleted = False


    self._ptr.call_with_return(193,tuple([py__string_path._ptr]))

  @functools.native_method
  def get_download_file(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(194,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_downloaded_bytes(self) -> typing.Union[int]:
    r'''
				Returns the number of bytes this HTTPRequest downloaded.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(195,tuple([]))
    return _ret


  @functools.native_method
  def get_body_size(self) -> typing.Union[int]:
    r'''
				Returns the response body length.
				**Note:** Some Web servers may not send a body length. In this case, the value returned will be `-1`. If using chunked transfer encoding, the body length will also be `-1`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(196,tuple([]))
    return _ret


  @functools.native_method
  def set_timeout(self, timeout:'float'   ) -> None:
    r''''''

    assert isinstance(timeout, (int, float)), 'timeout must be int or float'

    self.py__timeout = timeout






    self._ptr.call_with_return(197,tuple([timeout]))

  @functools.native_method
  def get_timeout(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(198,tuple([]))

    return _ret


  @functools.native_method
  def set_download_chunk_size(self, chunk_size:'int'   ) -> None:
    r''''''

    assert isinstance(chunk_size, (int, float)), 'chunk_size must be int or float'

    self.py__download_chunk_size = chunk_size






    self._ptr.call_with_return(199,tuple([chunk_size]))

  @functools.native_method
  def get_download_chunk_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(200,tuple([]))

    return _ret


  @functools.native_method
  def set_http_proxy(self, host:'str'   , port:'int'   ) -> None:
    r'''
				Sets the proxy server for HTTP requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			'''

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(port, (int, float)), 'port must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)


    self._ptr.call_with_return(201,tuple([py_string_host._ptr, port]))

  @functools.native_method
  def set_https_proxy(self, host:'str'   , port:'int'   ) -> None:
    r'''
				Sets the proxy server for HTTPS requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			'''

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(port, (int, float)), 'port must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)


    self._ptr.call_with_return(202,tuple([py_string_host._ptr, port]))


register_cast_function('HTTPRequest', HTTPRequest.cast)
register_class('HTTPRequest', HTTPRequest)
