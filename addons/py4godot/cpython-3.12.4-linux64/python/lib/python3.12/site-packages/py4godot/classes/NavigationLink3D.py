# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Node3D as py4godot_node3d 
from py4godot.wrappers.wrappers import CPPNavigationLink3DWrapper


class NavigationLink3D(py4godot_node3d.Node3D):
  r'''
		A link between two positions on `NavigationRegion3D`s that agents can be routed through. These positions can be on the same `NavigationRegion3D` or on two different ones. Links are useful to express navigation methods other than traveling along the surface of the navigation mesh, such as ziplines, teleporters, or gaps that can be jumped across.
	'''

  @staticmethod
  def constructor():
    class_ = NavigationLink3D.construct_without_init()
    class_._ptr = constructor(497,0, ())
    return class_
  @staticmethod
  def new():
    class_ = NavigationLink3D.construct_without_init()
    class_._ptr = constructor(497,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNavigationLink3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(497,0, ())


  def generate_wrapper(self):
    return CPPNavigationLink3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = NavigationLink3D.__new__(NavigationLink3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NavigationLink3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationLink3D.construct_without_init()
    cls._ptr = CPPNavigationLink3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationLink3D.construct_without_init()
    cls._ptr = CPPNavigationLink3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_enabled()
    return _ret
  @enabled.setter
  def enabled(self,  value:'bool'):
    self.set_enabled(value)
  @property
  def bidirectional(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_bidirectional()
    return _ret
  @bidirectional.setter
  def bidirectional(self,  value:'bool'):
    self.set_bidirectional(value)
  @property
  def navigation_layers(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_navigation_layers()
    return _ret
  @navigation_layers.setter
  def navigation_layers(self,  value:'int'):
    self.set_navigation_layers(value)
  @property
  def start_position(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_start_position()
    return _ret
  @start_position.setter
  def start_position(self,  value:'Vector3'):
    self.set_start_position(value)
  @property
  def end_position(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_end_position()
    return _ret
  @end_position.setter
  def end_position(self,  value:'Vector3'):
    self.set_end_position(value)
  @property
  def enter_cost(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_enter_cost()
    return _ret
  @enter_cost.setter
  def enter_cost(self,  value:'float'):
    self.set_enter_cost(value)
  @property
  def travel_cost(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_travel_cost()
    return _ret
  @travel_cost.setter
  def travel_cost(self,  value:'float'):
    self.set_travel_cost(value)
  @functools.native_method
  def get_rid(self) -> typing.Union['RID']:
    r'''
				Returns the `RID` of this link on the `NavigationServer3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(251,tuple([]))
    return _ret


  @functools.native_method
  def set_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__enabled = enabled






    self._ptr.call_with_return(252,tuple([enabled]))

  @functools.native_method
  def is_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(253,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_map(self, navigation_map:'RID'   ) -> None:
    r'''
				Sets the `RID` of the navigation map this link should use. By default the link will automatically join the `World3D` default navigation map so this function is only required to override the default map.
			'''

    assert(not navigation_map is None)
    assert isinstance(navigation_map, RID), 'navigation_map must be RID'






    self._ptr.call_with_return(254,tuple([navigation_map._ptr]))

  @functools.native_method
  def get_navigation_map(self) -> typing.Union['RID']:
    r'''
				Returns the current navigation map `RID` used by this link.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(255,tuple([]))
    return _ret


  @functools.native_method
  def set_bidirectional(self, bidirectional:'bool'   ) -> None:
    r''''''

    assert isinstance(bidirectional, bool), 'bidirectional must be bool'

    self.py__bidirectional = bidirectional






    self._ptr.call_with_return(256,tuple([bidirectional]))

  @functools.native_method
  def is_bidirectional(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(257,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_layers(self, navigation_layers:'int'   ) -> None:
    r''''''

    assert isinstance(navigation_layers, (int, float)), 'navigation_layers must be int or float'

    self.py__navigation_layers = navigation_layers






    self._ptr.call_with_return(258,tuple([navigation_layers]))

  @functools.native_method
  def get_navigation_layers(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(259,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_layer_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `navigation_layers` bitmask, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'







    self._ptr.call_with_return(260,tuple([layer_number, value]))

  @functools.native_method
  def get_navigation_layer_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `navigation_layers` bitmask is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(261,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_start_position(self, position:'Vector3'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'

    self.py__start_position = position






    self._ptr.call_with_return(262,tuple([position._ptr]))

  @functools.native_method
  def get_start_position(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(263,tuple([]))

    return _ret


  @functools.native_method
  def set_end_position(self, position:'Vector3'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'

    self.py__end_position = position






    self._ptr.call_with_return(264,tuple([position._ptr]))

  @functools.native_method
  def get_end_position(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_global_start_position(self, position:'Vector3'   ) -> None:
    r'''
				Sets the `start_position` that is relative to the link from a global `position`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'






    self._ptr.call_with_return(266,tuple([position._ptr]))

  @functools.native_method
  def get_global_start_position(self) -> typing.Union['Vector3']:
    r'''
				Returns the `start_position` that is relative to the link as a global position.
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(267,tuple([]))
    return _ret


  @functools.native_method
  def set_global_end_position(self, position:'Vector3'   ) -> None:
    r'''
				Sets the `end_position` that is relative to the link from a global `position`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'






    self._ptr.call_with_return(268,tuple([position._ptr]))

  @functools.native_method
  def get_global_end_position(self) -> typing.Union['Vector3']:
    r'''
				Returns the `end_position` that is relative to the link as a global position.
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(269,tuple([]))
    return _ret


  @functools.native_method
  def set_enter_cost(self, enter_cost:'float'   ) -> None:
    r''''''

    assert isinstance(enter_cost, (int, float)), 'enter_cost must be int or float'

    self.py__enter_cost = enter_cost






    self._ptr.call_with_return(270,tuple([enter_cost]))

  @functools.native_method
  def get_enter_cost(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_travel_cost(self, travel_cost:'float'   ) -> None:
    r''''''

    assert isinstance(travel_cost, (int, float)), 'travel_cost must be int or float'

    self.py__travel_cost = travel_cost






    self._ptr.call_with_return(272,tuple([travel_cost]))

  @functools.native_method
  def get_travel_cost(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(273,tuple([]))

    return _ret



register_cast_function('NavigationLink3D', NavigationLink3D.cast)
register_class('NavigationLink3D', NavigationLink3D)
