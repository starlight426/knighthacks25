# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPUPNPDeviceWrapper

class IGDStatus:
  IGD_STATUS_OK = 0
  IGD_STATUS_HTTP_ERROR = 1
  IGD_STATUS_HTTP_EMPTY = 2
  IGD_STATUS_NO_URLS = 3
  IGD_STATUS_NO_IGD = 4
  IGD_STATUS_DISCONNECTED = 5
  IGD_STATUS_UNKNOWN_DEVICE = 6
  IGD_STATUS_INVALID_CONTROL = 7
  IGD_STATUS_MALLOC_ERROR = 8
  IGD_STATUS_UNKNOWN_ERROR = 9


class UPNPDevice(py4godot_refcounted.RefCounted):
  r''''''

  @staticmethod
  def constructor():
    class_ = UPNPDevice.construct_without_init()
    class_._ptr = constructor(857,0, ())
    return class_
  @staticmethod
  def new():
    class_ = UPNPDevice.construct_without_init()
    class_._ptr = constructor(857,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPUPNPDeviceWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(857,0, ())


  def generate_wrapper(self):
    return CPPUPNPDeviceWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = UPNPDevice.__new__(UPNPDevice)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'UPNPDevice'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = UPNPDevice.construct_without_init()
    cls._ptr = CPPUPNPDeviceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = UPNPDevice.construct_without_init()
    cls._ptr = CPPUPNPDeviceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def description_url(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_description_url()
    return _ret
  @description_url.setter
  def description_url(self,  value:'str'):
    self.set_description_url(value)
  @property
  def service_type(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_service_type()
    return _ret
  @service_type.setter
  def service_type(self,  value:'str'):
    self.set_service_type(value)
  @property
  def igd_control_url(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_igd_control_url()
    return _ret
  @igd_control_url.setter
  def igd_control_url(self,  value:'str'):
    self.set_igd_control_url(value)
  @property
  def igd_service_type(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_igd_service_type()
    return _ret
  @igd_service_type.setter
  def igd_service_type(self,  value:'str'):
    self.set_igd_service_type(value)
  @property
  def igd_our_addr(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_igd_our_addr()
    return _ret
  @igd_our_addr.setter
  def igd_our_addr(self,  value:'str'):
    self.set_igd_our_addr(value)
  @property
  def igd_status(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_igd_status()
    return _ret
  @igd_status.setter
  def igd_status(self,  value:'int'):
    self.set_igd_status(value)
  @functools.native_method
  def is_valid_gateway(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def query_external_address(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def add_port_mapping(self, port:'int'   , port_internal:'int' =0  , desc:'str' =""  , proto:'str' ="UDP"  , duration:'int' =0  ) -> typing.Union[int]:
    r''''''
    if desc is None:
      desc = String.new0()
    if proto is None:
      proto = String.new0()
    if desc is None:
      desc = String.new0()
    if proto is None:
      proto = String.new0()

    assert isinstance(port, (int, float)), 'port must be int or float'
    assert isinstance(port_internal, (int, float)), 'port_internal must be int or float'
    assert isinstance(duration, (int, float)), 'duration must be int or float'






    assert(isinstance(desc, (str, String)))
    py_string_desc = desc if isinstance(desc, StringName) else c_utils.py_string_to_string(desc)
    assert(isinstance(proto, (str, String)))
    py_string_proto = proto if isinstance(proto, StringName) else c_utils.py_string_to_string(proto)


    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([port, port_internal, py_string_desc._ptr, py_string_proto._ptr, duration]))
    return _ret


  @functools.native_method
  def delete_port_mapping(self, port:'int'   , proto:'str' ="UDP"  ) -> typing.Union[int]:
    r''''''
    if proto is None:
      proto = String.new0()
    if proto is None:
      proto = String.new0()

    assert isinstance(port, (int, float)), 'port must be int or float'





    assert(isinstance(proto, (str, String)))
    py_string_proto = proto if isinstance(proto, StringName) else c_utils.py_string_to_string(proto)

    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([port, py_string_proto._ptr]))
    return _ret


  @functools.native_method
  def set_description_url(self, url:'str'   ) -> None:
    r''''''

    assert(not url is None)
    assert isinstance(url, (str, String)), 'url must be str or String'

    self.py__description_url = url



    assert(isinstance(url, (str, String)))
    py_string_url = url if isinstance(url, StringName) else c_utils.py_string_to_string(url)

    py__string_url = utils.py_string_to_string(url)
    py__string_url.shouldBeDeleted = False


    self._ptr.call_with_return(57,tuple([py__string_url._ptr]))

  @functools.native_method
  def get_description_url(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_service_type(self, type:'str'   ) -> None:
    r''''''

    assert(not type is None)
    assert isinstance(type, (str, String)), 'type must be str or String'

    self.py__service_type = type



    assert(isinstance(type, (str, String)))
    py_string_type = type if isinstance(type, StringName) else c_utils.py_string_to_string(type)

    py__string_type = utils.py_string_to_string(type)
    py__string_type.shouldBeDeleted = False


    self._ptr.call_with_return(59,tuple([py__string_type._ptr]))

  @functools.native_method
  def get_service_type(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_igd_control_url(self, url:'str'   ) -> None:
    r''''''

    assert(not url is None)
    assert isinstance(url, (str, String)), 'url must be str or String'

    self.py__igd_control_url = url



    assert(isinstance(url, (str, String)))
    py_string_url = url if isinstance(url, StringName) else c_utils.py_string_to_string(url)

    py__string_url = utils.py_string_to_string(url)
    py__string_url.shouldBeDeleted = False


    self._ptr.call_with_return(61,tuple([py__string_url._ptr]))

  @functools.native_method
  def get_igd_control_url(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_igd_service_type(self, type:'str'   ) -> None:
    r''''''

    assert(not type is None)
    assert isinstance(type, (str, String)), 'type must be str or String'

    self.py__igd_service_type = type



    assert(isinstance(type, (str, String)))
    py_string_type = type if isinstance(type, StringName) else c_utils.py_string_to_string(type)

    py__string_type = utils.py_string_to_string(type)
    py__string_type.shouldBeDeleted = False


    self._ptr.call_with_return(63,tuple([py__string_type._ptr]))

  @functools.native_method
  def get_igd_service_type(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_igd_our_addr(self, addr:'str'   ) -> None:
    r''''''

    assert(not addr is None)
    assert isinstance(addr, (str, String)), 'addr must be str or String'

    self.py__igd_our_addr = addr



    assert(isinstance(addr, (str, String)))
    py_string_addr = addr if isinstance(addr, StringName) else c_utils.py_string_to_string(addr)

    py__string_addr = utils.py_string_to_string(addr)
    py__string_addr.shouldBeDeleted = False


    self._ptr.call_with_return(65,tuple([py__string_addr._ptr]))

  @functools.native_method
  def get_igd_our_addr(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_igd_status(self, status:'int'  ) -> None:
    r''''''

    assert isinstance(status, (int, float)), 'status must be int or float'

    self.py__igd_status = status






    self._ptr.call_with_return(67,tuple([status]))

  @functools.native_method
  def get_igd_status(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(68,tuple([]))

    return _ret



register_cast_function('UPNPDevice', UPNPDevice.cast)
register_class('UPNPDevice', UPNPDevice)
