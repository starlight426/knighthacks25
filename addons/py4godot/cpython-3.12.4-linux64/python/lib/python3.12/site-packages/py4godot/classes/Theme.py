# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.StyleBoxTexture as py4godot_styleboxtexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.StyleBox as py4godot_stylebox 
  import py4godot.classes.SystemFont as py4godot_systemfont 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.FontFile as py4godot_fontfile 
  import py4godot.classes.StyleBoxLine as py4godot_styleboxline 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.StyleBoxFlat as py4godot_styleboxflat 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.StyleBoxEmpty as py4godot_styleboxempty 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.FontVariation as py4godot_fontvariation 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPThemeWrapper

class DataType:
  DATA_TYPE_COLOR = 0
  DATA_TYPE_CONSTANT = 1
  DATA_TYPE_FONT = 2
  DATA_TYPE_FONT_SIZE = 3
  DATA_TYPE_ICON = 4
  DATA_TYPE_STYLEBOX = 5
  DATA_TYPE_MAX = 6


class Theme(py4godot_resource.Resource):
  r'''
		A resource used for styling/skinning `Control` and `Window` nodes. While individual controls can be styled using their local theme overrides (see `Control.add_theme_color_override`), theme resources allow you to store and apply the same settings across all controls sharing the same type (e.g. style all `Button`s the same). One theme resource can be used for the entire project, but you can also set a separate theme resource to a branch of control nodes. A theme resource assigned to a control applies to the control itself, as well as all of its direct and indirect children (as long as a chain of controls is uninterrupted).
		Use `ProjectSettings.gui/theme/custom` to set up a project-scope theme that will be available to every control in your project.
		Use `Control.theme` of any control node to set up a theme that will be available to that control and all of its direct and indirect children.
	'''

  @staticmethod
  def constructor():
    class_ = Theme.construct_without_init()
    class_._ptr = constructor(831,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Theme.construct_without_init()
    class_._ptr = constructor(831,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPThemeWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(831,0, ())


  def generate_wrapper(self):
    return CPPThemeWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Theme.__new__(Theme)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Theme'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Theme.construct_without_init()
    cls._ptr = CPPThemeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Theme.construct_without_init()
    cls._ptr = CPPThemeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def default_base_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_default_base_scale()
    return _ret
  @default_base_scale.setter
  def default_base_scale(self,  value:'float'):
    self.set_default_base_scale(value)
  @property
  def default_font(self) -> typing.Union['py4godot_font.Font','py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation']:
    r''''''
    _ret = self. get_default_font()
    return _ret
  @default_font.setter
  def default_font(self,  value:'py4godot_object.Object'):
    self.set_default_font(value)
  @property
  def default_font_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_default_font_size()
    return _ret
  @default_font_size.setter
  def default_font_size(self,  value:'int'):
    self.set_default_font_size(value)
  @functools.native_method
  def set_icon(self, name:'object'   , theme_type:'object'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Creates or changes the value of the icon property defined by `name` and `theme_type`. Use `clear_icon` to remove the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(77,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr, texture._ptr]))

  @functools.native_method
  def get_icon(self, name:'object'   , theme_type:'object'   ) -> typing.Any:
    r'''
				Returns the icon property defined by `name` and `theme_type`, if it exists.
				Returns the engine fallback icon value if the property doesn't exist (see `ThemeDB.fallback_icon`). Use `has_icon` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(78,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def has_icon(self, name:'object'   , theme_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the icon property defined by `name` and `theme_type` exists.
				Returns `false` if it doesn't exist. Use `set_icon` to define it.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def rename_icon(self, old_name:'object'   , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the icon property defined by `old_name` and `theme_type` to `name`, if it exists.
				Fails if it doesn't exist, or if a similar property with the new name already exists. Use `has_icon` to check for existence, and `clear_icon` to remove the existing property.
			'''

    assert(not old_name is None)
    assert isinstance(old_name, (str, StringName)), 'old_name must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(old_name, (str, StringName)))
    py_stringname_old_name = old_name if isinstance(old_name, StringName) else c_utils.py_string_to_string_name(old_name)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(80,tuple([py_stringname_old_name._ptr, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def clear_icon(self, name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Removes the icon property defined by `name` and `theme_type`, if it exists.
				Fails if it doesn't exist. Use `has_icon` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(81,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_icon_list(self, theme_type:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of names for icon properties defined with `theme_type`. Use `get_icon_type_list` to get a list of possible theme type names.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, String)), 'theme_type must be str or String'




    assert(isinstance(theme_type, (str, String)))
    py_string_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string(theme_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([py_string_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_icon_type_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names for icon properties. Use `get_type_list` to get a list of all unique theme types.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def set_stylebox(self, name:'object'   , theme_type:'object'   , texture:'py4godot_stylebox.StyleBox'   ) -> None:
    r'''
				Creates or changes the value of the `StyleBox` property defined by `name` and `theme_type`. Use `clear_stylebox` to remove the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert(not texture is None)
    assert isinstance(texture, get_class('StyleBox')), 'texture must be StyleBox'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(84,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr, texture._ptr]))

  @functools.native_method
  def get_stylebox(self, name:'object'   , theme_type:'object'   ) -> typing.Union['py4godot_stylebox.StyleBox','py4godot_styleboxflat.StyleBoxFlat','py4godot_styleboxtexture.StyleBoxTexture','py4godot_styleboxempty.StyleBoxEmpty','py4godot_styleboxline.StyleBoxLine']:
    r'''
				Returns the `StyleBox` property defined by `name` and `theme_type`, if it exists.
				Returns the engine fallback stylebox value if the property doesn't exist (see `ThemeDB.fallback_stylebox`). Use `has_stylebox` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: StyleBox
    _ret._ptr = self._ptr.call_with_return(85,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def has_stylebox(self, name:'object'   , theme_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `StyleBox` property defined by `name` and `theme_type` exists.
				Returns `false` if it doesn't exist. Use `set_stylebox` to define it.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def rename_stylebox(self, old_name:'object'   , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the `StyleBox` property defined by `old_name` and `theme_type` to `name`, if it exists.
				Fails if it doesn't exist, or if a similar property with the new name already exists. Use `has_stylebox` to check for existence, and `clear_stylebox` to remove the existing property.
			'''

    assert(not old_name is None)
    assert isinstance(old_name, (str, StringName)), 'old_name must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(old_name, (str, StringName)))
    py_stringname_old_name = old_name if isinstance(old_name, StringName) else c_utils.py_string_to_string_name(old_name)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(87,tuple([py_stringname_old_name._ptr, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def clear_stylebox(self, name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Removes the `StyleBox` property defined by `name` and `theme_type`, if it exists.
				Fails if it doesn't exist. Use `has_stylebox` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(88,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_stylebox_list(self, theme_type:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of names for `StyleBox` properties defined with `theme_type`. Use `get_stylebox_type_list` to get a list of possible theme type names.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, String)), 'theme_type must be str or String'




    assert(isinstance(theme_type, (str, String)))
    py_string_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string(theme_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([py_string_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_stylebox_type_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names for `StyleBox` properties. Use `get_type_list` to get a list of all unique theme types.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def set_font(self, name:'object'   , theme_type:'object'   , font:'py4godot_font.Font'   ) -> None:
    r'''
				Creates or changes the value of the `Font` property defined by `name` and `theme_type`. Use `clear_font` to remove the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(91,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr, font._ptr]))

  @functools.native_method
  def get_font(self, name:'object'   , theme_type:'object'   ) -> typing.Union['py4godot_font.Font','py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation']:
    r'''
				Returns the `Font` property defined by `name` and `theme_type`, if it exists.
				Returns the default theme font if the property doesn't exist and the default theme font is set up (see `default_font`). Use `has_font` to check for existence of the property and `has_default_font` to check for existence of the default theme font.
				Returns the engine fallback font value, if neither exist (see `ThemeDB.fallback_font`).
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(92,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def has_font(self, name:'object'   , theme_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `Font` property defined by `name` and `theme_type` exists, or if the default theme font is set up (see `has_default_font`).
				Returns `false` if neither exist. Use `set_font` to define the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def rename_font(self, old_name:'object'   , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the `Font` property defined by `old_name` and `theme_type` to `name`, if it exists.
				Fails if it doesn't exist, or if a similar property with the new name already exists. Use `has_font` to check for existence, and `clear_font` to remove the existing property.
			'''

    assert(not old_name is None)
    assert isinstance(old_name, (str, StringName)), 'old_name must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(old_name, (str, StringName)))
    py_stringname_old_name = old_name if isinstance(old_name, StringName) else c_utils.py_string_to_string_name(old_name)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(94,tuple([py_stringname_old_name._ptr, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def clear_font(self, name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Removes the `Font` property defined by `name` and `theme_type`, if it exists.
				Fails if it doesn't exist. Use `has_font` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(95,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_font_list(self, theme_type:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of names for `Font` properties defined with `theme_type`. Use `get_font_type_list` to get a list of possible theme type names.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, String)), 'theme_type must be str or String'




    assert(isinstance(theme_type, (str, String)))
    py_string_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string(theme_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([py_string_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_font_type_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names for `Font` properties. Use `get_type_list` to get a list of all unique theme types.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(97,tuple([]))
    return _ret


  @functools.native_method
  def set_font_size(self, name:'object'   , theme_type:'object'   , font_size:'int'   ) -> None:
    r'''
				Creates or changes the value of the font size property defined by `name` and `theme_type`. Use `clear_font_size` to remove the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(98,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr, font_size]))

  @functools.native_method
  def get_font_size(self, name:'object'   , theme_type:'object'   ) -> typing.Union[int]:
    r'''
				Returns the font size property defined by `name` and `theme_type`, if it exists.
				Returns the default theme font size if the property doesn't exist and the default theme font size is set up (see `default_font_size`). Use `has_font_size` to check for existence of the property and `has_default_font_size` to check for existence of the default theme font.
				Returns the engine fallback font size value, if neither exist (see `ThemeDB.fallback_font_size`).
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_font_size(self, name:'object'   , theme_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the font size property defined by `name` and `theme_type` exists, or if the default theme font size is set up (see `has_default_font_size`).
				Returns `false` if neither exist. Use `set_font_size` to define the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def rename_font_size(self, old_name:'object'   , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the font size property defined by `old_name` and `theme_type` to `name`, if it exists.
				Fails if it doesn't exist, or if a similar property with the new name already exists. Use `has_font_size` to check for existence, and `clear_font_size` to remove the existing property.
			'''

    assert(not old_name is None)
    assert isinstance(old_name, (str, StringName)), 'old_name must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(old_name, (str, StringName)))
    py_stringname_old_name = old_name if isinstance(old_name, StringName) else c_utils.py_string_to_string_name(old_name)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(101,tuple([py_stringname_old_name._ptr, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def clear_font_size(self, name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Removes the font size property defined by `name` and `theme_type`, if it exists.
				Fails if it doesn't exist. Use `has_font_size` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(102,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_font_size_list(self, theme_type:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of names for font size properties defined with `theme_type`. Use `get_font_size_type_list` to get a list of possible theme type names.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, String)), 'theme_type must be str or String'




    assert(isinstance(theme_type, (str, String)))
    py_string_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string(theme_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([py_string_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_font_size_type_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names for font size properties. Use `get_type_list` to get a list of all unique theme types.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([]))
    return _ret


  @functools.native_method
  def set_color(self, name:'object'   , theme_type:'object'   , color:'Color'   ) -> None:
    r'''
				Creates or changes the value of the `Color` property defined by `name` and `theme_type`. Use `clear_color` to remove the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(105,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr, color._ptr]))

  @functools.native_method
  def get_color(self, name:'object'   , theme_type:'object'   ) -> typing.Union['Color']:
    r'''
				Returns the `Color` property defined by `name` and `theme_type`, if it exists.
				Returns the default color value if the property doesn't exist. Use `has_color` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(106,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_color(self, name:'object'   , theme_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `Color` property defined by `name` and `theme_type` exists.
				Returns `false` if it doesn't exist. Use `set_color` to define it.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def rename_color(self, old_name:'object'   , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the `Color` property defined by `old_name` and `theme_type` to `name`, if it exists.
				Fails if it doesn't exist, or if a similar property with the new name already exists. Use `has_color` to check for existence, and `clear_color` to remove the existing property.
			'''

    assert(not old_name is None)
    assert isinstance(old_name, (str, StringName)), 'old_name must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(old_name, (str, StringName)))
    py_stringname_old_name = old_name if isinstance(old_name, StringName) else c_utils.py_string_to_string_name(old_name)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(108,tuple([py_stringname_old_name._ptr, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def clear_color(self, name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Removes the `Color` property defined by `name` and `theme_type`, if it exists.
				Fails if it doesn't exist. Use `has_color` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(109,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_color_list(self, theme_type:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of names for `Color` properties defined with `theme_type`. Use `get_color_type_list` to get a list of possible theme type names.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, String)), 'theme_type must be str or String'




    assert(isinstance(theme_type, (str, String)))
    py_string_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string(theme_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(110,tuple([py_string_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_color_type_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names for `Color` properties. Use `get_type_list` to get a list of all unique theme types.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(111,tuple([]))
    return _ret


  @functools.native_method
  def set_constant(self, name:'object'   , theme_type:'object'   , constant:'int'   ) -> None:
    r'''
				Creates or changes the value of the constant property defined by `name` and `theme_type`. Use `clear_constant` to remove the property.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert isinstance(constant, (int, float)), 'constant must be int or float'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(112,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr, constant]))

  @functools.native_method
  def get_constant(self, name:'object'   , theme_type:'object'   ) -> typing.Union[int]:
    r'''
				Returns the constant property defined by `name` and `theme_type`, if it exists.
				Returns `0` if the property doesn't exist. Use `has_constant` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(113,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_constant(self, name:'object'   , theme_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the constant property defined by `name` and `theme_type` exists.
				Returns `false` if it doesn't exist. Use `set_constant` to define it.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def rename_constant(self, old_name:'object'   , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the constant property defined by `old_name` and `theme_type` to `name`, if it exists.
				Fails if it doesn't exist, or if a similar property with the new name already exists. Use `has_constant` to check for existence, and `clear_constant` to remove the existing property.
			'''

    assert(not old_name is None)
    assert isinstance(old_name, (str, StringName)), 'old_name must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(old_name, (str, StringName)))
    py_stringname_old_name = old_name if isinstance(old_name, StringName) else c_utils.py_string_to_string_name(old_name)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(115,tuple([py_stringname_old_name._ptr, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def clear_constant(self, name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Removes the constant property defined by `name` and `theme_type`, if it exists.
				Fails if it doesn't exist. Use `has_constant` to check for existence.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(116,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_constant_list(self, theme_type:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of names for constant properties defined with `theme_type`. Use `get_constant_type_list` to get a list of possible theme type names.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, String)), 'theme_type must be str or String'




    assert(isinstance(theme_type, (str, String)))
    py_string_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string(theme_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(117,tuple([py_string_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_constant_type_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names for constant properties. Use `get_type_list` to get a list of all unique theme types.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(118,tuple([]))
    return _ret


  @functools.native_method
  def set_default_base_scale(self, base_scale:'float'   ) -> None:
    r''''''

    assert isinstance(base_scale, (int, float)), 'base_scale must be int or float'

    self.py__default_base_scale = base_scale






    self._ptr.call_with_return(119,tuple([base_scale]))

  @functools.native_method
  def get_default_base_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(120,tuple([]))

    return _ret


  @functools.native_method
  def has_default_base_scale(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `default_base_scale` has a valid value.
				Returns `false` if it doesn't. The value must be greater than `0.0` to be considered valid.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([]))
    return _ret


  @functools.native_method
  def set_default_font(self, font:'py4godot_font.Font'   ) -> None:
    r''''''

    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'

    self.py__default_font = font






    self._ptr.call_with_return(122,tuple([font._ptr]))

  @functools.native_method
  def get_default_font(self) -> typing.Union['py4godot_font.Font','py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(123,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def has_default_font(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `default_font` has a valid value.
				Returns `false` if it doesn't.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(124,tuple([]))
    return _ret


  @functools.native_method
  def set_default_font_size(self, font_size:'int'   ) -> None:
    r''''''

    assert isinstance(font_size, (int, float)), 'font_size must be int or float'

    self.py__default_font_size = font_size






    self._ptr.call_with_return(125,tuple([font_size]))

  @functools.native_method
  def get_default_font_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(126,tuple([]))

    return _ret


  @functools.native_method
  def has_default_font_size(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `default_font_size` has a valid value.
				Returns `false` if it doesn't. The value must be greater than `0` to be considered valid.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(127,tuple([]))
    return _ret


  @functools.native_method
  def set_theme_item(self, data_type:'int'  , name:'object'   , theme_type:'object'   , value:'object'   ) -> None:
    r'''
				Creates or changes the value of the theme property of `data_type` defined by `name` and `theme_type`. Use `clear_theme_item` to remove the property.
				Fails if the `value` type is not accepted by `data_type`.
				**Note:** This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
			'''

    assert isinstance(data_type, (int, float)), 'data_type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(128,tuple([data_type, py_stringname_name._ptr, py_stringname_theme_type._ptr, value]))

  @functools.native_method
  def get_theme_item(self, data_type:'int'  , name:'object'   , theme_type:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the theme property of `data_type` defined by `name` and `theme_type`, if it exists.
				Returns the engine fallback value if the property doesn't exist (see `ThemeDB`). Use `has_theme_item` to check for existence.
				**Note:** This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
			'''

    assert isinstance(data_type, (int, float)), 'data_type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = None
    _ret = self._ptr.call_with_return(129,tuple([data_type, py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_item(self, data_type:'int'  , name:'object'   , theme_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the theme property of `data_type` defined by `name` and `theme_type` exists.
				Returns `false` if it doesn't exist. Use `set_theme_item` to define it.
				**Note:** This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
			'''

    assert isinstance(data_type, (int, float)), 'data_type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(130,tuple([data_type, py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def rename_theme_item(self, data_type:'int'  , old_name:'object'   , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the theme property of `data_type` defined by `old_name` and `theme_type` to `name`, if it exists.
				Fails if it doesn't exist, or if a similar property with the new name already exists. Use `has_theme_item` to check for existence, and `clear_theme_item` to remove the existing property.
				**Note:** This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
			'''

    assert isinstance(data_type, (int, float)), 'data_type must be int or float'
    assert(not old_name is None)
    assert isinstance(old_name, (str, StringName)), 'old_name must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'





    assert(isinstance(old_name, (str, StringName)))
    py_stringname_old_name = old_name if isinstance(old_name, StringName) else c_utils.py_string_to_string_name(old_name)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(131,tuple([data_type, py_stringname_old_name._ptr, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def clear_theme_item(self, data_type:'int'  , name:'object'   , theme_type:'object'   ) -> None:
    r'''
				Removes the theme property of `data_type` defined by `name` and `theme_type`, if it exists.
				Fails if it doesn't exist. Use `has_theme_item` to check for existence.
				**Note:** This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
			'''

    assert isinstance(data_type, (int, float)), 'data_type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(132,tuple([data_type, py_stringname_name._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_theme_item_list(self, data_type:'int'  , theme_type:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of names for properties of `data_type` defined with `theme_type`. Use `get_theme_item_type_list` to get a list of possible theme type names.
				**Note:** This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
			'''

    assert isinstance(data_type, (int, float)), 'data_type must be int or float'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, String)), 'theme_type must be str or String'





    assert(isinstance(theme_type, (str, String)))
    py_string_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string(theme_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(133,tuple([data_type, py_string_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_theme_item_type_list(self, data_type:'int'  ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names for `data_type` properties. Use `get_type_list` to get a list of all unique theme types.
				**Note:** This method is analogous to calling the corresponding data type specific method, but can be used for more generalized logic.
			'''

    assert isinstance(data_type, (int, float)), 'data_type must be int or float'






    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(134,tuple([data_type]))
    return _ret


  @functools.native_method
  def set_type_variation(self, theme_type:'object'   , base_type:'object'   ) -> None:
    r'''
				Marks `theme_type` as a variation of `base_type`.
				This adds `theme_type` as a suggested option for `Control.theme_type_variation` on a `Control` that is of the `base_type` class.
				Variations can also be nested, i.e. `base_type` can be another variation. If a chain of variations ends with a `base_type` matching the class of the `Control`, the whole chain is going to be suggested as options.
				**Note:** Suggestions only show up if this theme resource is set as the project default theme. See `ProjectSettings.gui/theme/custom`.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert(not base_type is None)
    assert isinstance(base_type, (str, StringName)), 'base_type must be str or StringName'




    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)
    assert(isinstance(base_type, (str, StringName)))
    py_stringname_base_type = base_type if isinstance(base_type, StringName) else c_utils.py_string_to_string_name(base_type)

    self._ptr.call_with_return(135,tuple([py_stringname_theme_type._ptr, py_stringname_base_type._ptr]))

  @functools.native_method
  def is_type_variation(self, theme_type:'object'   , base_type:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `theme_type` is marked as a variation of `base_type`.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'
    assert(not base_type is None)
    assert isinstance(base_type, (str, StringName)), 'base_type must be str or StringName'




    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)
    assert(isinstance(base_type, (str, StringName)))
    py_stringname_base_type = base_type if isinstance(base_type, StringName) else c_utils.py_string_to_string_name(base_type)

    _ret = 0
    _ret = self._ptr.call_with_return(136,tuple([py_stringname_theme_type._ptr, py_stringname_base_type._ptr]))
    return _ret


  @functools.native_method
  def clear_type_variation(self, theme_type:'object'   ) -> None:
    r'''
				Unmarks `theme_type` as being a variation of another theme type. See `set_type_variation`.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(137,tuple([py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_type_variation_base(self, theme_type:'object'   ) -> typing.Union['StringName']:
    r'''
				Returns the name of the base theme type if `theme_type` is a valid variation type. Returns an empty string otherwise.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(138,tuple([py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_type_variation_list(self, base_type:'object'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all type variations for the given `base_type`.
			'''

    assert(not base_type is None)
    assert isinstance(base_type, (str, StringName)), 'base_type must be str or StringName'




    assert(isinstance(base_type, (str, StringName)))
    py_stringname_base_type = base_type if isinstance(base_type, StringName) else c_utils.py_string_to_string_name(base_type)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(139,tuple([py_stringname_base_type._ptr]))
    return _ret


  @functools.native_method
  def add_type(self, theme_type:'object'   ) -> None:
    r'''
				Adds an empty theme type for every valid data type.
				**Note:** Empty types are not saved with the theme. This method only exists to perform in-memory changes to the resource. Use available `set_*` methods to add theme items.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(140,tuple([py_stringname_theme_type._ptr]))

  @functools.native_method
  def remove_type(self, theme_type:'object'   ) -> None:
    r'''
				Removes the theme type, gracefully discarding defined theme items. If the type is a variation, this information is also erased. If the type is a base for type variations, those variations lose their base.
			'''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(141,tuple([py_stringname_theme_type._ptr]))

  @functools.native_method
  def rename_type(self, old_theme_type:'object'   , theme_type:'object'   ) -> None:
    r'''
				Renames the theme type `old_theme_type` to `theme_type`, if the old type exists and the new one doesn't exist.
				**Note:** Renaming a theme type to an empty name or a variation to a type associated with a built-in class removes type variation connections in a way that cannot be undone by reversing the rename alone.
			'''

    assert(not old_theme_type is None)
    assert isinstance(old_theme_type, (str, StringName)), 'old_theme_type must be str or StringName'
    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'




    assert(isinstance(old_theme_type, (str, StringName)))
    py_stringname_old_theme_type = old_theme_type if isinstance(old_theme_type, StringName) else c_utils.py_string_to_string_name(old_theme_type)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    self._ptr.call_with_return(142,tuple([py_stringname_old_theme_type._ptr, py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_type_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a list of all unique theme type names. Use the appropriate `get_*_type_list` method to get a list of unique theme types for a single data type.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(143,tuple([]))
    return _ret


  @functools.native_method
  def merge_with(self, other:'Theme'   ) -> None:
    r'''
				Adds missing and overrides existing definitions with values from the `other` theme resource.
				**Note:** This modifies the current theme. If you want to merge two themes together without modifying either one, create a new empty theme and merge the other two into it one after another.
			'''

    assert(not other is None)
    assert isinstance(other, get_class('Theme')), 'other must be Theme'






    self._ptr.call_with_return(144,tuple([other._ptr]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Removes all the theme properties defined on the theme resource.
			'''




    self._ptr.call_with_return(145,tuple([]))


register_cast_function('Theme', Theme.cast)
register_class('Theme', Theme)
