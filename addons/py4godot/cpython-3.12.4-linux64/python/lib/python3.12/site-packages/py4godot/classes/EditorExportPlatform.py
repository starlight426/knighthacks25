# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.EditorExportPlatformWeb as py4godot_editorexportplatformweb 
  import py4godot.classes.EditorExportPlatformIOS as py4godot_editorexportplatformios 
  import py4godot.classes.EditorExportPlatformMacOS as py4godot_editorexportplatformmacos 
  import py4godot.classes.EditorExportPlatformAppleEmbedded as py4godot_editorexportplatformappleembedded 
  import py4godot.classes.EditorExportPlatformPC as py4godot_editorexportplatformpc 
  import py4godot.classes.EditorExportPlatformVisionOS as py4godot_editorexportplatformvisionos 
  import py4godot.classes.EditorExportPlatformExtension as py4godot_editorexportplatformextension 
  import py4godot.classes.EditorExportPreset as py4godot_editorexportpreset 
  import py4godot.classes.EditorExportPlatformAndroid as py4godot_editorexportplatformandroid 
  import py4godot.classes.EditorExportPlatformLinuxBSD as py4godot_editorexportplatformlinuxbsd 
  import py4godot.classes.EditorExportPlatformWindows as py4godot_editorexportplatformwindows 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPEditorExportPlatformWrapper

class ExportMessageType:
  EXPORT_MESSAGE_NONE = 0
  EXPORT_MESSAGE_INFO = 1
  EXPORT_MESSAGE_WARNING = 2
  EXPORT_MESSAGE_ERROR = 3
class DebugFlags:
  DEBUG_FLAG_DUMB_CLIENT = 1
  DEBUG_FLAG_REMOTE_DEBUG = 2
  DEBUG_FLAG_REMOTE_DEBUG_LOCALHOST = 4
  DEBUG_FLAG_VIEW_COLLISIONS = 8
  DEBUG_FLAG_VIEW_NAVIGATION = 16


class EditorExportPlatform(py4godot_refcounted.RefCounted):
  r'''
		Base resource that provides the functionality of exporting a release build of a project to a platform, from the editor. Stores platform-specific metadata such as the name and supported features of the platform, and performs the exporting of projects, PCK files, and ZIP files. Uses an export template for the platform provided at the time of project exporting.
		Used in scripting by `EditorExportPlugin` to configure platform-specific customization of scenes and resources. See `EditorExportPlugin._begin_customize_scenes` and `EditorExportPlugin._begin_customize_resources` for more details.
	'''

  @staticmethod
  def constructor():
    class_ = EditorExportPlatform.construct_without_init()
    class_._ptr = constructor(270,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorExportPlatform.construct_without_init()
    class_._ptr = constructor(270,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorExportPlatformWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(270,0, ())


  def generate_wrapper(self):
    return CPPEditorExportPlatformWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorExportPlatform.__new__(EditorExportPlatform)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorExportPlatform'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorExportPlatform.construct_without_init()
    cls._ptr = CPPEditorExportPlatformWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorExportPlatform.construct_without_init()
    cls._ptr = CPPEditorExportPlatformWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def get_os_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the export operating system handled by this `EditorExportPlatform` class, as a friendly string. Possible return values are `Windows`, `Linux`, `macOS`, `Android`, `iOS`, and `Web`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def create_preset(self) -> typing.Union['py4godot_editorexportpreset.EditorExportPreset']:
    r'''
				Create a new preset for this platform.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorExportPreset
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def find_export_template(self, template_file_name:'str'   ) -> typing.Union['Dictionary']:
    r'''
				Locates export template for the platform, and returns `Dictionary` with the following keys: `path: String` and `error: String`. This method is provided for convenience and custom export platforms aren't required to use it or keep export templates stored in the same way official templates are.
			'''

    assert(not template_file_name is None)
    assert isinstance(template_file_name, (str, String)), 'template_file_name must be str or String'




    assert(isinstance(template_file_name, (str, String)))
    py_string_template_file_name = template_file_name if isinstance(template_file_name, StringName) else c_utils.py_string_to_string(template_file_name)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([py_string_template_file_name._ptr]))
    return _ret


  @functools.native_method
  def get_current_presets(self) -> typing.Union['Array']:
    r'''
				Returns array of `EditorExportPreset`s for this platform.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def save_pack(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , embed:'bool' =False  ) -> typing.Union['Dictionary']:
    r'''
				Saves PCK archive and returns `Dictionary` with the following keys: `result: Error`, `so_files: Array` (array of the shared/static objects which contains dictionaries with the following keys: `path: String`, `tags: PackedStringArray`, and `target_folder: String`).
				If `embed` is `true`, PCK content is appended to the end of `path` file and return `Dictionary` additionally include following keys: `embedded_start: int` (embedded PCK offset) and `embedded_size: int` (embedded PCK size).
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(embed, bool), 'embed must be bool'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([preset._ptr, debug, py_string_path._ptr, embed]))
    return _ret


  @functools.native_method
  def save_zip(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   ) -> typing.Union['Dictionary']:
    r'''
				Saves ZIP archive and returns `Dictionary` with the following keys: `result: Error`, `so_files: Array` (array of the shared/static objects which contains dictionaries with the following keys: `path: String`, `tags: PackedStringArray`, and `target_folder: String`).
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([preset._ptr, debug, py_string_path._ptr]))
    return _ret


  @functools.native_method
  def save_pack_patch(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   ) -> typing.Union['Dictionary']:
    r'''
				Saves patch PCK archive and returns `Dictionary` with the following keys: `result: Error`, `so_files: Array` (array of the shared/static objects which contains dictionaries with the following keys: `path: String`, `tags: PackedStringArray`, and `target_folder: String`).
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([preset._ptr, debug, py_string_path._ptr]))
    return _ret


  @functools.native_method
  def save_zip_patch(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   ) -> typing.Union['Dictionary']:
    r'''
				Saves patch ZIP archive and returns `Dictionary` with the following keys: `result: Error`, `so_files: Array` (array of the shared/static objects which contains dictionaries with the following keys: `path: String`, `tags: PackedStringArray`, and `target_folder: String`).
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([preset._ptr, debug, py_string_path._ptr]))
    return _ret


  @functools.native_method
  def gen_export_flags(self, flags:'int'   ) -> typing.Union['PackedStringArray']:
    r'''
				Generates array of command line arguments for the default export templates for the debug flags and editor settings.
			'''

    assert isinstance(flags, (int, float)), 'flags must be int or float'






    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([flags]))
    return _ret


  @functools.native_method
  def export_project_files(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , save_cb:'Callable'   , shared_cb:'Callable' = None  ) -> typing.Union[int]:
    r'''
				Exports project files for the specified preset. This method can be used to implement custom export format, other than PCK and ZIP. One of the callbacks is called for each exported file.
				`save_cb` is called for all exported files and have the following arguments: `file_path: String`, `file_data: PackedByteArray`, `file_index: int`, `file_count: int`, `encryption_include_filters: PackedStringArray`, `encryption_exclude_filters: PackedStringArray`, `encryption_key: PackedByteArray`.
				`shared_cb` is called for exported native shared/static libraries and have the following arguments: `file_path: String`, `tags: PackedStringArray`, `target_folder: String`.
				**Note:** `file_index` and `file_count` are intended for progress tracking only and aren't necessarily unique and precise.
			'''
    if shared_cb is None:
      shared_cb = Callable.new0()
    if shared_cb is None:
      shared_cb = Callable.new0()

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not save_cb is None)
    assert isinstance(save_cb, Callable), 'save_cb must be Callable'









    _ret:int
    _ret = self._ptr.call_with_return(62,tuple([preset._ptr, debug, save_cb._ptr, shared_cb._ptr]))
    return _ret


  @functools.native_method
  def export_project(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , flags:'int' =0  ) -> typing.Union[int]:
    r'''
				Creates a full project at `path` for the specified `preset`.
			'''



    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(63,tuple([preset._ptr, debug, py_string_path._ptr, flags]))
    return _ret


  @functools.native_method
  def export_pack(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , flags:'int' =0  ) -> typing.Union[int]:
    r'''
				Creates a PCK archive at `path` for the specified `preset`.
			'''



    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(64,tuple([preset._ptr, debug, py_string_path._ptr, flags]))
    return _ret


  @functools.native_method
  def export_zip(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , flags:'int' =0  ) -> typing.Union[int]:
    r'''
				Create a ZIP archive at `path` for the specified `preset`.
			'''



    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(65,tuple([preset._ptr, debug, py_string_path._ptr, flags]))
    return _ret


  @functools.native_method
  def export_pack_patch(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , patches:'PackedStringArray' = None  , flags:'int' =0  ) -> typing.Union[int]:
    r'''
				Creates a patch PCK archive at `path` for the specified `preset`, containing only the files that have changed since the last patch.
				**Note:** `patches` is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
			'''
    if patches is None:
      patches = PackedStringArray.new0()

    if patches is None:
      patches = PackedStringArray.new0()


    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)



    _ret:int
    _ret = self._ptr.call_with_return(66,tuple([preset._ptr, debug, py_string_path._ptr, patches._ptr, flags]))
    return _ret


  @functools.native_method
  def export_zip_patch(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , patches:'PackedStringArray' = None  , flags:'int' =0  ) -> typing.Union[int]:
    r'''
				Create a patch ZIP archive at `path` for the specified `preset`, containing only the files that have changed since the last patch.
				**Note:** `patches` is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
			'''
    if patches is None:
      patches = PackedStringArray.new0()

    if patches is None:
      patches = PackedStringArray.new0()


    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'






    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)



    _ret:int
    _ret = self._ptr.call_with_return(67,tuple([preset._ptr, debug, py_string_path._ptr, patches._ptr, flags]))
    return _ret


  @functools.native_method
  def clear_messages(self) -> None:
    r'''
				Clears the export log.
			'''




    self._ptr.call_with_return(68,tuple([]))

  @functools.native_method
  def add_message(self, type:'int'  , category:'str'   , message:'str'   ) -> None:
    r'''
				Adds a message to the export log that will be displayed when exporting ends.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not category is None)
    assert isinstance(category, (str, String)), 'category must be str or String'
    assert(not message is None)
    assert isinstance(message, (str, String)), 'message must be str or String'





    assert(isinstance(category, (str, String)))
    py_string_category = category if isinstance(category, StringName) else c_utils.py_string_to_string(category)
    assert(isinstance(message, (str, String)))
    py_string_message = message if isinstance(message, StringName) else c_utils.py_string_to_string(message)

    self._ptr.call_with_return(69,tuple([type, py_string_category._ptr, py_string_message._ptr]))

  @functools.native_method
  def get_message_count(self) -> typing.Union[int]:
    r'''
				Returns number of messages in the export log.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def get_message_type(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns message type, for the message with `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(71,tuple([index]))
    return _ret


  @functools.native_method
  def get_message_category(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns message category, for the message with `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_message_text(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns message text, for the message with `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_worst_message_type(self) -> typing.Union[int]:
    r'''
				Returns most severe message type currently present in the export log.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(74,tuple([]))
    return _ret


  @functools.native_method
  def ssh_run_on_remote(self, host:'str'   , port:'str'   , ssh_arg:'PackedStringArray'   , cmd_args:'str'   , output:'Array' = None  , port_fwd:'int' =-1  ) -> typing.Union[int]:
    r'''
				Executes specified command on the remote host via SSH protocol and returns command output in the `output`.
			'''
    if output is None:
      output = Array.new0()
    if output is None:
      output = Array.new0()

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert(not port is None)
    assert isinstance(port, (str, String)), 'port must be str or String'
    assert(not ssh_arg is None)
    assert isinstance(ssh_arg, PackedStringArray), 'ssh_arg must be PackedStringArray'
    assert(not cmd_args is None)
    assert isinstance(cmd_args, (str, String)), 'cmd_args must be str or String'
    assert isinstance(port_fwd, (int, float)), 'port_fwd must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)
    assert(isinstance(port, (str, String)))
    py_string_port = port if isinstance(port, StringName) else c_utils.py_string_to_string(port)

    assert(isinstance(cmd_args, (str, String)))
    py_string_cmd_args = cmd_args if isinstance(cmd_args, StringName) else c_utils.py_string_to_string(cmd_args)



    _ret:int
    _ret = self._ptr.call_with_return(75,tuple([py_string_host._ptr, py_string_port._ptr, ssh_arg._ptr, py_string_cmd_args._ptr, output._ptr, port_fwd]))
    return _ret


  @functools.native_method
  def ssh_run_on_remote_no_wait(self, host:'str'   , port:'str'   , ssh_args:'PackedStringArray'   , cmd_args:'str'   , port_fwd:'int' =-1  ) -> typing.Union[int]:
    r'''
				Executes specified command on the remote host via SSH protocol and returns process ID (on the remote host) without waiting for command to finish.
			'''

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert(not port is None)
    assert isinstance(port, (str, String)), 'port must be str or String'
    assert(not ssh_args is None)
    assert isinstance(ssh_args, PackedStringArray), 'ssh_args must be PackedStringArray'
    assert(not cmd_args is None)
    assert isinstance(cmd_args, (str, String)), 'cmd_args must be str or String'
    assert isinstance(port_fwd, (int, float)), 'port_fwd must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)
    assert(isinstance(port, (str, String)))
    py_string_port = port if isinstance(port, StringName) else c_utils.py_string_to_string(port)

    assert(isinstance(cmd_args, (str, String)))
    py_string_cmd_args = cmd_args if isinstance(cmd_args, StringName) else c_utils.py_string_to_string(cmd_args)


    _ret = 0
    _ret = self._ptr.call_with_return(76,tuple([py_string_host._ptr, py_string_port._ptr, ssh_args._ptr, py_string_cmd_args._ptr, port_fwd]))
    return _ret


  @functools.native_method
  def ssh_push_to_remote(self, host:'str'   , port:'str'   , scp_args:'PackedStringArray'   , src_file:'str'   , dst_file:'str'   ) -> typing.Union[int]:
    r'''
				Uploads specified file over SCP protocol to the remote host.
			'''

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert(not port is None)
    assert isinstance(port, (str, String)), 'port must be str or String'
    assert(not scp_args is None)
    assert isinstance(scp_args, PackedStringArray), 'scp_args must be PackedStringArray'
    assert(not src_file is None)
    assert isinstance(src_file, (str, String)), 'src_file must be str or String'
    assert(not dst_file is None)
    assert isinstance(dst_file, (str, String)), 'dst_file must be str or String'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)
    assert(isinstance(port, (str, String)))
    py_string_port = port if isinstance(port, StringName) else c_utils.py_string_to_string(port)

    assert(isinstance(src_file, (str, String)))
    py_string_src_file = src_file if isinstance(src_file, StringName) else c_utils.py_string_to_string(src_file)
    assert(isinstance(dst_file, (str, String)))
    py_string_dst_file = dst_file if isinstance(dst_file, StringName) else c_utils.py_string_to_string(dst_file)

    _ret:int
    _ret = self._ptr.call_with_return(77,tuple([py_string_host._ptr, py_string_port._ptr, scp_args._ptr, py_string_src_file._ptr, py_string_dst_file._ptr]))
    return _ret


  @functools.native_method
  def get_internal_export_files(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   ) -> typing.Union['Dictionary']:
    r'''
				Returns additional files that should always be exported regardless of preset configuration, and are not part of the project source. The returned `Dictionary` contains filename keys (`String`) and their corresponding raw data (`PackedByteArray`).
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([preset._ptr, debug]))
    return _ret


  @staticmethod
  def get_forced_export_files(preset:'py4godot_editorexportpreset.EditorExportPreset' = None  ) -> typing.Union['PackedStringArray']:
    r'''
				Returns array of core file names that always should be exported regardless of preset config.
			'''
    if preset is None:
      preset = c_utils.empty_object
    if preset is None:
      preset = c_utils.empty_object







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = static_method(270,0,tuple([preset._ptr]))
    return _ret



register_cast_function('EditorExportPlatform', EditorExportPlatform.cast)
register_class('EditorExportPlatform', EditorExportPlatform)
