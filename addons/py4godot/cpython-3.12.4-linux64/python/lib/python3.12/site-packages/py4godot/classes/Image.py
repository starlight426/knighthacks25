# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPImageWrapper

class Format:
  FORMAT_L8 = 0
  FORMAT_LA8 = 1
  FORMAT_R8 = 2
  FORMAT_RG8 = 3
  FORMAT_RGB8 = 4
  FORMAT_RGBA8 = 5
  FORMAT_RGBA4444 = 6
  FORMAT_RGB565 = 7
  FORMAT_RF = 8
  FORMAT_RGF = 9
  FORMAT_RGBF = 10
  FORMAT_RGBAF = 11
  FORMAT_RH = 12
  FORMAT_RGH = 13
  FORMAT_RGBH = 14
  FORMAT_RGBAH = 15
  FORMAT_RGBE9995 = 16
  FORMAT_DXT1 = 17
  FORMAT_DXT3 = 18
  FORMAT_DXT5 = 19
  FORMAT_RGTC_R = 20
  FORMAT_RGTC_RG = 21
  FORMAT_BPTC_RGBA = 22
  FORMAT_BPTC_RGBF = 23
  FORMAT_BPTC_RGBFU = 24
  FORMAT_ETC = 25
  FORMAT_ETC2_R11 = 26
  FORMAT_ETC2_R11S = 27
  FORMAT_ETC2_RG11 = 28
  FORMAT_ETC2_RG11S = 29
  FORMAT_ETC2_RGB8 = 30
  FORMAT_ETC2_RGBA8 = 31
  FORMAT_ETC2_RGB8A1 = 32
  FORMAT_ETC2_RA_AS_RG = 33
  FORMAT_DXT5_RA_AS_RG = 34
  FORMAT_ASTC_4x4 = 35
  FORMAT_ASTC_4x4_HDR = 36
  FORMAT_ASTC_8x8 = 37
  FORMAT_ASTC_8x8_HDR = 38
  FORMAT_MAX = 39
class Interpolation:
  INTERPOLATE_NEAREST = 0
  INTERPOLATE_BILINEAR = 1
  INTERPOLATE_CUBIC = 2
  INTERPOLATE_TRILINEAR = 3
  INTERPOLATE_LANCZOS = 4
class AlphaMode:
  ALPHA_NONE = 0
  ALPHA_BIT = 1
  ALPHA_BLEND = 2
class CompressMode:
  COMPRESS_S3TC = 0
  COMPRESS_ETC = 1
  COMPRESS_ETC2 = 2
  COMPRESS_BPTC = 3
  COMPRESS_ASTC = 4
  COMPRESS_MAX = 5
class UsedChannels:
  USED_CHANNELS_L = 0
  USED_CHANNELS_LA = 1
  USED_CHANNELS_R = 2
  USED_CHANNELS_RG = 3
  USED_CHANNELS_RGB = 4
  USED_CHANNELS_RGBA = 5
class CompressSource:
  COMPRESS_SOURCE_GENERIC = 0
  COMPRESS_SOURCE_SRGB = 1
  COMPRESS_SOURCE_NORMAL = 2
class ASTCFormat:
  ASTC_FORMAT_4x4 = 0
  ASTC_FORMAT_8x8 = 1


class Image(py4godot_resource.Resource):
  r'''
		Native image datatype. Contains image data which can be converted to an `ImageTexture` and provides commonly used _image processing_ methods. The maximum width and height for an `Image` are `constant MAX_WIDTH` and `constant MAX_HEIGHT`.
		An `Image` cannot be assigned to a texture property of an object directly (such as `Sprite2D.texture`), and has to be converted manually to an `ImageTexture` first.
		**Note:** Methods that modify the image data cannot be used on VRAM-compressed images. Use `decompress` to convert the image to an uncompressed format first.
		**Note:** The maximum image size is 16384Ã—16384 pixels due to graphics hardware limitations. Larger images may fail to import.
	'''
  MAX_WIDTH:typing.ClassVar[int]

  MAX_HEIGHT:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = Image.construct_without_init()
    class_._ptr = constructor(403,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Image.construct_without_init()
    class_._ptr = constructor(403,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPImageWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(403,0, ())


  def generate_wrapper(self):
    return CPPImageWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Image.__new__(Image)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Image'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Image.construct_without_init()
    cls._ptr = CPPImageWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Image.construct_without_init()
    cls._ptr = CPPImageWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def data(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. _get_data()
    return _ret
  @data.setter
  def data(self,  value:'Dictionary'):
    self._set_data(value)
  @functools.native_method
  def get_width(self) -> typing.Union[int]:
    r'''
				Returns the image's width.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([]))
    return _ret


  @functools.native_method
  def get_height(self) -> typing.Union[int]:
    r'''
				Returns the image's height.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def get_size(self) -> typing.Union['Vector2i']:
    r'''
				Returns the image's size (width and height).
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([]))
    return _ret


  @functools.native_method
  def has_mipmaps(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the image has generated mipmaps.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def get_format(self) -> typing.Union[int]:
    r'''
				Returns this image's format.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def get_data(self) -> typing.Union['PackedByteArray']:
    r'''
				Returns a copy of the image's raw data.
			'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def get_data_size(self) -> typing.Union[int]:
    r'''
				Returns size (in bytes) of the image's raw data.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def convert(self, format:'int'  ) -> None:
    r'''
				Converts this image's format to the given `format`.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'






    self._ptr.call_with_return(84,tuple([format]))

  @functools.native_method
  def get_mipmap_count(self) -> typing.Union[int]:
    r'''
				Returns the number of mipmap levels or 0 if the image has no mipmaps. The largest main level image is not counted as a mipmap level by this method, so if you want to include it you can add 1 to this count.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def get_mipmap_offset(self, mipmap:'int'   ) -> typing.Union[int]:
    r'''
				Returns the offset where the image's mipmap with index `mipmap` is stored in the `data` dictionary.
			'''

    assert isinstance(mipmap, (int, float)), 'mipmap must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([mipmap]))
    return _ret


  @functools.native_method
  def resize_to_po2(self, square:'bool' =False  , interpolation:'int'  =1) -> None:
    r'''
				Resizes the image to the nearest power of 2 for the width and height. If `square` is `true`, sets width and height to be the same. New pixels are calculated using the `interpolation` mode defined via `enum Interpolation` constants.
			'''



    assert isinstance(square, bool), 'square must be bool'
    assert isinstance(interpolation, (int, float)), 'interpolation must be int or float'







    self._ptr.call_with_return(87,tuple([square, interpolation]))

  @functools.native_method
  def resize(self, width:'int'   , height:'int'   , interpolation:'int'  =1) -> None:
    r'''
				Resizes the image to the given `width` and `height`. New pixels are calculated using the `interpolation` mode defined via `enum Interpolation` constants.
			'''



    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(interpolation, (int, float)), 'interpolation must be int or float'








    self._ptr.call_with_return(88,tuple([width, height, interpolation]))

  @functools.native_method
  def shrink_x2(self) -> None:
    r'''
				Shrinks the image by a factor of 2 on each axis (this divides the pixel count by 4).
			'''




    self._ptr.call_with_return(89,tuple([]))

  @functools.native_method
  def crop(self, width:'int'   , height:'int'   ) -> None:
    r'''
				Crops the image to the given `width` and `height`. If the specified size is larger than the current size, the extra area is filled with black pixels.
			'''

    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'







    self._ptr.call_with_return(90,tuple([width, height]))

  @functools.native_method
  def flip_x(self) -> None:
    r'''
				Flips the image horizontally.
			'''




    self._ptr.call_with_return(91,tuple([]))

  @functools.native_method
  def flip_y(self) -> None:
    r'''
				Flips the image vertically.
			'''




    self._ptr.call_with_return(92,tuple([]))

  @functools.native_method
  def generate_mipmaps(self, renormalize:'bool' =False  ) -> typing.Union[int]:
    r'''
				Generates mipmaps for the image. Mipmaps are precalculated lower-resolution copies of the image that are automatically used if the image needs to be scaled down when rendered. They help improve image quality and performance when rendering. This method returns an error if the image is compressed, in a custom format, or if the image's width/height is `0`. Enabling `renormalize` when generating mipmaps for normal map textures will make sure all resulting vector values are normalized.
				It is possible to check if the image has mipmaps by calling `has_mipmaps` or `get_mipmap_count`. Calling `generate_mipmaps` on an image that already has mipmaps will replace existing mipmaps in the image.
			'''

    assert isinstance(renormalize, bool), 'renormalize must be bool'






    _ret:int
    _ret = self._ptr.call_with_return(93,tuple([renormalize]))
    return _ret


  @functools.native_method
  def clear_mipmaps(self) -> None:
    r'''
				Removes the image's mipmaps.
			'''




    self._ptr.call_with_return(94,tuple([]))

  @staticmethod
  def create(width:'int'   , height:'int'   , use_mipmaps:'bool'   , format:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Creates an empty image of the given size and format. If `use_mipmaps` is `true`, generates mipmaps for this image. See the `generate_mipmaps`.
			'''

    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(use_mipmaps, bool), 'use_mipmaps must be bool'
    assert isinstance(format, (int, float)), 'format must be int or float'









    _ret = Image.construct_without_init()
    _ret._ptr = static_method(403,1,tuple([width, height, use_mipmaps, format]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @staticmethod
  def create_empty(width:'int'   , height:'int'   , use_mipmaps:'bool'   , format:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Creates an empty image of the given size and format. If `use_mipmaps` is `true`, generates mipmaps for this image. See the `generate_mipmaps`.
			'''

    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(use_mipmaps, bool), 'use_mipmaps must be bool'
    assert isinstance(format, (int, float)), 'format must be int or float'









    _ret = Image.construct_without_init()
    _ret._ptr = static_method(403,2,tuple([width, height, use_mipmaps, format]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @staticmethod
  def create_from_data(width:'int'   , height:'int'   , use_mipmaps:'bool'   , format:'int'  , data:'PackedByteArray'   ) -> typing.Union['typing.Self']:
    r'''
				Creates a new image of the given size and format. Fills the image with the given raw data. If `use_mipmaps` is `true`, loads the mipmaps for this image from `data`. See `generate_mipmaps`.
			'''

    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(use_mipmaps, bool), 'use_mipmaps must be bool'
    assert isinstance(format, (int, float)), 'format must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'










    _ret = Image.construct_without_init()
    _ret._ptr = static_method(403,3,tuple([width, height, use_mipmaps, format, data._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_data(self, width:'int'   , height:'int'   , use_mipmaps:'bool'   , format:'int'  , data:'PackedByteArray'   ) -> None:
    r'''
				Overwrites data of an existing `Image`. Non-static equivalent of `create_from_data`.
			'''

    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(use_mipmaps, bool), 'use_mipmaps must be bool'
    assert isinstance(format, (int, float)), 'format must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'










    self._ptr.call_with_return(95,tuple([width, height, use_mipmaps, format, data._ptr]))

  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the image has no data.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def load(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Loads an image from file `path`. See `url=$DOCS_URL/tutorials/assets_pipeline/importing_images.html#supported-image-formats`Supported image formats`/url` for a list of supported image formats and limitations.
				**Warning:** This method should only be used in the editor or in cases when you need to load external images at run-time, such as images located at the `user://` directory, and may not work in exported projects.
				See also `ImageTexture` description for usage examples.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(97,tuple([py_string_path._ptr]))
    return _ret


  @staticmethod
  def load_from_file(path:'str'   ) -> typing.Union['typing.Self']:
    r'''
				Creates a new `Image` and loads data from the specified file.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = Image.construct_without_init()
    _ret._ptr = static_method(403,4,tuple([py_string_path._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def save_png(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Saves the image as a PNG file to the file at `path`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(98,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def save_png_to_buffer(self) -> typing.Union['PackedByteArray']:
    r'''
				Saves the image as a PNG file to a byte array.
			'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([]))
    return _ret


  @functools.native_method
  def save_jpg(self, path:'str'   , quality:'float' =0.75  ) -> typing.Union[int]:
    r'''
				Saves the image as a JPEG file to `path` with the specified `quality` between `0.01` and `1.0` (inclusive). Higher `quality` values result in better-looking output at the cost of larger file sizes. Recommended `quality` values are between `0.75` and `0.90`. Even at quality `1.00`, JPEG compression remains lossy.
				**Note:** JPEG does not save an alpha channel. If the `Image` contains an alpha channel, the image will still be saved, but the resulting JPEG file won't contain the alpha channel.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(quality, (int, float)), 'quality must be int or float'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(100,tuple([py_string_path._ptr, quality]))
    return _ret


  @functools.native_method
  def save_jpg_to_buffer(self, quality:'float' =0.75  ) -> typing.Union['PackedByteArray']:
    r'''
				Saves the image as a JPEG file to a byte array with the specified `quality` between `0.01` and `1.0` (inclusive). Higher `quality` values result in better-looking output at the cost of larger byte array sizes (and therefore memory usage). Recommended `quality` values are between `0.75` and `0.90`. Even at quality `1.00`, JPEG compression remains lossy.
				**Note:** JPEG does not save an alpha channel. If the `Image` contains an alpha channel, the image will still be saved, but the resulting byte array won't contain the alpha channel.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'






    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([quality]))
    return _ret


  @functools.native_method
  def save_exr(self, path:'str'   , grayscale:'bool' =False  ) -> typing.Union[int]:
    r'''
				Saves the image as an EXR file to `path`. If `grayscale` is `true` and the image has only one channel, it will be saved explicitly as monochrome rather than one red channel. This function will return `constant ERR_UNAVAILABLE` if Godot was compiled without the TinyEXR module.
				**Note:** The TinyEXR module is disabled in non-editor builds, which means `save_exr` will return `constant ERR_UNAVAILABLE` when it is called from an exported project.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(grayscale, bool), 'grayscale must be bool'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(102,tuple([py_string_path._ptr, grayscale]))
    return _ret


  @functools.native_method
  def save_exr_to_buffer(self, grayscale:'bool' =False  ) -> typing.Union['PackedByteArray']:
    r'''
				Saves the image as an EXR file to a byte array. If `grayscale` is `true` and the image has only one channel, it will be saved explicitly as monochrome rather than one red channel. This function will return an empty byte array if Godot was compiled without the TinyEXR module.
				**Note:** The TinyEXR module is disabled in non-editor builds, which means `save_exr_to_buffer` will return an empty byte array when it is called from an exported project.
			'''

    assert isinstance(grayscale, bool), 'grayscale must be bool'






    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([grayscale]))
    return _ret


  @functools.native_method
  def save_dds(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Saves the image as a DDS (DirectDraw Surface) file to `path`. DDS is a container format that can store textures in various compression formats, such as DXT1, DXT5, or BC7. This function will return `constant ERR_UNAVAILABLE` if Godot was compiled without the DDS module.
				**Note:** The DDS module may be disabled in certain builds, which means `save_dds` will return `constant ERR_UNAVAILABLE` when it is called from an exported project.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(104,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def save_dds_to_buffer(self) -> typing.Union['PackedByteArray']:
    r'''
				Saves the image as a DDS (DirectDraw Surface) file to a byte array. DDS is a container format that can store textures in various compression formats, such as DXT1, DXT5, or BC7. This function will return an empty byte array if Godot was compiled without the DDS module.
				**Note:** The DDS module may be disabled in certain builds, which means `save_dds_to_buffer` will return an empty byte array when it is called from an exported project.
			'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([]))
    return _ret


  @functools.native_method
  def save_webp(self, path:'str'   , lossy:'bool' =False  , quality:'float' =0.75  ) -> typing.Union[int]:
    r'''
				Saves the image as a WebP (Web Picture) file to the file at `path`. By default it will save lossless. If `lossy` is `true`, the image will be saved lossy, using the `quality` setting between `0.0` and `1.0` (inclusive). Lossless WebP offers more efficient compression than PNG.
				**Note:** The WebP format is limited to a size of 16383Ã—16383 pixels, while PNG can save larger images.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(lossy, bool), 'lossy must be bool'
    assert isinstance(quality, (int, float)), 'quality must be int or float'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)



    _ret:int
    _ret = self._ptr.call_with_return(106,tuple([py_string_path._ptr, lossy, quality]))
    return _ret


  @functools.native_method
  def save_webp_to_buffer(self, lossy:'bool' =False  , quality:'float' =0.75  ) -> typing.Union['PackedByteArray']:
    r'''
				Saves the image as a WebP (Web Picture) file to a byte array. By default it will save lossless. If `lossy` is `true`, the image will be saved lossy, using the `quality` setting between `0.0` and `1.0` (inclusive). Lossless WebP offers more efficient compression than PNG.
				**Note:** The WebP format is limited to a size of 16383Ã—16383 pixels, while PNG can save larger images.
			'''

    assert isinstance(lossy, bool), 'lossy must be bool'
    assert isinstance(quality, (int, float)), 'quality must be int or float'







    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(107,tuple([lossy, quality]))
    return _ret


  @functools.native_method
  def detect_alpha(self) -> typing.Union[int]:
    r'''
				Returns `constant ALPHA_BLEND` if the image has data for alpha values. Returns `constant ALPHA_BIT` if all the alpha values are stored in a single bit. Returns `constant ALPHA_NONE` if no data for alpha values is found.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(108,tuple([]))
    return _ret


  @functools.native_method
  def is_invisible(self) -> typing.Union[bool]:
    r'''
				Returns `true` if all the image's pixels have an alpha value of 0. Returns `false` if any pixel has an alpha value higher than 0.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([]))
    return _ret


  @functools.native_method
  def detect_used_channels(self, source:'int'  =0) -> typing.Union[int]:
    r'''
				Returns the color channels used by this image. If the image is compressed, the original `source` must be specified.
			'''



    assert isinstance(source, (int, float)), 'source must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(110,tuple([source]))
    return _ret


  @functools.native_method
  def compress(self, mode:'int'  , source:'int'  =0, astc_format:'int'  =0) -> typing.Union[int]:
    r'''
				Compresses the image with a VRAM-compressed format to use less memory. Can not directly access pixel data while the image is compressed. Returns error if the chosen compression mode is not available.
				The `source` parameter helps to pick the best compression method for DXT and ETC2 formats. It is ignored for ASTC compression.
				The `astc_format` parameter is only taken into account when using ASTC compression; it is ignored for all other formats.
				**Note:** `compress` is only supported in editor builds. When run in an exported project, this method always returns `constant ERR_UNAVAILABLE`.
			'''





    assert isinstance(mode, (int, float)), 'mode must be int or float'
    assert isinstance(source, (int, float)), 'source must be int or float'
    assert isinstance(astc_format, (int, float)), 'astc_format must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(111,tuple([mode, source, astc_format]))
    return _ret


  @functools.native_method
  def compress_from_channels(self, mode:'int'  , channels:'int'  , astc_format:'int'  =0) -> typing.Union[int]:
    r'''
				Compresses the image with a VRAM-compressed format to use less memory. Can not directly access pixel data while the image is compressed. Returns error if the chosen compression mode is not available.
				This is an alternative to `compress` that lets the user supply the channels used in order for the compressor to pick the best DXT and ETC2 formats. For other formats (non DXT or ETC2), this argument is ignored.
				The `astc_format` parameter is only taken into account when using ASTC compression; it is ignored for all other formats.
				**Note:** `compress_from_channels` is only supported in editor builds. When run in an exported project, this method always returns `constant ERR_UNAVAILABLE`.
			'''



    assert isinstance(mode, (int, float)), 'mode must be int or float'
    assert isinstance(channels, (int, float)), 'channels must be int or float'
    assert isinstance(astc_format, (int, float)), 'astc_format must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(112,tuple([mode, channels, astc_format]))
    return _ret


  @functools.native_method
  def decompress(self) -> typing.Union[int]:
    r'''
				Decompresses the image if it is VRAM-compressed in a supported format. This increases memory utilization, but allows modifying the image. Returns `constant OK` if the format is supported, otherwise `constant ERR_UNAVAILABLE`. All VRAM-compressed formats supported by Godot can be decompressed with this method, except `constant FORMAT_ETC2_R11S`, `constant FORMAT_ETC2_RG11S`, and `constant FORMAT_ETC2_RGB8A1`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(113,tuple([]))
    return _ret


  @functools.native_method
  def is_compressed(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the image is compressed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([]))
    return _ret


  @functools.native_method
  def rotate_90(self, direction:'int'  ) -> None:
    r'''
				Rotates the image in the specified `direction` by `90` degrees. The width and height of the image must be greater than `1`. If the width and height are not equal, the image will be resized.
			'''

    assert isinstance(direction, (int, float)), 'direction must be int or float'






    self._ptr.call_with_return(115,tuple([direction]))

  @functools.native_method
  def rotate_180(self) -> None:
    r'''
				Rotates the image by `180` degrees. The width and height of the image must be greater than `1`.
			'''




    self._ptr.call_with_return(116,tuple([]))

  @functools.native_method
  def fix_alpha_edges(self) -> None:
    r'''
				Blends low-alpha pixels with nearby pixels.
			'''




    self._ptr.call_with_return(117,tuple([]))

  @functools.native_method
  def premultiply_alpha(self) -> None:
    r'''
				Multiplies color values with alpha values. Resulting color values for a pixel are `(color * alpha)/256`. See also `CanvasItemMaterial.blend_mode`.
			'''




    self._ptr.call_with_return(118,tuple([]))

  @functools.native_method
  def srgb_to_linear(self) -> None:
    r'''
				Converts the raw data from nonlinear sRGB encoding to linear encoding using a lookup table. Only works on images with `constant FORMAT_RGB8` or `constant FORMAT_RGBA8` formats.
				**Note:** The 8-bit formats required by this method are not suitable for storing linearly encoded values; a significant amount of color information will be lost in darker values. To maintain image quality, this method should not be used.
			'''




    self._ptr.call_with_return(119,tuple([]))

  @functools.native_method
  def linear_to_srgb(self) -> None:
    r'''
				Converts the entire image from linear encoding to nonlinear sRGB encoding by using a lookup table. Only works on images with `constant FORMAT_RGB8` or `constant FORMAT_RGBA8` formats.
			'''




    self._ptr.call_with_return(120,tuple([]))

  @functools.native_method
  def normal_map_to_xy(self) -> None:
    r'''
				Converts the image's data to represent coordinates on a 3D plane. This is used when the image represents a normal map. A normal map can add lots of detail to a 3D surface without increasing the polygon count.
			'''




    self._ptr.call_with_return(121,tuple([]))

  @functools.native_method
  def rgbe_to_srgb(self) -> typing.Union['typing.Self']:
    r'''
				Converts a standard linear RGBE (Red Green Blue Exponent) image to an image that uses nonlinear sRGB encoding.
			'''




    _ret = Image.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(122,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def bump_map_to_normal_map(self, bump_scale:'float' =1.0  ) -> None:
    r'''
				Converts a bump map to a normal map. A bump map provides a height offset per-pixel, while a normal map provides a normal direction per pixel.
			'''

    assert isinstance(bump_scale, (int, float)), 'bump_scale must be int or float'






    self._ptr.call_with_return(123,tuple([bump_scale]))

  @functools.native_method
  def compute_image_metrics(self, compared_image:'Image'   , use_luma:'bool'   ) -> typing.Union['Dictionary']:
    r'''
				Compute image metrics on the current image and the compared image. This can be used to calculate the similarity between two images.
				The dictionary contains `max`, `mean`, `mean_squared`, `root_mean_squared` and `peak_snr`.
			'''

    assert(not compared_image is None)
    assert isinstance(compared_image, get_class('Image')), 'compared_image must be Image'
    assert isinstance(use_luma, bool), 'use_luma must be bool'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([compared_image._ptr, use_luma]))
    return _ret


  @functools.native_method
  def blit_rect(self, src:'Image'   , src_rect:'Rect2i'   , dst:'Vector2i'   ) -> None:
    r'''
				Copies `src_rect` from `src` image to this image at coordinates `dst`, clipped accordingly to both image bounds. This image and `src` image **must** have the same format. `src_rect` with non-positive size is treated as empty.
				**Note:** The alpha channel data in `src` will overwrite the corresponding data in this image at the target position. To blend alpha channels, use `blend_rect` instead.
			'''

    assert(not src is None)
    assert isinstance(src, get_class('Image')), 'src must be Image'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2i), 'src_rect must be Rect2i'
    assert(not dst is None)
    assert isinstance(dst, Vector2i), 'dst must be Vector2i'








    self._ptr.call_with_return(125,tuple([src._ptr, src_rect._ptr, dst._ptr]))

  @functools.native_method
  def blit_rect_mask(self, src:'Image'   , mask:'Image'   , src_rect:'Rect2i'   , dst:'Vector2i'   ) -> None:
    r'''
				Blits `src_rect` area from `src` image to this image at the coordinates given by `dst`, clipped accordingly to both image bounds. `src` pixel is copied onto `dst` if the corresponding `mask` pixel's alpha value is not 0. This image and `src` image **must** have the same format. `src` image and `mask` image **must** have the same size (width and height) but they can have different formats. `src_rect` with non-positive size is treated as empty.
			'''

    assert(not src is None)
    assert isinstance(src, get_class('Image')), 'src must be Image'
    assert(not mask is None)
    assert isinstance(mask, get_class('Image')), 'mask must be Image'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2i), 'src_rect must be Rect2i'
    assert(not dst is None)
    assert isinstance(dst, Vector2i), 'dst must be Vector2i'









    self._ptr.call_with_return(126,tuple([src._ptr, mask._ptr, src_rect._ptr, dst._ptr]))

  @functools.native_method
  def blend_rect(self, src:'Image'   , src_rect:'Rect2i'   , dst:'Vector2i'   ) -> None:
    r'''
				Alpha-blends `src_rect` from `src` image to this image at coordinates `dst`, clipped accordingly to both image bounds. This image and `src` image **must** have the same format. `src_rect` with non-positive size is treated as empty.
			'''

    assert(not src is None)
    assert isinstance(src, get_class('Image')), 'src must be Image'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2i), 'src_rect must be Rect2i'
    assert(not dst is None)
    assert isinstance(dst, Vector2i), 'dst must be Vector2i'








    self._ptr.call_with_return(127,tuple([src._ptr, src_rect._ptr, dst._ptr]))

  @functools.native_method
  def blend_rect_mask(self, src:'Image'   , mask:'Image'   , src_rect:'Rect2i'   , dst:'Vector2i'   ) -> None:
    r'''
				Alpha-blends `src_rect` from `src` image to this image using `mask` image at coordinates `dst`, clipped accordingly to both image bounds. Alpha channels are required for both `src` and `mask`. `dst` pixels and `src` pixels will blend if the corresponding mask pixel's alpha value is not 0. This image and `src` image **must** have the same format. `src` image and `mask` image **must** have the same size (width and height) but they can have different formats. `src_rect` with non-positive size is treated as empty.
			'''

    assert(not src is None)
    assert isinstance(src, get_class('Image')), 'src must be Image'
    assert(not mask is None)
    assert isinstance(mask, get_class('Image')), 'mask must be Image'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2i), 'src_rect must be Rect2i'
    assert(not dst is None)
    assert isinstance(dst, Vector2i), 'dst must be Vector2i'









    self._ptr.call_with_return(128,tuple([src._ptr, mask._ptr, src_rect._ptr, dst._ptr]))

  @functools.native_method
  def fill(self, color:'Color'   ) -> None:
    r'''
				Fills the image with `color`.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'






    self._ptr.call_with_return(129,tuple([color._ptr]))

  @functools.native_method
  def fill_rect(self, rect:'Rect2i'   , color:'Color'   ) -> None:
    r'''
				Fills `rect` with `color`.
			'''

    assert(not rect is None)
    assert isinstance(rect, Rect2i), 'rect must be Rect2i'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(130,tuple([rect._ptr, color._ptr]))

  @functools.native_method
  def get_used_rect(self) -> typing.Union['Rect2i']:
    r'''
				Returns a `Rect2i` enclosing the visible portion of the image, considering each pixel with a non-zero alpha channel as visible.
			'''




    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(131,tuple([]))
    return _ret


  @functools.native_method
  def get_region(self, region:'Rect2i'   ) -> typing.Union['typing.Self']:
    r'''
				Returns a new `Image` that is a copy of this `Image`'s area specified with `region`.
			'''

    assert(not region is None)
    assert isinstance(region, Rect2i), 'region must be Rect2i'






    _ret = Image.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(132,tuple([region._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def copy_from(self, src:'Image'   ) -> None:
    r'''
				Copies `src` image to this image.
			'''

    assert(not src is None)
    assert isinstance(src, get_class('Image')), 'src must be Image'






    self._ptr.call_with_return(133,tuple([src._ptr]))

  @functools.native_method
  def get_pixelv(self, point:'Vector2i'   ) -> typing.Union['Color']:
    r'''
				Returns the color of the pixel at `point`.
				This is the same as `get_pixel`, but with a `Vector2i` argument instead of two integer arguments.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2i), 'point must be Vector2i'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(134,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def get_pixel(self, x:'int'   , y:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the color of the pixel at `(x, y)`.
				This is the same as `get_pixelv`, but with two integer arguments instead of a `Vector2i` argument.
			'''

    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(135,tuple([x, y]))
    return _ret


  @functools.native_method
  def set_pixelv(self, point:'Vector2i'   , color:'Color'   ) -> None:
    r'''
				Sets the `Color` of the pixel at `point` to `color`.
				
				```gdscript
				var img_width = 10
				var img_height = 5
				var img = Image.create(img_width, img_height, false, Image.FORMAT_RGBA8)

				img.set_pixelv(Vector2i(1, 2), Color.RED) # Sets the color at (1, 2) to red.
				```
				
				
				This is the same as `set_pixel`, but with a `Vector2i` argument instead of two integer arguments.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2i), 'point must be Vector2i'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(136,tuple([point._ptr, color._ptr]))

  @functools.native_method
  def set_pixel(self, x:'int'   , y:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the `Color` of the pixel at `(x, y)` to `color`.
				
				```gdscript
				var img_width = 10
				var img_height = 5
				var img = Image.create(img_width, img_height, false, Image.FORMAT_RGBA8)

				img.set_pixel(1, 2, Color.RED) # Sets the color at (1, 2) to red.
				```
				
				
				This is the same as `set_pixelv`, but with a two integer arguments instead of a `Vector2i` argument.
			'''

    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(137,tuple([x, y, color._ptr]))

  @functools.native_method
  def adjust_bcs(self, brightness:'float'   , contrast:'float'   , saturation:'float'   ) -> None:
    r'''
				Adjusts this image's `brightness`, `contrast`, and `saturation` by the given values. Does not work if the image is compressed (see `is_compressed`).
			'''

    assert isinstance(brightness, (int, float)), 'brightness must be int or float'
    assert isinstance(contrast, (int, float)), 'contrast must be int or float'
    assert isinstance(saturation, (int, float)), 'saturation must be int or float'








    self._ptr.call_with_return(138,tuple([brightness, contrast, saturation]))

  @functools.native_method
  def load_png_from_buffer(self, buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Loads an image from the binary contents of a PNG file.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'






    _ret:int
    _ret = self._ptr.call_with_return(139,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def load_jpg_from_buffer(self, buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Loads an image from the binary contents of a JPEG file.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'






    _ret:int
    _ret = self._ptr.call_with_return(140,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def load_webp_from_buffer(self, buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Loads an image from the binary contents of a WebP file.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'






    _ret:int
    _ret = self._ptr.call_with_return(141,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def load_tga_from_buffer(self, buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Loads an image from the binary contents of a TGA file.
				**Note:** This method is only available in engine builds with the TGA module enabled. By default, the TGA module is enabled, but it can be disabled at build-time using the `module_tga_enabled=no` SCons option.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'






    _ret:int
    _ret = self._ptr.call_with_return(142,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def load_bmp_from_buffer(self, buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Loads an image from the binary contents of a BMP file.
				**Note:** Godot's BMP module doesn't support 16-bit per pixel images. Only 1-bit, 4-bit, 8-bit, 24-bit, and 32-bit per pixel images are supported.
				**Note:** This method is only available in engine builds with the BMP module enabled. By default, the BMP module is enabled, but it can be disabled at build-time using the `module_bmp_enabled=no` SCons option.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'






    _ret:int
    _ret = self._ptr.call_with_return(143,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def load_ktx_from_buffer(self, buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Loads an image from the binary contents of a `url=https://github.com/KhronosGroup/KTX-Software`KTX`/url` file. Unlike most image formats, KTX can store VRAM-compressed data and embed mipmaps.
				**Note:** Godot's libktx implementation only supports 2D images. Cubemaps, texture arrays, and de-padding are not supported.
				**Note:** This method is only available in engine builds with the KTX module enabled. By default, the KTX module is enabled, but it can be disabled at build-time using the `module_ktx_enabled=no` SCons option.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'






    _ret:int
    _ret = self._ptr.call_with_return(144,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def load_dds_from_buffer(self, buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Loads an image from the binary contents of a DDS file.
				**Note:** This method is only available in engine builds with the DDS module enabled. By default, the DDS module is enabled, but it can be disabled at build-time using the `module_dds_enabled=no` SCons option.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'






    _ret:int
    _ret = self._ptr.call_with_return(145,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def load_svg_from_buffer(self, buffer:'PackedByteArray'   , scale:'float' =1.0  ) -> typing.Union[int]:
    r'''
				Loads an image from the UTF-8 binary contents of an **uncompressed** SVG file (**.svg**).
				**Note:** Beware when using compressed SVG files (like **.svgz**), they need to be `decompressed` before loading.
				**Note:** This method is only available in engine builds with the SVG module enabled. By default, the SVG module is enabled, but it can be disabled at build-time using the `module_svg_enabled=no` SCons option.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'
    assert isinstance(scale, (int, float)), 'scale must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(146,tuple([buffer._ptr, scale]))
    return _ret


  @functools.native_method
  def load_svg_from_string(self, svg_str:'str'   , scale:'float' =1.0  ) -> typing.Union[int]:
    r'''
				Loads an image from the string contents of an SVG file (**.svg**).
				**Note:** This method is only available in engine builds with the SVG module enabled. By default, the SVG module is enabled, but it can be disabled at build-time using the `module_svg_enabled=no` SCons option.
			'''

    assert(not svg_str is None)
    assert isinstance(svg_str, (str, String)), 'svg_str must be str or String'
    assert isinstance(scale, (int, float)), 'scale must be int or float'




    assert(isinstance(svg_str, (str, String)))
    py_string_svg_str = svg_str if isinstance(svg_str, StringName) else c_utils.py_string_to_string(svg_str)


    _ret:int
    _ret = self._ptr.call_with_return(147,tuple([py_string_svg_str._ptr, scale]))
    return _ret



register_cast_function('Image', Image.cast)
register_class('Image', Image)
