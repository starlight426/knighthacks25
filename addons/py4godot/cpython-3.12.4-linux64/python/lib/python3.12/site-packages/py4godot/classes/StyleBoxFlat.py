# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.StyleBox as py4godot_stylebox 
from py4godot.wrappers.wrappers import CPPStyleBoxFlatWrapper


class StyleBoxFlat(py4godot_stylebox.StyleBox):
  r'''
		By configuring various properties of this style box, you can achieve many common looks without the need of a texture. This includes optionally rounded borders, antialiasing, shadows, and skew.
		Setting corner radius to high values is allowed. As soon as corners overlap, the stylebox will switch to a relative system:
		`codeblock lang=text`
		height = 30
		corner_radius_top_left = 50
		corner_radius_bottom_left = 100
		```
		The relative system now would take the 1:2 ratio of the two left corners to calculate the actual corner width. Both corners added will **never** be more than the height. Result:
		`codeblock lang=text`
		corner_radius_top_left: 10
		corner_radius_bottom_left: 20
		```
	'''

  @staticmethod
  def constructor():
    class_ = StyleBoxFlat.construct_without_init()
    class_._ptr = constructor(795,0, ())
    return class_
  @staticmethod
  def new():
    class_ = StyleBoxFlat.construct_without_init()
    class_._ptr = constructor(795,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPStyleBoxFlatWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(795,0, ())


  def generate_wrapper(self):
    return CPPStyleBoxFlatWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = StyleBoxFlat.__new__(StyleBoxFlat)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'StyleBoxFlat'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = StyleBoxFlat.construct_without_init()
    cls._ptr = CPPStyleBoxFlatWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = StyleBoxFlat.construct_without_init()
    cls._ptr = CPPStyleBoxFlatWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def bg_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_bg_color()
    return _ret
  @bg_color.setter
  def bg_color(self,  value:'Color'):
    self.set_bg_color(value)
  @property
  def draw_center(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_draw_center_enabled()
    return _ret
  @draw_center.setter
  def draw_center(self,  value:'bool'):
    self.set_draw_center(value)
  @property
  def skew(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_skew()
    return _ret
  @skew.setter
  def skew(self,  value:'Vector2'):
    self.set_skew(value)
  @property
  def border_width_left(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_border_width(0)
    return _ret
  @border_width_left.setter
  def border_width_left(self,  value:'int'):
    self.set_border_width(value)
  @property
  def border_width_top(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_border_width(1)
    return _ret
  @border_width_top.setter
  def border_width_top(self,  value:'int'):
    self.set_border_width(value)
  @property
  def border_width_right(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_border_width(2)
    return _ret
  @border_width_right.setter
  def border_width_right(self,  value:'int'):
    self.set_border_width(value)
  @property
  def border_width_bottom(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_border_width(3)
    return _ret
  @border_width_bottom.setter
  def border_width_bottom(self,  value:'int'):
    self.set_border_width(value)
  @property
  def border_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_border_color()
    return _ret
  @border_color.setter
  def border_color(self,  value:'Color'):
    self.set_border_color(value)
  @property
  def border_blend(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_border_blend()
    return _ret
  @border_blend.setter
  def border_blend(self,  value:'bool'):
    self.set_border_blend(value)
  @property
  def corner_radius_top_left(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_corner_radius(0)
    return _ret
  @corner_radius_top_left.setter
  def corner_radius_top_left(self,  value:'int'):
    self.set_corner_radius(value)
  @property
  def corner_radius_top_right(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_corner_radius(1)
    return _ret
  @corner_radius_top_right.setter
  def corner_radius_top_right(self,  value:'int'):
    self.set_corner_radius(value)
  @property
  def corner_radius_bottom_right(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_corner_radius(2)
    return _ret
  @corner_radius_bottom_right.setter
  def corner_radius_bottom_right(self,  value:'int'):
    self.set_corner_radius(value)
  @property
  def corner_radius_bottom_left(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_corner_radius(3)
    return _ret
  @corner_radius_bottom_left.setter
  def corner_radius_bottom_left(self,  value:'int'):
    self.set_corner_radius(value)
  @property
  def corner_detail(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_corner_detail()
    return _ret
  @corner_detail.setter
  def corner_detail(self,  value:'int'):
    self.set_corner_detail(value)
  @property
  def expand_margin_left(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_expand_margin(0)
    return _ret
  @expand_margin_left.setter
  def expand_margin_left(self,  value:'float'):
    self.set_expand_margin(value)
  @property
  def expand_margin_top(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_expand_margin(1)
    return _ret
  @expand_margin_top.setter
  def expand_margin_top(self,  value:'float'):
    self.set_expand_margin(value)
  @property
  def expand_margin_right(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_expand_margin(2)
    return _ret
  @expand_margin_right.setter
  def expand_margin_right(self,  value:'float'):
    self.set_expand_margin(value)
  @property
  def expand_margin_bottom(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_expand_margin(3)
    return _ret
  @expand_margin_bottom.setter
  def expand_margin_bottom(self,  value:'float'):
    self.set_expand_margin(value)
  @property
  def shadow_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_shadow_color()
    return _ret
  @shadow_color.setter
  def shadow_color(self,  value:'Color'):
    self.set_shadow_color(value)
  @property
  def shadow_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_shadow_size()
    return _ret
  @shadow_size.setter
  def shadow_size(self,  value:'int'):
    self.set_shadow_size(value)
  @property
  def shadow_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_shadow_offset()
    return _ret
  @shadow_offset.setter
  def shadow_offset(self,  value:'Vector2'):
    self.set_shadow_offset(value)
  @property
  def anti_aliasing(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_anti_aliased()
    return _ret
  @anti_aliasing.setter
  def anti_aliasing(self,  value:'bool'):
    self.set_anti_aliased(value)
  @property
  def anti_aliasing_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_aa_size()
    return _ret
  @anti_aliasing_size.setter
  def anti_aliasing_size(self,  value:'float'):
    self.set_aa_size(value)
  @functools.native_method
  def set_bg_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__bg_color = color






    self._ptr.call_with_return(90,tuple([color._ptr]))

  @functools.native_method
  def get_bg_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_border_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__border_color = color






    self._ptr.call_with_return(92,tuple([color._ptr]))

  @functools.native_method
  def get_border_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_border_width_all(self, width:'int'   ) -> None:
    r'''
				Sets the border width to `width` pixels for all sides.
			'''

    assert isinstance(width, (int, float)), 'width must be int or float'






    self._ptr.call_with_return(94,tuple([width]))

  @functools.native_method
  def get_border_width_min(self) -> typing.Union[int]:
    r'''
				Returns the smallest border width out of all four borders.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def set_border_width(self, margin:'int'  , width:'int'   ) -> None:
    r'''
				Sets the specified `enum Side`'s border width to `width` pixels.
			'''

    assert isinstance(margin, (int, float)), 'margin must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'

    self.py__border_width_left = margin







    self._ptr.call_with_return(96,tuple([margin, width]))

  @functools.native_method
  def get_border_width(self, margin:'int'  ) -> typing.Union[int]:
    r'''
				Returns the specified `enum Side`'s border width.
			'''

    assert isinstance(margin, (int, float)), 'margin must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([margin]))

    return _ret


  @functools.native_method
  def set_border_blend(self, blend:'bool'   ) -> None:
    r''''''

    assert isinstance(blend, bool), 'blend must be bool'

    self.py__border_blend = blend






    self._ptr.call_with_return(98,tuple([blend]))

  @functools.native_method
  def get_border_blend(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([]))

    return _ret


  @functools.native_method
  def set_corner_radius_all(self, radius:'int'   ) -> None:
    r'''
				Sets the corner radius to `radius` pixels for all corners.
			'''

    assert isinstance(radius, (int, float)), 'radius must be int or float'






    self._ptr.call_with_return(100,tuple([radius]))

  @functools.native_method
  def set_corner_radius(self, corner:'int'  , radius:'int'   ) -> None:
    r'''
				Sets the corner radius to `radius` pixels for the given `corner`.
			'''

    assert isinstance(corner, (int, float)), 'corner must be int or float'
    assert isinstance(radius, (int, float)), 'radius must be int or float'

    self.py__corner_radius_top_left = corner







    self._ptr.call_with_return(101,tuple([corner, radius]))

  @functools.native_method
  def get_corner_radius(self, corner:'int'  ) -> typing.Union[int]:
    r'''
				Returns the given `corner`'s radius.
			'''

    assert isinstance(corner, (int, float)), 'corner must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([corner]))

    return _ret


  @functools.native_method
  def set_expand_margin(self, margin:'int'  , size:'float'   ) -> None:
    r'''
				Sets the expand margin to `size` pixels for the specified `enum Side`.
			'''

    assert isinstance(margin, (int, float)), 'margin must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'

    self.py__expand_margin_left = margin







    self._ptr.call_with_return(103,tuple([margin, size]))

  @functools.native_method
  def set_expand_margin_all(self, size:'float'   ) -> None:
    r'''
				Sets the expand margin to `size` pixels for all sides.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'






    self._ptr.call_with_return(104,tuple([size]))

  @functools.native_method
  def get_expand_margin(self, margin:'int'  ) -> typing.Union[float]:
    r'''
				Returns the size of the specified `enum Side`'s expand margin.
			'''

    assert isinstance(margin, (int, float)), 'margin must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([margin]))

    return _ret


  @functools.native_method
  def set_draw_center(self, draw_center:'bool'   ) -> None:
    r''''''

    assert isinstance(draw_center, bool), 'draw_center must be bool'

    self.py__draw_center = draw_center






    self._ptr.call_with_return(106,tuple([draw_center]))

  @functools.native_method
  def is_draw_center_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([]))

    return _ret


  @functools.native_method
  def set_skew(self, skew:'Vector2'   ) -> None:
    r''''''

    assert(not skew is None)
    assert isinstance(skew, Vector2), 'skew must be Vector2'

    self.py__skew = skew






    self._ptr.call_with_return(108,tuple([skew._ptr]))

  @functools.native_method
  def get_skew(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(109,tuple([]))

    return _ret


  @functools.native_method
  def set_shadow_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__shadow_color = color






    self._ptr.call_with_return(110,tuple([color._ptr]))

  @functools.native_method
  def get_shadow_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(111,tuple([]))

    return _ret


  @functools.native_method
  def set_shadow_size(self, size:'int'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'

    self.py__shadow_size = size






    self._ptr.call_with_return(112,tuple([size]))

  @functools.native_method
  def get_shadow_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(113,tuple([]))

    return _ret


  @functools.native_method
  def set_shadow_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'

    self.py__shadow_offset = offset






    self._ptr.call_with_return(114,tuple([offset._ptr]))

  @functools.native_method
  def get_shadow_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(115,tuple([]))

    return _ret


  @functools.native_method
  def set_anti_aliased(self, anti_aliased:'bool'   ) -> None:
    r''''''

    assert isinstance(anti_aliased, bool), 'anti_aliased must be bool'

    self.py__anti_aliasing = anti_aliased






    self._ptr.call_with_return(116,tuple([anti_aliased]))

  @functools.native_method
  def is_anti_aliased(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(117,tuple([]))

    return _ret


  @functools.native_method
  def set_aa_size(self, size:'float'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'

    self.py__anti_aliasing_size = size






    self._ptr.call_with_return(118,tuple([size]))

  @functools.native_method
  def get_aa_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([]))

    return _ret


  @functools.native_method
  def set_corner_detail(self, detail:'int'   ) -> None:
    r''''''

    assert isinstance(detail, (int, float)), 'detail must be int or float'

    self.py__corner_detail = detail






    self._ptr.call_with_return(120,tuple([detail]))

  @functools.native_method
  def get_corner_detail(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([]))

    return _ret



register_cast_function('StyleBoxFlat', StyleBoxFlat.cast)
register_class('StyleBoxFlat', StyleBoxFlat)
