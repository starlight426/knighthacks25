# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Area3DTypedArray as py4godot_area3dtypedarray 
  import py4godot.classes.Node3DTypedArray as py4godot_node3dtypedarray 
  import py4godot.classes.Node as py4godot_node 
import py4godot.classes.Area3DTypedArray as py4godot_area3dtypedarray 
import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
import py4godot.classes.Node3DTypedArray as py4godot_node3dtypedarray 
from py4godot.wrappers.wrappers import CPPArea3DWrapper

class SpaceOverride:
  SPACE_OVERRIDE_DISABLED = 0
  SPACE_OVERRIDE_COMBINE = 1
  SPACE_OVERRIDE_COMBINE_REPLACE = 2
  SPACE_OVERRIDE_REPLACE = 3
  SPACE_OVERRIDE_REPLACE_COMBINE = 4


class Area3D(py4godot_collisionobject3d.CollisionObject3D):
  r'''
		`Area3D` is a region of 3D space defined by one or multiple `CollisionShape3D` or `CollisionPolygon3D` child nodes. It detects when other `CollisionObject3D`s enter or exit it, and it also keeps track of which collision objects haven't exited it yet (i.e. which one are overlapping it).
		This node can also locally alter or override physics parameters (gravity, damping) and route audio to custom audio buses.
		**Note:** Areas and bodies created with `PhysicsServer3D` might not interact as expected with `Area3D`s, and might not emit signals or track objects correctly.
		**Warning:** Using a `ConcavePolygonShape3D` inside a `CollisionShape3D` child of this node (created e.g. by using the **Create Trimesh Collision Sibling** option in the **Mesh** menu that appears when selecting a `MeshInstance3D` node) may give unexpected results, since this collision shape is hollow. If this is not desired, it has to be split into multiple `ConvexPolygonShape3D`s or primitive shapes like `BoxShape3D`, or in some cases it may be replaceable by a `CollisionPolygon3D`.
	'''

  @staticmethod
  def constructor():
    class_ = Area3D.construct_without_init()
    class_._ptr = constructor(99,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Area3D.construct_without_init()
    class_._ptr = constructor(99,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPArea3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(99,0, ())


  def generate_wrapper(self):
    return CPPArea3DWrapper()
  def init_signals(self):
    super().init_signals()
    body_shape_entered_name = utils.py_string_to_string_name("body_shape_entered")
    self.body_shape_entered = signals.BuiltinSignal(self, body_shape_entered_name)
    body_shape_exited_name = utils.py_string_to_string_name("body_shape_exited")
    self.body_shape_exited = signals.BuiltinSignal(self, body_shape_exited_name)
    body_entered_name = utils.py_string_to_string_name("body_entered")
    self.body_entered = signals.BuiltinSignal(self, body_entered_name)
    body_exited_name = utils.py_string_to_string_name("body_exited")
    self.body_exited = signals.BuiltinSignal(self, body_exited_name)
    area_shape_entered_name = utils.py_string_to_string_name("area_shape_entered")
    self.area_shape_entered = signals.BuiltinSignal(self, area_shape_entered_name)
    area_shape_exited_name = utils.py_string_to_string_name("area_shape_exited")
    self.area_shape_exited = signals.BuiltinSignal(self, area_shape_exited_name)
    area_entered_name = utils.py_string_to_string_name("area_entered")
    self.area_entered = signals.BuiltinSignal(self, area_entered_name)
    area_exited_name = utils.py_string_to_string_name("area_exited")
    self.area_exited = signals.BuiltinSignal(self, area_exited_name)

  @staticmethod
  def construct_without_init():
    cls = Area3D.__new__(Area3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Area3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Area3D.construct_without_init()
    cls._ptr = CPPArea3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Area3D.construct_without_init()
    cls._ptr = CPPArea3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def monitoring(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_monitoring()
    return _ret
  @monitoring.setter
  def monitoring(self,  value:'bool'):
    self.set_monitoring(value)
  @property
  def monitorable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_monitorable()
    return _ret
  @monitorable.setter
  def monitorable(self,  value:'bool'):
    self.set_monitorable(value)
  @property
  def priority(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_priority()
    return _ret
  @priority.setter
  def priority(self,  value:'int'):
    self.set_priority(value)
  @property
  def gravity_space_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_gravity_space_override_mode()
    return _ret
  @gravity_space_override.setter
  def gravity_space_override(self,  value:'int'):
    self.set_gravity_space_override_mode(value)
  @property
  def gravity_point(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_gravity_a_point()
    return _ret
  @gravity_point.setter
  def gravity_point(self,  value:'bool'):
    self.set_gravity_is_point(value)
  @property
  def gravity_point_unit_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_gravity_point_unit_distance()
    return _ret
  @gravity_point_unit_distance.setter
  def gravity_point_unit_distance(self,  value:'float'):
    self.set_gravity_point_unit_distance(value)
  @property
  def gravity_point_center(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_gravity_point_center()
    return _ret
  @gravity_point_center.setter
  def gravity_point_center(self,  value:'Vector3'):
    self.set_gravity_point_center(value)
  @property
  def gravity_direction(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_gravity_direction()
    return _ret
  @gravity_direction.setter
  def gravity_direction(self,  value:'Vector3'):
    self.set_gravity_direction(value)
  @property
  def gravity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_gravity()
    return _ret
  @gravity.setter
  def gravity(self,  value:'float'):
    self.set_gravity(value)
  @property
  def linear_damp_space_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_linear_damp_space_override_mode()
    return _ret
  @linear_damp_space_override.setter
  def linear_damp_space_override(self,  value:'int'):
    self.set_linear_damp_space_override_mode(value)
  @property
  def linear_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_linear_damp()
    return _ret
  @linear_damp.setter
  def linear_damp(self,  value:'float'):
    self.set_linear_damp(value)
  @property
  def angular_damp_space_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_angular_damp_space_override_mode()
    return _ret
  @angular_damp_space_override.setter
  def angular_damp_space_override(self,  value:'int'):
    self.set_angular_damp_space_override_mode(value)
  @property
  def angular_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_angular_damp()
    return _ret
  @angular_damp.setter
  def angular_damp(self,  value:'float'):
    self.set_angular_damp(value)
  @property
  def wind_force_magnitude(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_wind_force_magnitude()
    return _ret
  @wind_force_magnitude.setter
  def wind_force_magnitude(self,  value:'float'):
    self.set_wind_force_magnitude(value)
  @property
  def wind_attenuation_factor(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_wind_attenuation_factor()
    return _ret
  @wind_attenuation_factor.setter
  def wind_attenuation_factor(self,  value:'float'):
    self.set_wind_attenuation_factor(value)
  @property
  def wind_source_path(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_wind_source_path()
    return _ret
  @wind_source_path.setter
  def wind_source_path(self,  value:'object'):
    self.set_wind_source_path(value)
  @property
  def audio_bus_override(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_overriding_audio_bus()
    return _ret
  @audio_bus_override.setter
  def audio_bus_override(self,  value:'bool'):
    self.set_audio_bus_override(value)
  @property
  def audio_bus_name(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_audio_bus_name()
    return _ret
  @audio_bus_name.setter
  def audio_bus_name(self,  value:'object'):
    self.set_audio_bus_name(value)
  @property
  def reverb_bus_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_reverb_bus()
    return _ret
  @reverb_bus_enabled.setter
  def reverb_bus_enabled(self,  value:'bool'):
    self.set_use_reverb_bus(value)
  @property
  def reverb_bus_name(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_reverb_bus_name()
    return _ret
  @reverb_bus_name.setter
  def reverb_bus_name(self,  value:'object'):
    self.set_reverb_bus_name(value)
  @property
  def reverb_bus_amount(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_reverb_amount()
    return _ret
  @reverb_bus_amount.setter
  def reverb_bus_amount(self,  value:'float'):
    self.set_reverb_amount(value)
  @property
  def reverb_bus_uniformity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_reverb_uniformity()
    return _ret
  @reverb_bus_uniformity.setter
  def reverb_bus_uniformity(self,  value:'float'):
    self.set_reverb_uniformity(value)
  @functools.native_method
  def set_gravity_space_override_mode(self, space_override_mode:'int'  ) -> None:
    r''''''

    assert isinstance(space_override_mode, (int, float)), 'space_override_mode must be int or float'

    self.py__gravity_space_override = space_override_mode






    self._ptr.call_with_return(286,tuple([space_override_mode]))

  @functools.native_method
  def get_gravity_space_override_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_is_point(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gravity_point = enable






    self._ptr.call_with_return(288,tuple([enable]))

  @functools.native_method
  def is_gravity_a_point(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_point_unit_distance(self, distance_scale:'float'   ) -> None:
    r''''''

    assert isinstance(distance_scale, (int, float)), 'distance_scale must be int or float'

    self.py__gravity_point_unit_distance = distance_scale






    self._ptr.call_with_return(290,tuple([distance_scale]))

  @functools.native_method
  def get_gravity_point_unit_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_point_center(self, center:'Vector3'   ) -> None:
    r''''''

    assert(not center is None)
    assert isinstance(center, Vector3), 'center must be Vector3'

    self.py__gravity_point_center = center






    self._ptr.call_with_return(292,tuple([center._ptr]))

  @functools.native_method
  def get_gravity_point_center(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_direction(self, direction:'Vector3'   ) -> None:
    r''''''

    assert(not direction is None)
    assert isinstance(direction, Vector3), 'direction must be Vector3'

    self.py__gravity_direction = direction






    self._ptr.call_with_return(294,tuple([direction._ptr]))

  @functools.native_method
  def get_gravity_direction(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(295,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity(self, gravity:'float'   ) -> None:
    r''''''

    assert isinstance(gravity, (int, float)), 'gravity must be int or float'

    self.py__gravity = gravity






    self._ptr.call_with_return(296,tuple([gravity]))

  @functools.native_method
  def get_gravity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp_space_override_mode(self, space_override_mode:'int'  ) -> None:
    r''''''

    assert isinstance(space_override_mode, (int, float)), 'space_override_mode must be int or float'

    self.py__linear_damp_space_override = space_override_mode






    self._ptr.call_with_return(298,tuple([space_override_mode]))

  @functools.native_method
  def get_linear_damp_space_override_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(299,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp_space_override_mode(self, space_override_mode:'int'  ) -> None:
    r''''''

    assert isinstance(space_override_mode, (int, float)), 'space_override_mode must be int or float'

    self.py__angular_damp_space_override = space_override_mode






    self._ptr.call_with_return(300,tuple([space_override_mode]))

  @functools.native_method
  def get_angular_damp_space_override_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(301,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp(self, angular_damp:'float'   ) -> None:
    r''''''

    assert isinstance(angular_damp, (int, float)), 'angular_damp must be int or float'

    self.py__angular_damp = angular_damp






    self._ptr.call_with_return(302,tuple([angular_damp]))

  @functools.native_method
  def get_angular_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(303,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp(self, linear_damp:'float'   ) -> None:
    r''''''

    assert isinstance(linear_damp, (int, float)), 'linear_damp must be int or float'

    self.py__linear_damp = linear_damp






    self._ptr.call_with_return(304,tuple([linear_damp]))

  @functools.native_method
  def get_linear_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def set_priority(self, priority:'int'   ) -> None:
    r''''''

    assert isinstance(priority, (int, float)), 'priority must be int or float'

    self.py__priority = priority






    self._ptr.call_with_return(306,tuple([priority]))

  @functools.native_method
  def get_priority(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(307,tuple([]))

    return _ret


  @functools.native_method
  def set_wind_force_magnitude(self, wind_force_magnitude:'float'   ) -> None:
    r''''''

    assert isinstance(wind_force_magnitude, (int, float)), 'wind_force_magnitude must be int or float'

    self.py__wind_force_magnitude = wind_force_magnitude






    self._ptr.call_with_return(308,tuple([wind_force_magnitude]))

  @functools.native_method
  def get_wind_force_magnitude(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(309,tuple([]))

    return _ret


  @functools.native_method
  def set_wind_attenuation_factor(self, wind_attenuation_factor:'float'   ) -> None:
    r''''''

    assert isinstance(wind_attenuation_factor, (int, float)), 'wind_attenuation_factor must be int or float'

    self.py__wind_attenuation_factor = wind_attenuation_factor






    self._ptr.call_with_return(310,tuple([wind_attenuation_factor]))

  @functools.native_method
  def get_wind_attenuation_factor(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def set_wind_source_path(self, wind_source_path:'object'   ) -> None:
    r''''''

    assert(not wind_source_path is None)
    assert isinstance(wind_source_path, (str, NodePath)), 'wind_source_path must be str or NodePath'

    self.py__wind_source_path = wind_source_path



    assert(isinstance(wind_source_path, (str, NodePath)))
    py_nodepath_wind_source_path = wind_source_path if isinstance(wind_source_path,NodePath) else NodePath.new2(wind_source_path)


    self._ptr.call_with_return(312,tuple([py_nodepath_wind_source_path._ptr]))

  @functools.native_method
  def get_wind_source_path(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def set_monitorable(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__monitorable = enable






    self._ptr.call_with_return(314,tuple([enable]))

  @functools.native_method
  def is_monitorable(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([]))

    return _ret


  @functools.native_method
  def set_monitoring(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__monitoring = enable






    self._ptr.call_with_return(316,tuple([enable]))

  @functools.native_method
  def is_monitoring(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def get_overlapping_bodies(self) -> typing.Union['py4godot_node3dtypedarray.Node3DTypedArray']:
    r'''
				Returns a list of intersecting `PhysicsBody3D`s and `GridMap`s. The overlapping body's `CollisionObject3D.collision_layer` must be part of this area's `CollisionObject3D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = py4godot_node3dtypedarray.Node3DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(318,tuple([]))
    return _ret


  @functools.native_method
  def get_overlapping_areas(self) -> typing.Union['py4godot_area3dtypedarray.Area3DTypedArray']:
    r'''
				Returns a list of intersecting `Area3D`s. The overlapping area's `CollisionObject3D.collision_layer` must be part of this area's `CollisionObject3D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = py4godot_area3dtypedarray.Area3DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(319,tuple([]))
    return _ret


  @functools.native_method
  def has_overlapping_bodies(self) -> typing.Union[bool]:
    r'''
				Returns `true` if intersecting any `PhysicsBody3D`s or `GridMap`s, otherwise returns `false`. The overlapping body's `CollisionObject3D.collision_layer` must be part of this area's `CollisionObject3D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) the list of overlapping bodies is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(320,tuple([]))
    return _ret


  @functools.native_method
  def has_overlapping_areas(self) -> typing.Union[bool]:
    r'''
				Returns `true` if intersecting any `Area3D`s, otherwise returns `false`. The overlapping area's `CollisionObject3D.collision_layer` must be part of this area's `CollisionObject3D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) the list of overlapping areas is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))
    return _ret


  @functools.native_method
  def overlaps_body(self, body:'py4godot_node.Node'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given physics body intersects or overlaps this `Area3D`, `false` otherwise.
				**Note:** The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
				The `body` argument can either be a `PhysicsBody3D` or a `GridMap` instance. While GridMaps are not physics body themselves, they register their tiles with collision shapes as a virtual physics body.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'






    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def overlaps_area(self, area:'py4godot_node.Node'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `Area3D` intersects or overlaps this `Area3D`, `false` otherwise.
				**Note:** The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
			'''

    assert(not area is None)
    assert isinstance(area, get_class('Node')), 'area must be Node'






    _ret = 0
    _ret = self._ptr.call_with_return(323,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def set_audio_bus_override(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__audio_bus_override = enable






    self._ptr.call_with_return(324,tuple([enable]))

  @functools.native_method
  def is_overriding_audio_bus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([]))

    return _ret


  @functools.native_method
  def set_audio_bus_name(self, name:'object'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'

    self.py__audio_bus_name = name



    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(326,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_audio_bus_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(327,tuple([]))

    return _ret


  @functools.native_method
  def set_use_reverb_bus(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__reverb_bus_enabled = enable






    self._ptr.call_with_return(328,tuple([enable]))

  @functools.native_method
  def is_using_reverb_bus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([]))

    return _ret


  @functools.native_method
  def set_reverb_bus_name(self, name:'object'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'

    self.py__reverb_bus_name = name



    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(330,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_reverb_bus_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(331,tuple([]))

    return _ret


  @functools.native_method
  def set_reverb_amount(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'

    self.py__reverb_bus_amount = amount






    self._ptr.call_with_return(332,tuple([amount]))

  @functools.native_method
  def get_reverb_amount(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(333,tuple([]))

    return _ret


  @functools.native_method
  def set_reverb_uniformity(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'

    self.py__reverb_bus_uniformity = amount






    self._ptr.call_with_return(334,tuple([amount]))

  @functools.native_method
  def get_reverb_uniformity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(335,tuple([]))

    return _ret



register_cast_function('Area3D', Area3D.cast)
register_class('Area3D', Area3D)
