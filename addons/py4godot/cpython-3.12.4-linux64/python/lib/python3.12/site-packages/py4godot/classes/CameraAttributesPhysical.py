# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.CameraAttributes as py4godot_cameraattributes 
from py4godot.wrappers.wrappers import CPPCameraAttributesPhysicalWrapper


class CameraAttributesPhysical(py4godot_cameraattributes.CameraAttributes):
  r'''
		`CameraAttributesPhysical` is used to set rendering settings based on a physically-based camera's settings. It is responsible for exposure, auto-exposure, and depth of field.
		When used in a `WorldEnvironment` it provides default settings for exposure, auto-exposure, and depth of field that will be used by all cameras without their own `CameraAttributes`, including the editor camera. When used in a `Camera3D` it will override any `CameraAttributes` set in the `WorldEnvironment` and will override the `Camera3D`s `Camera3D.far`, `Camera3D.near`, `Camera3D.fov`, and `Camera3D.keep_aspect` properties. When used in `VoxelGI` or `LightmapGI`, only the exposure settings will be used.
		The default settings are intended for use in an outdoor environment, tips for settings for use in an indoor environment can be found in each setting's documentation.
		**Note:** Depth of field blur is only supported in the Forward+ and Mobile rendering methods, not Compatibility.
	'''

  @staticmethod
  def constructor():
    class_ = CameraAttributesPhysical.construct_without_init()
    class_._ptr = constructor(191,0, ())
    return class_
  @staticmethod
  def new():
    class_ = CameraAttributesPhysical.construct_without_init()
    class_._ptr = constructor(191,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCameraAttributesPhysicalWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(191,0, ())


  def generate_wrapper(self):
    return CPPCameraAttributesPhysicalWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = CameraAttributesPhysical.__new__(CameraAttributesPhysical)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'CameraAttributesPhysical'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = CameraAttributesPhysical.construct_without_init()
    cls._ptr = CPPCameraAttributesPhysicalWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = CameraAttributesPhysical.construct_without_init()
    cls._ptr = CPPCameraAttributesPhysicalWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def frustum_focus_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_focus_distance()
    return _ret
  @frustum_focus_distance.setter
  def frustum_focus_distance(self,  value:'float'):
    self.set_focus_distance(value)
  @property
  def frustum_focal_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_focal_length()
    return _ret
  @frustum_focal_length.setter
  def frustum_focal_length(self,  value:'float'):
    self.set_focal_length(value)
  @property
  def frustum_near(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_near()
    return _ret
  @frustum_near.setter
  def frustum_near(self,  value:'float'):
    self.set_near(value)
  @property
  def frustum_far(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_far()
    return _ret
  @frustum_far.setter
  def frustum_far(self,  value:'float'):
    self.set_far(value)
  @property
  def exposure_aperture(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_aperture()
    return _ret
  @exposure_aperture.setter
  def exposure_aperture(self,  value:'float'):
    self.set_aperture(value)
  @property
  def exposure_shutter_speed(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_shutter_speed()
    return _ret
  @exposure_shutter_speed.setter
  def exposure_shutter_speed(self,  value:'float'):
    self.set_shutter_speed(value)
  @property
  def auto_exposure_min_exposure_value(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_auto_exposure_min_exposure_value()
    return _ret
  @auto_exposure_min_exposure_value.setter
  def auto_exposure_min_exposure_value(self,  value:'float'):
    self.set_auto_exposure_min_exposure_value(value)
  @property
  def auto_exposure_max_exposure_value(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_auto_exposure_max_exposure_value()
    return _ret
  @auto_exposure_max_exposure_value.setter
  def auto_exposure_max_exposure_value(self,  value:'float'):
    self.set_auto_exposure_max_exposure_value(value)
  @functools.native_method
  def set_aperture(self, aperture:'float'   ) -> None:
    r''''''

    assert isinstance(aperture, (int, float)), 'aperture must be int or float'

    self.py__exposure_aperture = aperture






    self._ptr.call_with_return(87,tuple([aperture]))

  @functools.native_method
  def get_aperture(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_shutter_speed(self, shutter_speed:'float'   ) -> None:
    r''''''

    assert isinstance(shutter_speed, (int, float)), 'shutter_speed must be int or float'

    self.py__exposure_shutter_speed = shutter_speed






    self._ptr.call_with_return(89,tuple([shutter_speed]))

  @functools.native_method
  def get_shutter_speed(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_focal_length(self, focal_length:'float'   ) -> None:
    r''''''

    assert isinstance(focal_length, (int, float)), 'focal_length must be int or float'

    self.py__frustum_focal_length = focal_length






    self._ptr.call_with_return(91,tuple([focal_length]))

  @functools.native_method
  def get_focal_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_focus_distance(self, focus_distance:'float'   ) -> None:
    r''''''

    assert isinstance(focus_distance, (int, float)), 'focus_distance must be int or float'

    self.py__frustum_focus_distance = focus_distance






    self._ptr.call_with_return(93,tuple([focus_distance]))

  @functools.native_method
  def get_focus_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_near(self, near:'float'   ) -> None:
    r''''''

    assert isinstance(near, (int, float)), 'near must be int or float'

    self.py__frustum_near = near






    self._ptr.call_with_return(95,tuple([near]))

  @functools.native_method
  def get_near(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))

    return _ret


  @functools.native_method
  def set_far(self, far:'float'   ) -> None:
    r''''''

    assert isinstance(far, (int, float)), 'far must be int or float'

    self.py__frustum_far = far






    self._ptr.call_with_return(97,tuple([far]))

  @functools.native_method
  def get_far(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def get_fov(self) -> typing.Union[float]:
    r'''
				Returns the vertical field of view that corresponds to the `frustum_focal_length`. This value is calculated internally whenever `frustum_focal_length` is changed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([]))
    return _ret


  @functools.native_method
  def set_auto_exposure_max_exposure_value(self, exposure_value_max:'float'   ) -> None:
    r''''''

    assert isinstance(exposure_value_max, (int, float)), 'exposure_value_max must be int or float'

    self.py__auto_exposure_max_exposure_value = exposure_value_max






    self._ptr.call_with_return(100,tuple([exposure_value_max]))

  @functools.native_method
  def get_auto_exposure_max_exposure_value(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))

    return _ret


  @functools.native_method
  def set_auto_exposure_min_exposure_value(self, exposure_value_min:'float'   ) -> None:
    r''''''

    assert isinstance(exposure_value_min, (int, float)), 'exposure_value_min must be int or float'

    self.py__auto_exposure_min_exposure_value = exposure_value_min






    self._ptr.call_with_return(102,tuple([exposure_value_min]))

  @functools.native_method
  def get_auto_exposure_min_exposure_value(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([]))

    return _ret



register_cast_function('CameraAttributesPhysical', CameraAttributesPhysical.cast)
register_class('CameraAttributesPhysical', CameraAttributesPhysical)
