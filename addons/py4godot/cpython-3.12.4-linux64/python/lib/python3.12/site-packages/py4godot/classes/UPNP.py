# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.UPNPDevice as py4godot_upnpdevice 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPUPNPWrapper

class UPNPResult:
  UPNP_RESULT_SUCCESS = 0
  UPNP_RESULT_NOT_AUTHORIZED = 1
  UPNP_RESULT_PORT_MAPPING_NOT_FOUND = 2
  UPNP_RESULT_INCONSISTENT_PARAMETERS = 3
  UPNP_RESULT_NO_SUCH_ENTRY_IN_ARRAY = 4
  UPNP_RESULT_ACTION_FAILED = 5
  UPNP_RESULT_SRC_IP_WILDCARD_NOT_PERMITTED = 6
  UPNP_RESULT_EXT_PORT_WILDCARD_NOT_PERMITTED = 7
  UPNP_RESULT_INT_PORT_WILDCARD_NOT_PERMITTED = 8
  UPNP_RESULT_REMOTE_HOST_MUST_BE_WILDCARD = 9
  UPNP_RESULT_EXT_PORT_MUST_BE_WILDCARD = 10
  UPNP_RESULT_NO_PORT_MAPS_AVAILABLE = 11
  UPNP_RESULT_CONFLICT_WITH_OTHER_MECHANISM = 12
  UPNP_RESULT_CONFLICT_WITH_OTHER_MAPPING = 13
  UPNP_RESULT_SAME_PORT_VALUES_REQUIRED = 14
  UPNP_RESULT_ONLY_PERMANENT_LEASE_SUPPORTED = 15
  UPNP_RESULT_INVALID_GATEWAY = 16
  UPNP_RESULT_INVALID_PORT = 17
  UPNP_RESULT_INVALID_PROTOCOL = 18
  UPNP_RESULT_INVALID_DURATION = 19
  UPNP_RESULT_INVALID_ARGS = 20
  UPNP_RESULT_INVALID_RESPONSE = 21
  UPNP_RESULT_INVALID_PARAM = 22
  UPNP_RESULT_HTTP_ERROR = 23
  UPNP_RESULT_SOCKET_ERROR = 24
  UPNP_RESULT_MEM_ALLOC_ERROR = 25
  UPNP_RESULT_NO_GATEWAY = 26
  UPNP_RESULT_NO_DEVICES = 27
  UPNP_RESULT_UNKNOWN_ERROR = 28


class UPNP(py4godot_refcounted.RefCounted):
  r''''''

  @staticmethod
  def constructor():
    class_ = UPNP.construct_without_init()
    class_._ptr = constructor(856,0, ())
    return class_
  @staticmethod
  def new():
    class_ = UPNP.construct_without_init()
    class_._ptr = constructor(856,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPUPNPWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(856,0, ())


  def generate_wrapper(self):
    return CPPUPNPWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = UPNP.__new__(UPNP)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'UPNP'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = UPNP.construct_without_init()
    cls._ptr = CPPUPNPWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = UPNP.construct_without_init()
    cls._ptr = CPPUPNPWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def discover_multicast_if(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_discover_multicast_if()
    return _ret
  @discover_multicast_if.setter
  def discover_multicast_if(self,  value:'str'):
    self.set_discover_multicast_if(value)
  @property
  def discover_local_port(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_discover_local_port()
    return _ret
  @discover_local_port.setter
  def discover_local_port(self,  value:'int'):
    self.set_discover_local_port(value)
  @property
  def discover_ipv6(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_discover_ipv6()
    return _ret
  @discover_ipv6.setter
  def discover_ipv6(self,  value:'bool'):
    self.set_discover_ipv6(value)
  @functools.native_method
  def get_device_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def get_device(self, index:'int'   ) -> typing.Union['py4godot_upnpdevice.UPNPDevice']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: UPNPDevice
    _ret._ptr = self._ptr.call_with_return(54,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def add_device(self, device:'py4godot_upnpdevice.UPNPDevice'   ) -> None:
    r''''''

    assert(not device is None)
    assert isinstance(device, get_class('UPNPDevice')), 'device must be UPNPDevice'






    self._ptr.call_with_return(55,tuple([device._ptr]))

  @functools.native_method
  def set_device(self, index:'int'   , device:'py4godot_upnpdevice.UPNPDevice'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not device is None)
    assert isinstance(device, get_class('UPNPDevice')), 'device must be UPNPDevice'







    self._ptr.call_with_return(56,tuple([index, device._ptr]))

  @functools.native_method
  def remove_device(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(57,tuple([index]))

  @functools.native_method
  def clear_devices(self) -> None:
    r''''''




    self._ptr.call_with_return(58,tuple([]))

  @functools.native_method
  def get_gateway(self) -> typing.Union['py4godot_upnpdevice.UPNPDevice']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: UPNPDevice
    _ret._ptr = self._ptr.call_with_return(59,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def discover(self, timeout:'int' =2000  , ttl:'int' =2  , device_filter:'str' ="InternetGatewayDevice"  ) -> typing.Union[int]:
    r''''''
    if device_filter is None:
      device_filter = String.new0()
    if device_filter is None:
      device_filter = String.new0()

    assert isinstance(timeout, (int, float)), 'timeout must be int or float'
    assert isinstance(ttl, (int, float)), 'ttl must be int or float'






    assert(isinstance(device_filter, (str, String)))
    py_string_device_filter = device_filter if isinstance(device_filter, StringName) else c_utils.py_string_to_string(device_filter)

    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([timeout, ttl, py_string_device_filter._ptr]))
    return _ret


  @functools.native_method
  def query_external_address(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def add_port_mapping(self, port:'int'   , port_internal:'int' =0  , desc:'str' =""  , proto:'str' ="UDP"  , duration:'int' =0  ) -> typing.Union[int]:
    r''''''
    if desc is None:
      desc = String.new0()
    if proto is None:
      proto = String.new0()
    if desc is None:
      desc = String.new0()
    if proto is None:
      proto = String.new0()

    assert isinstance(port, (int, float)), 'port must be int or float'
    assert isinstance(port_internal, (int, float)), 'port_internal must be int or float'
    assert isinstance(duration, (int, float)), 'duration must be int or float'






    assert(isinstance(desc, (str, String)))
    py_string_desc = desc if isinstance(desc, StringName) else c_utils.py_string_to_string(desc)
    assert(isinstance(proto, (str, String)))
    py_string_proto = proto if isinstance(proto, StringName) else c_utils.py_string_to_string(proto)


    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([port, port_internal, py_string_desc._ptr, py_string_proto._ptr, duration]))
    return _ret


  @functools.native_method
  def delete_port_mapping(self, port:'int'   , proto:'str' ="UDP"  ) -> typing.Union[int]:
    r''''''
    if proto is None:
      proto = String.new0()
    if proto is None:
      proto = String.new0()

    assert isinstance(port, (int, float)), 'port must be int or float'





    assert(isinstance(proto, (str, String)))
    py_string_proto = proto if isinstance(proto, StringName) else c_utils.py_string_to_string(proto)

    _ret = 0
    _ret = self._ptr.call_with_return(63,tuple([port, py_string_proto._ptr]))
    return _ret


  @functools.native_method
  def set_discover_multicast_if(self, m_if:'str'   ) -> None:
    r''''''

    assert(not m_if is None)
    assert isinstance(m_if, (str, String)), 'm_if must be str or String'

    self.py__discover_multicast_if = m_if



    assert(isinstance(m_if, (str, String)))
    py_string_m_if = m_if if isinstance(m_if, StringName) else c_utils.py_string_to_string(m_if)

    py__string_m_if = utils.py_string_to_string(m_if)
    py__string_m_if.shouldBeDeleted = False


    self._ptr.call_with_return(64,tuple([py__string_m_if._ptr]))

  @functools.native_method
  def get_discover_multicast_if(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(65,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_discover_local_port(self, port:'int'   ) -> None:
    r''''''

    assert isinstance(port, (int, float)), 'port must be int or float'

    self.py__discover_local_port = port






    self._ptr.call_with_return(66,tuple([port]))

  @functools.native_method
  def get_discover_local_port(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([]))

    return _ret


  @functools.native_method
  def set_discover_ipv6(self, ipv6:'bool'   ) -> None:
    r''''''

    assert isinstance(ipv6, bool), 'ipv6 must be bool'

    self.py__discover_ipv6 = ipv6






    self._ptr.call_with_return(68,tuple([ipv6]))

  @functools.native_method
  def is_discover_ipv6(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))

    return _ret



register_cast_function('UPNP', UPNP.cast)
register_class('UPNP', UPNP)
