# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Environment as py4godot_environment 
  import py4godot.classes.Compositor as py4godot_compositor 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.CameraAttributesPhysical as py4godot_cameraattributesphysical 
  import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
  import py4godot.classes.CameraAttributes as py4godot_cameraattributes 
  import py4godot.classes.CameraAttributesPractical as py4godot_cameraattributespractical 
import py4godot.classes.Node3D as py4godot_node3d 
import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
from py4godot.wrappers.wrappers import CPPCamera3DWrapper

class ProjectionType:
  PROJECTION_PERSPECTIVE = 0
  PROJECTION_ORTHOGONAL = 1
  PROJECTION_FRUSTUM = 2
class KeepAspect:
  KEEP_WIDTH = 0
  KEEP_HEIGHT = 1
class DopplerTracking:
  DOPPLER_TRACKING_DISABLED = 0
  DOPPLER_TRACKING_IDLE_STEP = 1
  DOPPLER_TRACKING_PHYSICS_STEP = 2


class Camera3D(py4godot_node3d.Node3D):
  r'''
		`Camera3D` is a special node that displays what is visible from its current location. Cameras register themselves in the nearest `Viewport` node (when ascending the tree). Only one camera can be active per viewport. If no viewport is available ascending the tree, the camera will register in the global viewport. In other words, a camera just provides 3D display capabilities to a `Viewport`, and, without one, a scene registered in that `Viewport` (or higher viewports) can't be displayed.
	'''

  @staticmethod
  def constructor():
    class_ = Camera3D.construct_without_init()
    class_._ptr = constructor(189,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Camera3D.construct_without_init()
    class_._ptr = constructor(189,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCamera3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(189,0, ())


  def generate_wrapper(self):
    return CPPCamera3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Camera3D.__new__(Camera3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Camera3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Camera3D.construct_without_init()
    cls._ptr = CPPCamera3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Camera3D.construct_without_init()
    cls._ptr = CPPCamera3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def keep_aspect(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_keep_aspect_mode()
    return _ret
  @keep_aspect.setter
  def keep_aspect(self,  value:'int'):
    self.set_keep_aspect_mode(value)
  @property
  def cull_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cull_mask()
    return _ret
  @cull_mask.setter
  def cull_mask(self,  value:'int'):
    self.set_cull_mask(value)
  @property
  def environment(self) -> typing.Union['py4godot_environment.Environment']:
    r''''''
    _ret = self. get_environment()
    return _ret
  @environment.setter
  def environment(self,  value:'py4godot_object.Object'):
    self.set_environment(value)
  @property
  def attributes(self) -> typing.Union['py4godot_cameraattributespractical.CameraAttributesPractical']:
    r''''''
    _ret = self. get_attributes()
    return _ret
  @attributes.setter
  def attributes(self,  value:'py4godot_object.Object'):
    self.set_attributes(value)
  @property
  def compositor(self) -> typing.Union['py4godot_compositor.Compositor']:
    r''''''
    _ret = self. get_compositor()
    return _ret
  @compositor.setter
  def compositor(self,  value:'py4godot_object.Object'):
    self.set_compositor(value)
  @property
  def h_offset(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_h_offset()
    return _ret
  @h_offset.setter
  def h_offset(self,  value:'float'):
    self.set_h_offset(value)
  @property
  def v_offset(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_v_offset()
    return _ret
  @v_offset.setter
  def v_offset(self,  value:'float'):
    self.set_v_offset(value)
  @property
  def doppler_tracking(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_doppler_tracking()
    return _ret
  @doppler_tracking.setter
  def doppler_tracking(self,  value:'int'):
    self.set_doppler_tracking(value)
  @property
  def projection(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_projection()
    return _ret
  @projection.setter
  def projection(self,  value:'int'):
    self.set_projection(value)
  @property
  def current(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_current()
    return _ret
  @current.setter
  def current(self,  value:'bool'):
    self.set_current(value)
  @property
  def fov(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fov()
    return _ret
  @fov.setter
  def fov(self,  value:'float'):
    self.set_fov(value)
  @property
  def size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'float'):
    self.set_size(value)
  @property
  def frustum_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_frustum_offset()
    return _ret
  @frustum_offset.setter
  def frustum_offset(self,  value:'Vector2'):
    self.set_frustum_offset(value)
  @property
  def near(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_near()
    return _ret
  @near.setter
  def near(self,  value:'float'):
    self.set_near(value)
  @property
  def far(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_far()
    return _ret
  @far.setter
  def far(self,  value:'float'):
    self.set_far(value)
  @functools.native_method
  def project_ray_normal(self, screen_point:'Vector2'   ) -> typing.Union['Vector3']:
    r'''
				Returns a normal vector in world space, that is the result of projecting a point on the `Viewport` rectangle by the inverse camera projection. This is useful for casting rays in the form of (origin, normal) for object intersection or picking.
			'''

    assert(not screen_point is None)
    assert isinstance(screen_point, Vector2), 'screen_point must be Vector2'






    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(251,tuple([screen_point._ptr]))
    return _ret


  @functools.native_method
  def project_local_ray_normal(self, screen_point:'Vector2'   ) -> typing.Union['Vector3']:
    r'''
				Returns a normal vector from the screen point location directed along the camera. Orthogonal cameras are normalized. Perspective cameras account for perspective, screen width/height, etc.
			'''

    assert(not screen_point is None)
    assert isinstance(screen_point, Vector2), 'screen_point must be Vector2'






    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(252,tuple([screen_point._ptr]))
    return _ret


  @functools.native_method
  def project_ray_origin(self, screen_point:'Vector2'   ) -> typing.Union['Vector3']:
    r'''
				Returns a 3D position in world space, that is the result of projecting a point on the `Viewport` rectangle by the inverse camera projection. This is useful for casting rays in the form of (origin, normal) for object intersection or picking.
			'''

    assert(not screen_point is None)
    assert isinstance(screen_point, Vector2), 'screen_point must be Vector2'






    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(253,tuple([screen_point._ptr]))
    return _ret


  @functools.native_method
  def unproject_position(self, world_point:'Vector3'   ) -> typing.Union['Vector2']:
    r'''
				Returns the 2D coordinate in the `Viewport` rectangle that maps to the given 3D point in world space.
				**Note:** When using this to position GUI elements over a 3D viewport, use `is_position_behind` to prevent them from appearing if the 3D point is behind the camera:
				```gdscript
				# This code block is part of a script that inherits from Node3D.
				# `control` is a reference to a node inheriting from Control.
				control.visible = not get_viewport().get_camera_3d().is_position_behind(global_transform.origin)
				control.position = get_viewport().get_camera_3d().unproject_position(global_transform.origin)
				```
			'''

    assert(not world_point is None)
    assert isinstance(world_point, Vector3), 'world_point must be Vector3'






    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(254,tuple([world_point._ptr]))
    return _ret


  @functools.native_method
  def is_position_behind(self, world_point:'Vector3'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given position is behind the camera (the blue part of the linked diagram). `url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/camera3d_position_frustum.png`See this diagram`/url` for an overview of position query methods.
				**Note:** A position which returns `false` may still be outside the camera's field of view.
			'''

    assert(not world_point is None)
    assert isinstance(world_point, Vector3), 'world_point must be Vector3'






    _ret = 0
    _ret = self._ptr.call_with_return(255,tuple([world_point._ptr]))
    return _ret


  @functools.native_method
  def project_position(self, screen_point:'Vector2'   , z_depth:'float'   ) -> typing.Union['Vector3']:
    r'''
				Returns the 3D point in world space that maps to the given 2D coordinate in the `Viewport` rectangle on a plane that is the given `z_depth` distance into the scene away from the camera.
			'''

    assert(not screen_point is None)
    assert isinstance(screen_point, Vector2), 'screen_point must be Vector2'
    assert isinstance(z_depth, (int, float)), 'z_depth must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(256,tuple([screen_point._ptr, z_depth]))
    return _ret


  @functools.native_method
  def set_perspective(self, fov:'float'   , z_near:'float'   , z_far:'float'   ) -> None:
    r'''
				Sets the camera projection to perspective mode (see `constant PROJECTION_PERSPECTIVE`), by specifying a `fov` (field of view) angle in degrees, and the `z_near` and `z_far` clip planes in world space units.
			'''

    assert isinstance(fov, (int, float)), 'fov must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'








    self._ptr.call_with_return(257,tuple([fov, z_near, z_far]))

  @functools.native_method
  def set_orthogonal(self, size:'float'   , z_near:'float'   , z_far:'float'   ) -> None:
    r'''
				Sets the camera projection to orthogonal mode (see `constant PROJECTION_ORTHOGONAL`), by specifying a `size`, and the `z_near` and `z_far` clip planes in world space units.
				As a hint, 3D games that look 2D often use this projection, with `size` specified in pixels.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'








    self._ptr.call_with_return(258,tuple([size, z_near, z_far]))

  @functools.native_method
  def set_frustum(self, size:'float'   , offset:'Vector2'   , z_near:'float'   , z_far:'float'   ) -> None:
    r'''
				Sets the camera projection to frustum mode (see `constant PROJECTION_FRUSTUM`), by specifying a `size`, an `offset`, and the `z_near` and `z_far` clip planes in world space units. See also `frustum_offset`.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'









    self._ptr.call_with_return(259,tuple([size, offset._ptr, z_near, z_far]))

  @functools.native_method
  def make_current(self) -> None:
    r'''
				Makes this camera the current camera for the `Viewport` (see class description). If the camera node is outside the scene tree, it will attempt to become current once it's added.
			'''




    self._ptr.call_with_return(260,tuple([]))

  @functools.native_method
  def clear_current(self, enable_next:'bool' =True  ) -> None:
    r'''
				If this is the current camera, remove it from being current. If `enable_next` is `true`, request to make the next camera current, if any.
			'''

    assert isinstance(enable_next, bool), 'enable_next must be bool'






    self._ptr.call_with_return(261,tuple([enable_next]))

  @functools.native_method
  def set_current(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__current = enabled






    self._ptr.call_with_return(262,tuple([enabled]))

  @functools.native_method
  def is_current(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([]))

    return _ret


  @functools.native_method
  def get_camera_transform(self) -> typing.Union['Transform3D']:
    r'''
				Returns the transform of the camera plus the vertical (`v_offset`) and horizontal (`h_offset`) offsets; and any other adjustments made to the position and orientation of the camera by subclassed cameras such as `XRCamera3D`.
			'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(264,tuple([]))
    return _ret


  @functools.native_method
  def get_camera_projection(self) -> typing.Union['Projection']:
    r'''
				Returns the projection matrix that this camera uses to render to its associated viewport. The camera must be part of the scene tree to function.
			'''




    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(265,tuple([]))
    return _ret


  @functools.native_method
  def get_fov(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(266,tuple([]))

    return _ret


  @functools.native_method
  def get_frustum_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(267,tuple([]))

    return _ret


  @functools.native_method
  def get_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(268,tuple([]))

    return _ret


  @functools.native_method
  def get_far(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def get_near(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(270,tuple([]))

    return _ret


  @functools.native_method
  def set_fov(self, fov:'float'   ) -> None:
    r''''''

    assert isinstance(fov, (int, float)), 'fov must be int or float'

    self.py__fov = fov






    self._ptr.call_with_return(271,tuple([fov]))

  @functools.native_method
  def set_frustum_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'

    self.py__frustum_offset = offset






    self._ptr.call_with_return(272,tuple([offset._ptr]))

  @functools.native_method
  def set_size(self, size:'float'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'

    self.py__size = size






    self._ptr.call_with_return(273,tuple([size]))

  @functools.native_method
  def set_far(self, far:'float'   ) -> None:
    r''''''

    assert isinstance(far, (int, float)), 'far must be int or float'

    self.py__far = far






    self._ptr.call_with_return(274,tuple([far]))

  @functools.native_method
  def set_near(self, near:'float'   ) -> None:
    r''''''

    assert isinstance(near, (int, float)), 'near must be int or float'

    self.py__near = near






    self._ptr.call_with_return(275,tuple([near]))

  @functools.native_method
  def get_projection(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(276,tuple([]))

    return _ret


  @functools.native_method
  def set_projection(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__projection = mode






    self._ptr.call_with_return(277,tuple([mode]))

  @functools.native_method
  def set_h_offset(self, offset:'float'   ) -> None:
    r''''''

    assert isinstance(offset, (int, float)), 'offset must be int or float'

    self.py__h_offset = offset






    self._ptr.call_with_return(278,tuple([offset]))

  @functools.native_method
  def get_h_offset(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def set_v_offset(self, offset:'float'   ) -> None:
    r''''''

    assert isinstance(offset, (int, float)), 'offset must be int or float'

    self.py__v_offset = offset






    self._ptr.call_with_return(280,tuple([offset]))

  @functools.native_method
  def get_v_offset(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(281,tuple([]))

    return _ret


  @functools.native_method
  def set_cull_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'

    self.py__cull_mask = mask






    self._ptr.call_with_return(282,tuple([mask]))

  @functools.native_method
  def get_cull_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def set_environment(self, env:'py4godot_environment.Environment'   ) -> None:
    r''''''

    assert(not env is None)
    assert isinstance(env, get_class('Environment')), 'env must be Environment'

    self.py__environment = env






    self._ptr.call_with_return(284,tuple([env._ptr]))

  @functools.native_method
  def get_environment(self) -> typing.Union['py4godot_environment.Environment']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Environment
    _ret._ptr = self._ptr.call_with_return(285,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_attributes(self, env:'py4godot_cameraattributes.CameraAttributes'   ) -> None:
    r''''''

    assert(not env is None)
    assert isinstance(env, get_class('CameraAttributes')), 'env must be CameraAttributes'

    self.py__attributes = env






    self._ptr.call_with_return(286,tuple([env._ptr]))

  @functools.native_method
  def get_attributes(self) -> typing.Union['py4godot_cameraattributesphysical.CameraAttributesPhysical','py4godot_cameraattributes.CameraAttributes','py4godot_cameraattributespractical.CameraAttributesPractical']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: CameraAttributes
    _ret._ptr = self._ptr.call_with_return(287,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_compositor(self, compositor:'py4godot_compositor.Compositor'   ) -> None:
    r''''''

    assert(not compositor is None)
    assert isinstance(compositor, get_class('Compositor')), 'compositor must be Compositor'

    self.py__compositor = compositor






    self._ptr.call_with_return(288,tuple([compositor._ptr]))

  @functools.native_method
  def get_compositor(self) -> typing.Union['py4godot_compositor.Compositor']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Compositor
    _ret._ptr = self._ptr.call_with_return(289,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_keep_aspect_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__keep_aspect = mode






    self._ptr.call_with_return(290,tuple([mode]))

  @functools.native_method
  def get_keep_aspect_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_doppler_tracking(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__doppler_tracking = mode






    self._ptr.call_with_return(292,tuple([mode]))

  @functools.native_method
  def get_doppler_tracking(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def get_frustum(self) -> typing.Union['py4godot_planetypedarray.PlaneTypedArray']:
    r'''
				Returns the camera's frustum planes in world space units as an array of `Plane`s in the following order: near, far, left, top, right, bottom. Not to be confused with `frustum_offset`.
			'''




    _ret = py4godot_planetypedarray.PlaneTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(294,tuple([]))
    return _ret


  @functools.native_method
  def is_position_in_frustum(self, world_point:'Vector3'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given position is inside the camera's frustum (the green part of the linked diagram). `url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/camera3d_position_frustum.png`See this diagram`/url` for an overview of position query methods.
			'''

    assert(not world_point is None)
    assert isinstance(world_point, Vector3), 'world_point must be Vector3'






    _ret = 0
    _ret = self._ptr.call_with_return(295,tuple([world_point._ptr]))
    return _ret


  @functools.native_method
  def get_camera_rid(self) -> typing.Union['RID']:
    r'''
				Returns the camera's RID from the `RenderingServer`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(296,tuple([]))
    return _ret


  @functools.native_method
  def get_pyramid_shape_rid(self) -> typing.Union['RID']:
    r'''
				Returns the RID of a pyramid shape encompassing the camera's view frustum, ignoring the camera's near plane. The tip of the pyramid represents the position of the camera.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(297,tuple([]))
    return _ret


  @functools.native_method
  def set_cull_mask_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `cull_mask`, given a `layer_number` between 1 and 20.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'







    self._ptr.call_with_return(298,tuple([layer_number, value]))

  @functools.native_method
  def get_cull_mask_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `cull_mask` is enabled, given a `layer_number` between 1 and 20.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([layer_number]))
    return _ret



register_cast_function('Camera3D', Camera3D.cast)
register_class('Camera3D', Camera3D)
