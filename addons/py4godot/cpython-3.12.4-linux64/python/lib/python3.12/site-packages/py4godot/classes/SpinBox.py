# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.LineEdit as py4godot_lineedit 
import py4godot.classes.Range as py4godot_range 
from py4godot.wrappers.wrappers import CPPSpinBoxWrapper


class SpinBox(py4godot_range.Range):
  r'''
		`SpinBox` is a numerical input text field. It allows entering integers and floating-point numbers. The `SpinBox` also has up and down buttons that can be clicked increase or decrease the value. The value can also be changed by dragging the mouse up or down over the `SpinBox`'s arrows.
		Additionally, mathematical expressions can be entered. These are evaluated when the user presses `kbd`Enter`/kbd` while editing the `SpinBox`'s text field. This uses the `Expression` class to parse and evaluate the expression. The result of the expression is then set as the value of the `SpinBox`. Some examples of valid expressions are `5 + 2 * 3`, `pow(2, 4)`, and `PI + sin(0.5)`. Expressions are case-sensitive.
		**Example:** Create a `SpinBox`, disable its context menu and set its text alignment to right.
		
		```gdscript
		var spin_box = SpinBox.new()
		add_child(spin_box)
		var line_edit = spin_box.get_line_edit()
		line_edit.context_menu_enabled = false
		spin_box.horizontal_alignment = LineEdit.HORIZONTAL_ALIGNMENT_RIGHT
		```
		
		
		See `Range` class for more options over the `SpinBox`.
		**Note:** With the `SpinBox`'s context menu disabled, you can right-click the bottom half of the spinbox to set the value to its minimum, while right-clicking the top half sets the value to its maximum.
		**Note:** `SpinBox` relies on an underlying `LineEdit` node. To theme a `SpinBox`'s background, add theme items for `LineEdit` and customize them. The `LineEdit` has the `SpinBoxInnerLineEdit` theme variation, so that you can give it a distinct appearance from regular `LineEdit`s.
		**Note:** If you want to implement drag and drop for the underlying `LineEdit`, you can use `Control.set_drag_forwarding` on the node returned by `get_line_edit`.
	'''

  @staticmethod
  def constructor():
    class_ = SpinBox.construct_without_init()
    class_._ptr = constructor(770,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SpinBox.construct_without_init()
    class_._ptr = constructor(770,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSpinBoxWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(770,0, ())


  def generate_wrapper(self):
    return CPPSpinBoxWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SpinBox.__new__(SpinBox)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SpinBox'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SpinBox.construct_without_init()
    cls._ptr = CPPSpinBoxWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SpinBox.construct_without_init()
    cls._ptr = CPPSpinBoxWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_alignment()
    return _ret
  @alignment.setter
  def alignment(self,  value:'int'):
    self.set_horizontal_alignment(value)
  @property
  def editable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_editable()
    return _ret
  @editable.setter
  def editable(self,  value:'bool'):
    self.set_editable(value)
  @property
  def update_on_text_changed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_update_on_text_changed()
    return _ret
  @update_on_text_changed.setter
  def update_on_text_changed(self,  value:'bool'):
    self.set_update_on_text_changed(value)
  @property
  def prefix(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_prefix()
    return _ret
  @prefix.setter
  def prefix(self,  value:'str'):
    self.set_prefix(value)
  @property
  def suffix(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_suffix()
    return _ret
  @suffix.setter
  def suffix(self,  value:'str'):
    self.set_suffix(value)
  @property
  def custom_arrow_step(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_custom_arrow_step()
    return _ret
  @custom_arrow_step.setter
  def custom_arrow_step(self,  value:'float'):
    self.set_custom_arrow_step(value)
  @property
  def select_all_on_focus(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_select_all_on_focus()
    return _ret
  @select_all_on_focus.setter
  def select_all_on_focus(self,  value:'bool'):
    self.set_select_all_on_focus(value)
  @functools.native_method
  def set_horizontal_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'

    self.py__alignment = alignment






    self._ptr.call_with_return(457,tuple([alignment]))

  @functools.native_method
  def get_horizontal_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(458,tuple([]))

    return _ret


  @functools.native_method
  def set_suffix(self, suffix:'str'   ) -> None:
    r''''''

    assert(not suffix is None)
    assert isinstance(suffix, (str, String)), 'suffix must be str or String'

    self.py__suffix = suffix



    assert(isinstance(suffix, (str, String)))
    py_string_suffix = suffix if isinstance(suffix, StringName) else c_utils.py_string_to_string(suffix)

    py__string_suffix = utils.py_string_to_string(suffix)
    py__string_suffix.shouldBeDeleted = False


    self._ptr.call_with_return(459,tuple([py__string_suffix._ptr]))

  @functools.native_method
  def get_suffix(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(460,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_prefix(self, prefix:'str'   ) -> None:
    r''''''

    assert(not prefix is None)
    assert isinstance(prefix, (str, String)), 'prefix must be str or String'

    self.py__prefix = prefix



    assert(isinstance(prefix, (str, String)))
    py_string_prefix = prefix if isinstance(prefix, StringName) else c_utils.py_string_to_string(prefix)

    py__string_prefix = utils.py_string_to_string(prefix)
    py__string_prefix.shouldBeDeleted = False


    self._ptr.call_with_return(461,tuple([py__string_prefix._ptr]))

  @functools.native_method
  def get_prefix(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(462,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_editable(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__editable = enabled






    self._ptr.call_with_return(463,tuple([enabled]))

  @functools.native_method
  def set_custom_arrow_step(self, arrow_step:'float'   ) -> None:
    r''''''

    assert isinstance(arrow_step, (int, float)), 'arrow_step must be int or float'

    self.py__custom_arrow_step = arrow_step






    self._ptr.call_with_return(464,tuple([arrow_step]))

  @functools.native_method
  def get_custom_arrow_step(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(465,tuple([]))

    return _ret


  @functools.native_method
  def is_editable(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(466,tuple([]))

    return _ret


  @functools.native_method
  def set_update_on_text_changed(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__update_on_text_changed = enabled






    self._ptr.call_with_return(467,tuple([enabled]))

  @functools.native_method
  def get_update_on_text_changed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(468,tuple([]))

    return _ret


  @functools.native_method
  def set_select_all_on_focus(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__select_all_on_focus = enabled






    self._ptr.call_with_return(469,tuple([enabled]))

  @functools.native_method
  def is_select_all_on_focus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(470,tuple([]))

    return _ret


  @functools.native_method
  def apply(self) -> None:
    r'''
				Applies the current value of this `SpinBox`. This is equivalent to pressing `kbd`Enter`/kbd` while editing the `LineEdit` used by the `SpinBox`. This will cause `signal LineEdit.text_submitted` to be emitted and its currently contained expression to be evaluated.
			'''




    self._ptr.call_with_return(471,tuple([]))

  @functools.native_method
  def get_line_edit(self) -> typing.Union['py4godot_lineedit.LineEdit']:
    r'''
				Returns the `LineEdit` instance from this `SpinBox`. You can use it to access properties and methods of `LineEdit`.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: LineEdit
    _ret._ptr = self._ptr.call_with_return(472,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('SpinBox', SpinBox.cast)
register_class('SpinBox', SpinBox)
