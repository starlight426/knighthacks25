# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.StringTypedArray as py4godot_stringtypedarray 
  import py4godot.classes.intTypedArray as py4godot_inttypedarray 
  import py4godot.classes.Resource as py4godot_resource 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.StringTypedArray as py4godot_stringtypedarray 
import py4godot.classes.intTypedArray as py4godot_inttypedarray 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.TextEdit as py4godot_textedit 
from py4godot.wrappers.wrappers import CPPCodeEditWrapper

class CodeCompletionKind:
  KIND_CLASS = 0
  KIND_FUNCTION = 1
  KIND_SIGNAL = 2
  KIND_VARIABLE = 3
  KIND_MEMBER = 4
  KIND_ENUM = 5
  KIND_CONSTANT = 6
  KIND_NODE_PATH = 7
  KIND_FILE_PATH = 8
  KIND_PLAIN_TEXT = 9
class CodeCompletionLocation:
  LOCATION_LOCAL = 0
  LOCATION_PARENT_MASK = 256
  LOCATION_OTHER_USER_CODE = 512
  LOCATION_OTHER = 1024


class CodeEdit(py4godot_textedit.TextEdit):
  r'''
		CodeEdit is a specialized `TextEdit` designed for editing plain text code files. It has many features commonly found in code editors such as line numbers, line folding, code completion, indent management, and string/comment management.
		**Note:** Regardless of locale, `CodeEdit` will by default always use left-to-right text direction to correctly display source code.
	'''

  @staticmethod
  def constructor():
    class_ = CodeEdit.construct_without_init()
    class_._ptr = constructor(213,0, ())
    return class_
  @staticmethod
  def new():
    class_ = CodeEdit.construct_without_init()
    class_._ptr = constructor(213,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCodeEditWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(213,0, ())


  def generate_wrapper(self):
    return CPPCodeEditWrapper()
  def init_signals(self):
    super().init_signals()
    breakpoint_toggled_name = utils.py_string_to_string_name("breakpoint_toggled")
    self.breakpoint_toggled = signals.BuiltinSignal(self, breakpoint_toggled_name)
    code_completion_requested_name = utils.py_string_to_string_name("code_completion_requested")
    self.code_completion_requested = signals.BuiltinSignal(self, code_completion_requested_name)
    symbol_lookup_name = utils.py_string_to_string_name("symbol_lookup")
    self.symbol_lookup = signals.BuiltinSignal(self, symbol_lookup_name)
    symbol_validate_name = utils.py_string_to_string_name("symbol_validate")
    self.symbol_validate = signals.BuiltinSignal(self, symbol_validate_name)
    symbol_hovered_name = utils.py_string_to_string_name("symbol_hovered")
    self.symbol_hovered = signals.BuiltinSignal(self, symbol_hovered_name)

  @staticmethod
  def construct_without_init():
    cls = CodeEdit.__new__(CodeEdit)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'CodeEdit'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = CodeEdit.construct_without_init()
    cls._ptr = CPPCodeEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = CodeEdit.construct_without_init()
    cls._ptr = CPPCodeEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def symbol_lookup_on_click(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_symbol_lookup_on_click_enabled()
    return _ret
  @symbol_lookup_on_click.setter
  def symbol_lookup_on_click(self,  value:'bool'):
    self.set_symbol_lookup_on_click_enabled(value)
  @property
  def symbol_tooltip_on_hover(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_symbol_tooltip_on_hover_enabled()
    return _ret
  @symbol_tooltip_on_hover.setter
  def symbol_tooltip_on_hover(self,  value:'bool'):
    self.set_symbol_tooltip_on_hover_enabled(value)
  @property
  def line_folding(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_line_folding_enabled()
    return _ret
  @line_folding.setter
  def line_folding(self,  value:'bool'):
    self.set_line_folding_enabled(value)
  @property
  def line_length_guidelines(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. get_line_length_guidelines()
    return _ret
  @line_length_guidelines.setter
  def line_length_guidelines(self,  value:'PackedInt32Array'):
    self.set_line_length_guidelines(value)
  @property
  def gutters_draw_breakpoints_gutter(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_breakpoints_gutter()
    return _ret
  @gutters_draw_breakpoints_gutter.setter
  def gutters_draw_breakpoints_gutter(self,  value:'bool'):
    self.set_draw_breakpoints_gutter(value)
  @property
  def gutters_draw_bookmarks(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_bookmarks_gutter()
    return _ret
  @gutters_draw_bookmarks.setter
  def gutters_draw_bookmarks(self,  value:'bool'):
    self.set_draw_bookmarks_gutter(value)
  @property
  def gutters_draw_executing_lines(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_executing_lines_gutter()
    return _ret
  @gutters_draw_executing_lines.setter
  def gutters_draw_executing_lines(self,  value:'bool'):
    self.set_draw_executing_lines_gutter(value)
  @property
  def gutters_draw_line_numbers(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_draw_line_numbers_enabled()
    return _ret
  @gutters_draw_line_numbers.setter
  def gutters_draw_line_numbers(self,  value:'bool'):
    self.set_draw_line_numbers(value)
  @property
  def gutters_zero_pad_line_numbers(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_line_numbers_zero_padded()
    return _ret
  @gutters_zero_pad_line_numbers.setter
  def gutters_zero_pad_line_numbers(self,  value:'bool'):
    self.set_line_numbers_zero_padded(value)
  @property
  def gutters_draw_fold_gutter(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_fold_gutter()
    return _ret
  @gutters_draw_fold_gutter.setter
  def gutters_draw_fold_gutter(self,  value:'bool'):
    self.set_draw_fold_gutter(value)
  @property
  def delimiter_strings(self) -> typing.Union['PackedStringArray']:
    r''''''
    _ret = self. get_string_delimiters()
    return _ret
  @delimiter_strings.setter
  def delimiter_strings(self,  value:'PackedStringArray'):
    self.set_string_delimiters(value)
  @property
  def delimiter_comments(self) -> typing.Union['PackedStringArray']:
    r''''''
    _ret = self. get_comment_delimiters()
    return _ret
  @delimiter_comments.setter
  def delimiter_comments(self,  value:'PackedStringArray'):
    self.set_comment_delimiters(value)
  @property
  def code_completion_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_code_completion_enabled()
    return _ret
  @code_completion_enabled.setter
  def code_completion_enabled(self,  value:'bool'):
    self.set_code_completion_enabled(value)
  @property
  def code_completion_prefixes(self) -> typing.Union['PackedStringArray']:
    r''''''
    _ret = self. get_code_completion_prefixes()
    return _ret
  @code_completion_prefixes.setter
  def code_completion_prefixes(self,  value:'PackedStringArray'):
    self.set_code_completion_prefixes(value)
  @property
  def indent_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_indent_size()
    return _ret
  @indent_size.setter
  def indent_size(self,  value:'int'):
    self.set_indent_size(value)
  @property
  def indent_use_spaces(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_indent_using_spaces()
    return _ret
  @indent_use_spaces.setter
  def indent_use_spaces(self,  value:'bool'):
    self.set_indent_using_spaces(value)
  @property
  def indent_automatic(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_auto_indent_enabled()
    return _ret
  @indent_automatic.setter
  def indent_automatic(self,  value:'bool'):
    self.set_auto_indent_enabled(value)
  @property
  def indent_automatic_prefixes(self) -> typing.Union['PackedStringArray']:
    r''''''
    _ret = self. get_auto_indent_prefixes()
    return _ret
  @indent_automatic_prefixes.setter
  def indent_automatic_prefixes(self,  value:'PackedStringArray'):
    self.set_auto_indent_prefixes(value)
  @property
  def auto_brace_completion_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_auto_brace_completion_enabled()
    return _ret
  @auto_brace_completion_enabled.setter
  def auto_brace_completion_enabled(self,  value:'bool'):
    self.set_auto_brace_completion_enabled(value)
  @property
  def auto_brace_completion_highlight_matching(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_highlight_matching_braces_enabled()
    return _ret
  @auto_brace_completion_highlight_matching.setter
  def auto_brace_completion_highlight_matching(self,  value:'bool'):
    self.set_highlight_matching_braces_enabled(value)
  @property
  def auto_brace_completion_pairs(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_auto_brace_completion_pairs()
    return _ret
  @auto_brace_completion_pairs.setter
  def auto_brace_completion_pairs(self,  value:'Dictionary'):
    self.set_auto_brace_completion_pairs(value)
  @functools.native_method
  def _confirm_code_completion(self, replace:'bool'   ) -> None:
    r'''
				Override this method to define how the selected entry should be inserted. If `replace` is `true`, any existing text should be replaced.
			'''

    assert isinstance(replace, bool), 'replace must be bool'






    self._ptr.call_with_return(687,tuple([replace]))

  @functools.native_method
  def _request_code_completion(self, force:'bool'   ) -> None:
    r'''
				Override this method to define what happens when the user requests code completion. If `force` is `true`, any checks should be bypassed.
			'''

    assert isinstance(force, bool), 'force must be bool'






    self._ptr.call_with_return(688,tuple([force]))

  @functools.native_method
  def _filter_code_completion_candidates(self, candidates:'py4godot_dictionarytypedarray.DictionaryTypedArray'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Override this method to define what items in `candidates` should be displayed.
				Both `candidates` and the return is an `Array` of `Dictionary`, see `get_code_completion_option` for `Dictionary` content.
			'''

    assert isinstance(candidates, get_class('DictionaryTypedArray')), 'candidates must be DictionaryTypedArray'






    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(689,tuple([candidates._ptr]))
    return _ret


  @functools.native_method
  def set_indent_size(self, size:'int'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'

    self.py__indent_size = size






    self._ptr.call_with_return(690,tuple([size]))

  @functools.native_method
  def get_indent_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(691,tuple([]))

    return _ret


  @functools.native_method
  def set_indent_using_spaces(self, use_spaces:'bool'   ) -> None:
    r''''''

    assert isinstance(use_spaces, bool), 'use_spaces must be bool'

    self.py__indent_use_spaces = use_spaces






    self._ptr.call_with_return(692,tuple([use_spaces]))

  @functools.native_method
  def is_indent_using_spaces(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(693,tuple([]))

    return _ret


  @functools.native_method
  def set_auto_indent_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__indent_automatic = enable






    self._ptr.call_with_return(694,tuple([enable]))

  @functools.native_method
  def is_auto_indent_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(695,tuple([]))

    return _ret


  @functools.native_method
  def set_auto_indent_prefixes(self, prefixes:'py4godot_stringtypedarray.StringTypedArray'   ) -> None:
    r''''''

    assert isinstance(prefixes, get_class('StringTypedArray')), 'prefixes must be StringTypedArray'

    self.py__indent_automatic_prefixes = prefixes






    self._ptr.call_with_return(696,tuple([prefixes._ptr]))

  @functools.native_method
  def get_auto_indent_prefixes(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r''''''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(697,tuple([]))

    return _ret


  @functools.native_method
  def do_indent(self) -> None:
    r'''
				If there is no selection, indentation is inserted at the caret. Otherwise, the selected lines are indented like `indent_lines`. Equivalent to the `ProjectSettings.input/ui_text_indent` action. The indentation characters used depend on `indent_use_spaces` and `indent_size`.
			'''




    self._ptr.call_with_return(698,tuple([]))

  @functools.native_method
  def indent_lines(self) -> None:
    r'''
				Indents all lines that are selected or have a caret on them. Uses spaces or a tab depending on `indent_use_spaces`. See `unindent_lines`.
			'''




    self._ptr.call_with_return(699,tuple([]))

  @functools.native_method
  def unindent_lines(self) -> None:
    r'''
				Unindents all lines that are selected or have a caret on them. Uses spaces or a tab depending on `indent_use_spaces`. Equivalent to the `ProjectSettings.input/ui_text_dedent` action. See `indent_lines`.
			'''




    self._ptr.call_with_return(700,tuple([]))

  @functools.native_method
  def convert_indent(self, from_line:'int' =-1  , to_line:'int' =-1  ) -> None:
    r'''
				Converts the indents of lines between `from_line` and `to_line` to tabs or spaces as set by `indent_use_spaces`.
				Values of `-1` convert the entire text.
			'''

    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(to_line, (int, float)), 'to_line must be int or float'







    self._ptr.call_with_return(701,tuple([from_line, to_line]))

  @functools.native_method
  def set_auto_brace_completion_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__auto_brace_completion_enabled = enable






    self._ptr.call_with_return(702,tuple([enable]))

  @functools.native_method
  def is_auto_brace_completion_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(703,tuple([]))

    return _ret


  @functools.native_method
  def set_highlight_matching_braces_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__auto_brace_completion_highlight_matching = enable






    self._ptr.call_with_return(704,tuple([enable]))

  @functools.native_method
  def is_highlight_matching_braces_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(705,tuple([]))

    return _ret


  @functools.native_method
  def add_auto_brace_completion_pair(self, start_key:'str'   , end_key:'str'   ) -> None:
    r'''
				Adds a brace pair.
				Both the start and end keys must be symbols. Only the start key has to be unique.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'
    assert(not end_key is None)
    assert isinstance(end_key, (str, String)), 'end_key must be str or String'




    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)
    assert(isinstance(end_key, (str, String)))
    py_string_end_key = end_key if isinstance(end_key, StringName) else c_utils.py_string_to_string(end_key)

    self._ptr.call_with_return(706,tuple([py_string_start_key._ptr, py_string_end_key._ptr]))

  @functools.native_method
  def set_auto_brace_completion_pairs(self, pairs:'Dictionary'   ) -> None:
    r''''''

    assert(not pairs is None)
    assert isinstance(pairs, Dictionary), 'pairs must be Dictionary'

    self.py__auto_brace_completion_pairs = pairs






    self._ptr.call_with_return(707,tuple([pairs._ptr]))

  @functools.native_method
  def get_auto_brace_completion_pairs(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(708,tuple([]))

    return _ret


  @functools.native_method
  def has_auto_brace_completion_open_key(self, open_key:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if open key `open_key` exists.
			'''

    assert(not open_key is None)
    assert isinstance(open_key, (str, String)), 'open_key must be str or String'




    assert(isinstance(open_key, (str, String)))
    py_string_open_key = open_key if isinstance(open_key, StringName) else c_utils.py_string_to_string(open_key)

    _ret = 0
    _ret = self._ptr.call_with_return(709,tuple([py_string_open_key._ptr]))
    return _ret


  @functools.native_method
  def has_auto_brace_completion_close_key(self, close_key:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if close key `close_key` exists.
			'''

    assert(not close_key is None)
    assert isinstance(close_key, (str, String)), 'close_key must be str or String'




    assert(isinstance(close_key, (str, String)))
    py_string_close_key = close_key if isinstance(close_key, StringName) else c_utils.py_string_to_string(close_key)

    _ret = 0
    _ret = self._ptr.call_with_return(710,tuple([py_string_close_key._ptr]))
    return _ret


  @functools.native_method
  def get_auto_brace_completion_close_key(self, open_key:'str'   ) -> typing.Union[str]:
    r'''
				Gets the matching auto brace close key for `open_key`.
			'''

    assert(not open_key is None)
    assert isinstance(open_key, (str, String)), 'open_key must be str or String'




    assert(isinstance(open_key, (str, String)))
    py_string_open_key = open_key if isinstance(open_key, StringName) else c_utils.py_string_to_string(open_key)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(711,tuple([py_string_open_key._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_draw_breakpoints_gutter(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gutters_draw_breakpoints_gutter = enable






    self._ptr.call_with_return(712,tuple([enable]))

  @functools.native_method
  def is_drawing_breakpoints_gutter(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(713,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_bookmarks_gutter(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gutters_draw_bookmarks = enable






    self._ptr.call_with_return(714,tuple([enable]))

  @functools.native_method
  def is_drawing_bookmarks_gutter(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(715,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_executing_lines_gutter(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gutters_draw_executing_lines = enable






    self._ptr.call_with_return(716,tuple([enable]))

  @functools.native_method
  def is_drawing_executing_lines_gutter(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(717,tuple([]))

    return _ret


  @functools.native_method
  def set_line_as_breakpoint(self, line:'int'   , breakpointed:'bool'   ) -> None:
    r'''
				Sets the given line as a breakpoint. If `true` and `gutters_draw_breakpoints_gutter` is `true`, draws the `theme_item breakpoint` icon in the gutter for this line. See `get_breakpointed_lines` and `is_line_breakpointed`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(breakpointed, bool), 'breakpointed must be bool'







    self._ptr.call_with_return(718,tuple([line, breakpointed]))

  @functools.native_method
  def is_line_breakpointed(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given line is breakpointed. See `set_line_as_breakpoint`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(719,tuple([line]))
    return _ret


  @functools.native_method
  def clear_breakpointed_lines(self) -> None:
    r'''
				Clears all breakpointed lines.
			'''




    self._ptr.call_with_return(720,tuple([]))

  @functools.native_method
  def get_breakpointed_lines(self) -> typing.Union['PackedInt32Array']:
    r'''
				Gets all breakpointed lines.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(721,tuple([]))
    return _ret


  @functools.native_method
  def set_line_as_bookmarked(self, line:'int'   , bookmarked:'bool'   ) -> None:
    r'''
				Sets the given line as bookmarked. If `true` and `gutters_draw_bookmarks` is `true`, draws the `theme_item bookmark` icon in the gutter for this line. See `get_bookmarked_lines` and `is_line_bookmarked`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(bookmarked, bool), 'bookmarked must be bool'







    self._ptr.call_with_return(722,tuple([line, bookmarked]))

  @functools.native_method
  def is_line_bookmarked(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given line is bookmarked. See `set_line_as_bookmarked`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(723,tuple([line]))
    return _ret


  @functools.native_method
  def clear_bookmarked_lines(self) -> None:
    r'''
				Clears all bookmarked lines.
			'''




    self._ptr.call_with_return(724,tuple([]))

  @functools.native_method
  def get_bookmarked_lines(self) -> typing.Union['PackedInt32Array']:
    r'''
				Gets all bookmarked lines.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(725,tuple([]))
    return _ret


  @functools.native_method
  def set_line_as_executing(self, line:'int'   , executing:'bool'   ) -> None:
    r'''
				Sets the given line as executing. If `true` and `gutters_draw_executing_lines` is `true`, draws the `theme_item executing_line` icon in the gutter for this line. See `get_executing_lines` and `is_line_executing`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(executing, bool), 'executing must be bool'







    self._ptr.call_with_return(726,tuple([line, executing]))

  @functools.native_method
  def is_line_executing(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given line is marked as executing. See `set_line_as_executing`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(727,tuple([line]))
    return _ret


  @functools.native_method
  def clear_executing_lines(self) -> None:
    r'''
				Clears all executed lines.
			'''




    self._ptr.call_with_return(728,tuple([]))

  @functools.native_method
  def get_executing_lines(self) -> typing.Union['PackedInt32Array']:
    r'''
				Gets all executing lines.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(729,tuple([]))
    return _ret


  @functools.native_method
  def set_draw_line_numbers(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gutters_draw_line_numbers = enable






    self._ptr.call_with_return(730,tuple([enable]))

  @functools.native_method
  def is_draw_line_numbers_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(731,tuple([]))

    return _ret


  @functools.native_method
  def set_line_numbers_zero_padded(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gutters_zero_pad_line_numbers = enable






    self._ptr.call_with_return(732,tuple([enable]))

  @functools.native_method
  def is_line_numbers_zero_padded(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(733,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_fold_gutter(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gutters_draw_fold_gutter = enable






    self._ptr.call_with_return(734,tuple([enable]))

  @functools.native_method
  def is_drawing_fold_gutter(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(735,tuple([]))

    return _ret


  @functools.native_method
  def set_line_folding_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__line_folding = enabled






    self._ptr.call_with_return(736,tuple([enabled]))

  @functools.native_method
  def is_line_folding_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(737,tuple([]))

    return _ret


  @functools.native_method
  def can_fold_line(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given line is foldable. A line is foldable if it is the start of a valid code region (see `get_code_region_start_tag`), if it is the start of a comment or string block, or if the next non-empty line is more indented (see `TextEdit.get_indent_level`).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(738,tuple([line]))
    return _ret


  @functools.native_method
  def fold_line(self, line:'int'   ) -> None:
    r'''
				Folds the given line, if possible (see `can_fold_line`).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    self._ptr.call_with_return(739,tuple([line]))

  @functools.native_method
  def unfold_line(self, line:'int'   ) -> None:
    r'''
				Unfolds the given line if it is folded or if it is hidden under a folded line.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    self._ptr.call_with_return(740,tuple([line]))

  @functools.native_method
  def fold_all_lines(self) -> None:
    r'''
				Folds all lines that are possible to be folded (see `can_fold_line`).
			'''




    self._ptr.call_with_return(741,tuple([]))

  @functools.native_method
  def unfold_all_lines(self) -> None:
    r'''
				Unfolds all lines that are folded.
			'''




    self._ptr.call_with_return(742,tuple([]))

  @functools.native_method
  def toggle_foldable_line(self, line:'int'   ) -> None:
    r'''
				Toggle the folding of the code block at the given line.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    self._ptr.call_with_return(743,tuple([line]))

  @functools.native_method
  def toggle_foldable_lines_at_carets(self) -> None:
    r'''
				Toggle the folding of the code block on all lines with a caret on them.
			'''




    self._ptr.call_with_return(744,tuple([]))

  @functools.native_method
  def is_line_folded(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given line is folded. See `fold_line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(745,tuple([line]))
    return _ret


  @functools.native_method
  def get_folded_lines(self) -> typing.Union['py4godot_inttypedarray.intTypedArray']:
    r'''
				Returns all lines that are currently folded.
			'''




    _ret = py4godot_inttypedarray.intTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(746,tuple([]))
    return _ret


  @functools.native_method
  def create_code_region(self) -> None:
    r'''
				Creates a new code region with the selection. At least one single line comment delimiter have to be defined (see `add_comment_delimiter`).
				A code region is a part of code that is highlighted when folded and can help organize your script.
				Code region start and end tags can be customized (see `set_code_region_tags`).
				Code regions are delimited using start and end tags (respectively `region` and `endregion` by default) preceded by one line comment delimiter. (eg. `#region` and `#endregion`)
			'''




    self._ptr.call_with_return(747,tuple([]))

  @functools.native_method
  def get_code_region_start_tag(self) -> typing.Union[str]:
    r'''
				Returns the code region start tag (without comment delimiter).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(748,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_code_region_end_tag(self) -> typing.Union[str]:
    r'''
				Returns the code region end tag (without comment delimiter).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(749,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_code_region_tags(self, start:'str' ="region"  , end:'str' ="endregion"  ) -> None:
    r'''
				Sets the code region start and end tags (without comment delimiter).
			'''
    if start is None:
      start = String.new0()
    if end is None:
      end = String.new0()
    if start is None:
      start = String.new0()
    if end is None:
      end = String.new0()





    assert(isinstance(start, (str, String)))
    py_string_start = start if isinstance(start, StringName) else c_utils.py_string_to_string(start)
    assert(isinstance(end, (str, String)))
    py_string_end = end if isinstance(end, StringName) else c_utils.py_string_to_string(end)

    self._ptr.call_with_return(750,tuple([py_string_start._ptr, py_string_end._ptr]))

  @functools.native_method
  def is_line_code_region_start(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given line is a code region start. See `set_code_region_tags`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(751,tuple([line]))
    return _ret


  @functools.native_method
  def is_line_code_region_end(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given line is a code region end. See `set_code_region_tags`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(752,tuple([line]))
    return _ret


  @functools.native_method
  def add_string_delimiter(self, start_key:'str'   , end_key:'str'   , line_only:'bool' =False  ) -> None:
    r'''
				Defines a string delimiter from `start_key` to `end_key`. Both keys should be symbols, and `start_key` must not be shared with other delimiters.
				If `line_only` is `true` or `end_key` is an empty `String`, the region does not carry over to the next line.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'
    assert(not end_key is None)
    assert isinstance(end_key, (str, String)), 'end_key must be str or String'
    assert isinstance(line_only, bool), 'line_only must be bool'




    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)
    assert(isinstance(end_key, (str, String)))
    py_string_end_key = end_key if isinstance(end_key, StringName) else c_utils.py_string_to_string(end_key)


    self._ptr.call_with_return(753,tuple([py_string_start_key._ptr, py_string_end_key._ptr, line_only]))

  @functools.native_method
  def remove_string_delimiter(self, start_key:'str'   ) -> None:
    r'''
				Removes the string delimiter with `start_key`.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'




    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)

    self._ptr.call_with_return(754,tuple([py_string_start_key._ptr]))

  @functools.native_method
  def has_string_delimiter(self, start_key:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if string `start_key` exists.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'




    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)

    _ret = 0
    _ret = self._ptr.call_with_return(755,tuple([py_string_start_key._ptr]))
    return _ret


  @functools.native_method
  def set_string_delimiters(self, string_delimiters:'py4godot_stringtypedarray.StringTypedArray'   ) -> None:
    r''''''

    assert isinstance(string_delimiters, get_class('StringTypedArray')), 'string_delimiters must be StringTypedArray'

    self.py__delimiter_strings = string_delimiters






    self._ptr.call_with_return(756,tuple([string_delimiters._ptr]))

  @functools.native_method
  def clear_string_delimiters(self) -> None:
    r'''
				Removes all string delimiters.
			'''




    self._ptr.call_with_return(757,tuple([]))

  @functools.native_method
  def get_string_delimiters(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r''''''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(758,tuple([]))

    return _ret


  @functools.native_method
  def is_in_string(self, line:'int'   , column:'int' =-1  ) -> typing.Union[int]:
    r'''
				Returns the delimiter index if `line` `column` is in a string. If `column` is not provided, will return the delimiter index if the entire `line` is a string. Otherwise `-1`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(759,tuple([line, column]))
    return _ret


  @functools.native_method
  def add_comment_delimiter(self, start_key:'str'   , end_key:'str'   , line_only:'bool' =False  ) -> None:
    r'''
				Adds a comment delimiter from `start_key` to `end_key`. Both keys should be symbols, and `start_key` must not be shared with other delimiters.
				If `line_only` is `true` or `end_key` is an empty `String`, the region does not carry over to the next line.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'
    assert(not end_key is None)
    assert isinstance(end_key, (str, String)), 'end_key must be str or String'
    assert isinstance(line_only, bool), 'line_only must be bool'




    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)
    assert(isinstance(end_key, (str, String)))
    py_string_end_key = end_key if isinstance(end_key, StringName) else c_utils.py_string_to_string(end_key)


    self._ptr.call_with_return(760,tuple([py_string_start_key._ptr, py_string_end_key._ptr, line_only]))

  @functools.native_method
  def remove_comment_delimiter(self, start_key:'str'   ) -> None:
    r'''
				Removes the comment delimiter with `start_key`.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'




    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)

    self._ptr.call_with_return(761,tuple([py_string_start_key._ptr]))

  @functools.native_method
  def has_comment_delimiter(self, start_key:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if comment `start_key` exists.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'




    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)

    _ret = 0
    _ret = self._ptr.call_with_return(762,tuple([py_string_start_key._ptr]))
    return _ret


  @functools.native_method
  def set_comment_delimiters(self, comment_delimiters:'py4godot_stringtypedarray.StringTypedArray'   ) -> None:
    r''''''

    assert isinstance(comment_delimiters, get_class('StringTypedArray')), 'comment_delimiters must be StringTypedArray'

    self.py__delimiter_comments = comment_delimiters






    self._ptr.call_with_return(763,tuple([comment_delimiters._ptr]))

  @functools.native_method
  def clear_comment_delimiters(self) -> None:
    r'''
				Removes all comment delimiters.
			'''




    self._ptr.call_with_return(764,tuple([]))

  @functools.native_method
  def get_comment_delimiters(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r''''''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(765,tuple([]))

    return _ret


  @functools.native_method
  def is_in_comment(self, line:'int'   , column:'int' =-1  ) -> typing.Union[int]:
    r'''
				Returns delimiter index if `line` `column` is in a comment. If `column` is not provided, will return delimiter index if the entire `line` is a comment. Otherwise `-1`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(766,tuple([line, column]))
    return _ret


  @functools.native_method
  def get_delimiter_start_key(self, delimiter_index:'int'   ) -> typing.Union[str]:
    r'''
				Gets the start key for a string or comment region index.
			'''

    assert isinstance(delimiter_index, (int, float)), 'delimiter_index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(767,tuple([delimiter_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_delimiter_end_key(self, delimiter_index:'int'   ) -> typing.Union[str]:
    r'''
				Gets the end key for a string or comment region index.
			'''

    assert isinstance(delimiter_index, (int, float)), 'delimiter_index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(768,tuple([delimiter_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_delimiter_start_position(self, line:'int'   , column:'int'   ) -> typing.Union['Vector2']:
    r'''
				If `line` `column` is in a string or comment, returns the start position of the region. If not or no start could be found, both `Vector2` values will be `-1`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(769,tuple([line, column]))
    return _ret


  @functools.native_method
  def get_delimiter_end_position(self, line:'int'   , column:'int'   ) -> typing.Union['Vector2']:
    r'''
				If `line` `column` is in a string or comment, returns the end position of the region. If not or no end could be found, both `Vector2` values will be `-1`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(770,tuple([line, column]))
    return _ret


  @functools.native_method
  def set_code_hint(self, code_hint:'str'   ) -> None:
    r'''
				Sets the code hint text. Pass an empty string to clear.
			'''

    assert(not code_hint is None)
    assert isinstance(code_hint, (str, String)), 'code_hint must be str or String'




    assert(isinstance(code_hint, (str, String)))
    py_string_code_hint = code_hint if isinstance(code_hint, StringName) else c_utils.py_string_to_string(code_hint)

    self._ptr.call_with_return(771,tuple([py_string_code_hint._ptr]))

  @functools.native_method
  def set_code_hint_draw_below(self, draw_below:'bool'   ) -> None:
    r'''
				If `true`, the code hint will draw below the main caret. If `false`, the code hint will draw above the main caret. See `set_code_hint`.
			'''

    assert isinstance(draw_below, bool), 'draw_below must be bool'






    self._ptr.call_with_return(772,tuple([draw_below]))

  @functools.native_method
  def get_text_for_code_completion(self) -> typing.Union[str]:
    r'''
				Returns the full text with char `0xFFFF` at the caret location.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(773,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def request_code_completion(self, force:'bool' =False  ) -> None:
    r'''
				Emits `signal code_completion_requested`, if `force` is `true` will bypass all checks. Otherwise will check that the caret is in a word or in front of a prefix. Will ignore the request if all current options are of type file path, node path, or signal.
			'''

    assert isinstance(force, bool), 'force must be bool'






    self._ptr.call_with_return(774,tuple([force]))

  @functools.native_method
  def add_code_completion_option(self, type:'int'  , display_text:'str'   , insert_text:'str'   , text_color:'Color' = None  , icon:'py4godot_resource.Resource' = None  , value:'object' =None  , location:'int' =1024  ) -> None:
    r'''
				Submits an item to the queue of potential candidates for the autocomplete menu. Call `update_code_completion_options` to update the list.
				`location` indicates location of the option relative to the location of the code completion query. See `enum CodeEdit.CodeCompletionLocation` for how to set this value.
				**Note:** This list will replace all current candidates.
			'''
    if text_color is None:
      text_color = Color.new0()
    if icon is None:
      icon = c_utils.empty_object

    if text_color is None:
      text_color = Color.new0()
    if icon is None:
      icon = c_utils.empty_object


    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not display_text is None)
    assert isinstance(display_text, (str, String)), 'display_text must be str or String'
    assert(not insert_text is None)
    assert isinstance(insert_text, (str, String)), 'insert_text must be str or String'
    
    assert isinstance(location, (int, float)), 'location must be int or float'





    assert(isinstance(display_text, (str, String)))
    py_string_display_text = display_text if isinstance(display_text, StringName) else c_utils.py_string_to_string(display_text)
    assert(isinstance(insert_text, (str, String)))
    py_string_insert_text = insert_text if isinstance(insert_text, StringName) else c_utils.py_string_to_string(insert_text)





    self._ptr.call_with_return(775,tuple([type, py_string_display_text._ptr, py_string_insert_text._ptr, text_color._ptr, icon._ptr, value, location]))

  @functools.native_method
  def update_code_completion_options(self, force:'bool'   ) -> None:
    r'''
				Submits all completion options added with `add_code_completion_option`. Will try to force the autocomplete menu to popup, if `force` is `true`.
				**Note:** This will replace all current candidates.
			'''

    assert isinstance(force, bool), 'force must be bool'






    self._ptr.call_with_return(776,tuple([force]))

  @functools.native_method
  def get_code_completion_options(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Gets all completion options, see `get_code_completion_option` for return content.
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(777,tuple([]))
    return _ret


  @functools.native_method
  def get_code_completion_option(self, index:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Gets the completion option at `index`. The return `Dictionary` has the following key-values:
				`kind`: `enum CodeCompletionKind`
				`display_text`: Text that is shown on the autocomplete menu.
				`insert_text`: Text that is to be inserted when this item is selected.
				`font_color`: Color of the text on the autocomplete menu.
				`icon`: Icon to draw on the autocomplete menu.
				`default_value`: Value of the symbol.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(778,tuple([index]))
    return _ret


  @functools.native_method
  def get_code_completion_selected_index(self) -> typing.Union[int]:
    r'''
				Gets the index of the current selected completion option.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(779,tuple([]))
    return _ret


  @functools.native_method
  def set_code_completion_selected_index(self, index:'int'   ) -> None:
    r'''
				Sets the current selected completion option.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(780,tuple([index]))

  @functools.native_method
  def confirm_code_completion(self, replace:'bool' =False  ) -> None:
    r'''
				Inserts the selected entry into the text. If `replace` is `true`, any existing text is replaced rather than merged.
			'''

    assert isinstance(replace, bool), 'replace must be bool'






    self._ptr.call_with_return(781,tuple([replace]))

  @functools.native_method
  def cancel_code_completion(self) -> None:
    r'''
				Cancels the autocomplete menu.
			'''




    self._ptr.call_with_return(782,tuple([]))

  @functools.native_method
  def set_code_completion_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__code_completion_enabled = enable






    self._ptr.call_with_return(783,tuple([enable]))

  @functools.native_method
  def is_code_completion_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(784,tuple([]))

    return _ret


  @functools.native_method
  def set_code_completion_prefixes(self, prefixes:'py4godot_stringtypedarray.StringTypedArray'   ) -> None:
    r''''''

    assert isinstance(prefixes, get_class('StringTypedArray')), 'prefixes must be StringTypedArray'

    self.py__code_completion_prefixes = prefixes






    self._ptr.call_with_return(785,tuple([prefixes._ptr]))

  @functools.native_method
  def get_code_completion_prefixes(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r''''''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(786,tuple([]))

    return _ret


  @functools.native_method
  def set_line_length_guidelines(self, guideline_columns:'py4godot_inttypedarray.intTypedArray'   ) -> None:
    r''''''

    assert isinstance(guideline_columns, get_class('intTypedArray')), 'guideline_columns must be intTypedArray'

    self.py__line_length_guidelines = guideline_columns






    self._ptr.call_with_return(787,tuple([guideline_columns._ptr]))

  @functools.native_method
  def get_line_length_guidelines(self) -> typing.Union['py4godot_inttypedarray.intTypedArray']:
    r''''''




    _ret = py4godot_inttypedarray.intTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(788,tuple([]))

    return _ret


  @functools.native_method
  def set_symbol_lookup_on_click_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__symbol_lookup_on_click = enable






    self._ptr.call_with_return(789,tuple([enable]))

  @functools.native_method
  def is_symbol_lookup_on_click_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(790,tuple([]))

    return _ret


  @functools.native_method
  def get_text_for_symbol_lookup(self) -> typing.Union[str]:
    r'''
				Returns the full text with char `0xFFFF` at the cursor location.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(791,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_text_with_cursor_char(self, line:'int'   , column:'int'   ) -> typing.Union[str]:
    r'''
				Returns the full text with char `0xFFFF` at the specified location.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(792,tuple([line, column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_symbol_lookup_word_as_valid(self, valid:'bool'   ) -> None:
    r'''
				Sets the symbol emitted by `signal symbol_validate` as a valid lookup.
			'''

    assert isinstance(valid, bool), 'valid must be bool'






    self._ptr.call_with_return(793,tuple([valid]))

  @functools.native_method
  def set_symbol_tooltip_on_hover_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__symbol_tooltip_on_hover = enable






    self._ptr.call_with_return(794,tuple([enable]))

  @functools.native_method
  def is_symbol_tooltip_on_hover_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(795,tuple([]))

    return _ret


  @functools.native_method
  def move_lines_up(self) -> None:
    r'''
				Moves all lines up that are selected or have a caret on them.
			'''




    self._ptr.call_with_return(796,tuple([]))

  @functools.native_method
  def move_lines_down(self) -> None:
    r'''
				Moves all lines down that are selected or have a caret on them.
			'''




    self._ptr.call_with_return(797,tuple([]))

  @functools.native_method
  def delete_lines(self) -> None:
    r'''
				Deletes all lines that are selected or have a caret on them.
			'''




    self._ptr.call_with_return(798,tuple([]))

  @functools.native_method
  def duplicate_selection(self) -> None:
    r'''
				Duplicates all selected text and duplicates all lines with a caret on them.
			'''




    self._ptr.call_with_return(799,tuple([]))

  @functools.native_method
  def duplicate_lines(self) -> None:
    r'''
				Duplicates all lines currently selected with any caret. Duplicates the entire line beneath the current one no matter where the caret is within the line.
			'''




    self._ptr.call_with_return(800,tuple([]))


register_cast_function('CodeEdit', CodeEdit.cast)
register_class('CodeEdit', CodeEdit)
