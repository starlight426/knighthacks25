# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInterface as py4godot_openxrinterface 
  import py4godot.classes.XRInterface as py4godot_xrinterface 
  import py4godot.classes.XRControllerTracker as py4godot_xrcontrollertracker 
  import py4godot.classes.XRPositionalTracker as py4godot_xrpositionaltracker 
  import py4godot.classes.XRHandTracker as py4godot_xrhandtracker 
  import py4godot.classes.XRBodyTracker as py4godot_xrbodytracker 
  import py4godot.classes.WebXRInterface as py4godot_webxrinterface 
  import py4godot.classes.XRFaceTracker as py4godot_xrfacetracker 
  import py4godot.classes.XRInterfaceExtension as py4godot_xrinterfaceextension 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.MobileVRInterface as py4godot_mobilevrinterface 
  import py4godot.classes.XRTracker as py4godot_xrtracker 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
from py4godot.wrappers.wrappers import CPPXRServerWrapper

_XRServer_singleton_instance = None
class TrackerType:
  TRACKER_HEAD = 1
  TRACKER_CONTROLLER = 2
  TRACKER_BASESTATION = 4
  TRACKER_ANCHOR = 8
  TRACKER_HAND = 16
  TRACKER_BODY = 32
  TRACKER_FACE = 64
  TRACKER_ANY_KNOWN = 127
  TRACKER_UNKNOWN = 128
  TRACKER_ANY = 255
class RotationMode:
  RESET_FULL_ROTATION = 0
  RESET_BUT_KEEP_TILT = 1
  DONT_RESET_ROTATION = 2


class XRServer(py4godot_object.Object):
  r'''
		The AR/VR server is the heart of our Advanced and Virtual Reality solution and handles all the processing.
	'''


  def generate_wrapper(self):
    return CPPXRServerWrapper()
  def init_signals(self):
    super().init_signals()
    reference_frame_changed_name = utils.py_string_to_string_name("reference_frame_changed")
    self.reference_frame_changed = signals.BuiltinSignal(self, reference_frame_changed_name)
    interface_added_name = utils.py_string_to_string_name("interface_added")
    self.interface_added = signals.BuiltinSignal(self, interface_added_name)
    interface_removed_name = utils.py_string_to_string_name("interface_removed")
    self.interface_removed = signals.BuiltinSignal(self, interface_removed_name)
    tracker_added_name = utils.py_string_to_string_name("tracker_added")
    self.tracker_added = signals.BuiltinSignal(self, tracker_added_name)
    tracker_updated_name = utils.py_string_to_string_name("tracker_updated")
    self.tracker_updated = signals.BuiltinSignal(self, tracker_updated_name)
    tracker_removed_name = utils.py_string_to_string_name("tracker_removed")
    self.tracker_removed = signals.BuiltinSignal(self, tracker_removed_name)

  @staticmethod
  def construct_without_init():
    cls = XRServer.__new__(XRServer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'XRServer'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRServer.construct_without_init()
    cls._ptr = CPPXRServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRServer.construct_without_init()
    cls._ptr = CPPXRServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _XRServer_singleton_instance
    if _XRServer_singleton_instance is None:
      singleton = XRServer()
      singleton._ptr = constructor(1027,0, ())
      _XRServer_singleton_instance = singleton
    return _XRServer_singleton_instance

  @property
  def world_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_world_scale()
    return _ret
  @world_scale.setter
  def world_scale(self,  value:'float'):
    self.set_world_scale(value)
  @property
  def world_origin(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_world_origin()
    return _ret
  @world_origin.setter
  def world_origin(self,  value:'Vector3'):
    self.set_world_origin(value)
  @property
  def camera_locked_to_origin(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_camera_locked_to_origin()
    return _ret
  @camera_locked_to_origin.setter
  def camera_locked_to_origin(self,  value:'bool'):
    self.set_camera_locked_to_origin(value)
  @property
  def primary_interface(self) -> typing.Any:
    r''''''
    _ret = self. get_primary_interface()
    return _ret
  @primary_interface.setter
  def primary_interface(self,  value:'py4godot_object.Object'):
    self.set_primary_interface(value)
  @functools.native_method
  def get_world_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([]))

    return _ret


  @functools.native_method
  def set_world_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'

    self.py__world_scale = scale






    self._ptr.call_with_return(50,tuple([scale]))

  @functools.native_method
  def get_world_origin(self) -> typing.Union['Transform3D']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([]))

    return _ret


  @functools.native_method
  def set_world_origin(self, world_origin:'Transform3D'   ) -> None:
    r''''''

    assert(not world_origin is None)
    assert isinstance(world_origin, Transform3D), 'world_origin must be Transform3D'

    self.py__world_origin = world_origin






    self._ptr.call_with_return(52,tuple([world_origin._ptr]))

  @functools.native_method
  def get_reference_frame(self) -> typing.Union['Transform3D']:
    r'''
				Returns the reference frame transform. Mostly used internally and exposed for GDExtension build interfaces.
			'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def clear_reference_frame(self) -> None:
    r'''
				Clears the reference frame that was set by previous calls to `center_on_hmd`.
			'''




    self._ptr.call_with_return(54,tuple([]))

  @functools.native_method
  def center_on_hmd(self, rotation_mode:'int'  , keep_height:'bool'   ) -> None:
    r'''
				This is an important function to understand correctly. AR and VR platforms all handle positioning slightly differently.
				For platforms that do not offer spatial tracking, our origin point `(0, 0, 0)` is the location of our HMD, but you have little control over the direction the player is facing in the real world.
				For platforms that do offer spatial tracking, our origin point depends very much on the system. For OpenVR, our origin point is usually the center of the tracking space, on the ground. For other platforms, it's often the location of the tracking camera.
				This method allows you to center your tracker on the location of the HMD. It will take the current location of the HMD and use that to adjust all your tracking data; in essence, realigning the real world to your player's current position in the game world.
				For this method to produce usable results, tracking information must be available. This often takes a few frames after starting your game.
				You should call this method after a few seconds have passed. For example, when the user requests a realignment of the display holding a designated button on a controller for a short period of time, or when implementing a teleport mechanism.
			'''

    assert isinstance(rotation_mode, (int, float)), 'rotation_mode must be int or float'
    assert isinstance(keep_height, bool), 'keep_height must be bool'







    self._ptr.call_with_return(55,tuple([rotation_mode, keep_height]))

  @functools.native_method
  def get_hmd_transform(self) -> typing.Union['Transform3D']:
    r'''
				Returns the primary interface's transformation.
			'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def set_camera_locked_to_origin(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__camera_locked_to_origin = enabled






    self._ptr.call_with_return(57,tuple([enabled]))

  @functools.native_method
  def is_camera_locked_to_origin(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([]))

    return _ret


  @functools.native_method
  def add_interface(self, interface:'py4godot_xrinterface.XRInterface'   ) -> None:
    r'''
				Registers an `XRInterface` object.
			'''

    assert(not interface is None)
    assert isinstance(interface, get_class('XRInterface')), 'interface must be XRInterface'






    self._ptr.call_with_return(59,tuple([interface._ptr]))

  @functools.native_method
  def get_interface_count(self) -> typing.Union[int]:
    r'''
				Returns the number of interfaces currently registered with the AR/VR server. If your project supports multiple AR/VR platforms, you can look through the available interface, and either present the user with a selection or simply try to initialize each interface and use the first one that returns `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([]))
    return _ret


  @functools.native_method
  def remove_interface(self, interface:'py4godot_xrinterface.XRInterface'   ) -> None:
    r'''
				Removes this `interface`.
			'''

    assert(not interface is None)
    assert isinstance(interface, get_class('XRInterface')), 'interface must be XRInterface'






    self._ptr.call_with_return(61,tuple([interface._ptr]))

  @functools.native_method
  def get_interface_(self, idx:'int'   ) -> typing.Any:
    r'''
				Returns the interface registered at the given `idx` index in the list of interfaces.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: XRInterface
    _ret._ptr = self._ptr.call_with_return(62,tuple([idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_interfaces(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns a list of available interfaces the ID and name of each interface.
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([]))
    return _ret


  @functools.native_method
  def find_interface(self, name:'str'   ) -> typing.Any:
    r'''
				Finds an interface by its `name`. For example, if your project uses capabilities of an AR/VR platform, you can find the interface for that platform by name and initialize it.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: XRInterface
    _ret._ptr = self._ptr.call_with_return(64,tuple([py_string_name._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def add_tracker(self, tracker:'py4godot_xrtracker.XRTracker'   ) -> None:
    r'''
				Registers a new `XRTracker` that tracks a physical object.
			'''

    assert(not tracker is None)
    assert isinstance(tracker, get_class('XRTracker')), 'tracker must be XRTracker'






    self._ptr.call_with_return(65,tuple([tracker._ptr]))

  @functools.native_method
  def remove_tracker(self, tracker:'py4godot_xrtracker.XRTracker'   ) -> None:
    r'''
				Removes this `tracker`.
			'''

    assert(not tracker is None)
    assert isinstance(tracker, get_class('XRTracker')), 'tracker must be XRTracker'






    self._ptr.call_with_return(66,tuple([tracker._ptr]))

  @functools.native_method
  def get_trackers(self, tracker_types:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Returns a dictionary of trackers for `tracker_types`.
			'''

    assert isinstance(tracker_types, (int, float)), 'tracker_types must be int or float'






    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([tracker_types]))
    return _ret


  @functools.native_method
  def get_tracker(self, tracker_name:'object'   ) -> typing.Any:
    r'''
				Returns the positional tracker with the given `tracker_name`.
			'''

    assert(not tracker_name is None)
    assert isinstance(tracker_name, (str, StringName)), 'tracker_name must be str or StringName'




    assert(isinstance(tracker_name, (str, StringName)))
    py_stringname_tracker_name = tracker_name if isinstance(tracker_name, StringName) else c_utils.py_string_to_string_name(tracker_name)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: XRTracker
    _ret._ptr = self._ptr.call_with_return(68,tuple([py_stringname_tracker_name._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_primary_interface(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: XRInterface
    _ret._ptr = self._ptr.call_with_return(69,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_primary_interface(self, interface:'py4godot_xrinterface.XRInterface'   ) -> None:
    r''''''

    assert(not interface is None)
    assert isinstance(interface, get_class('XRInterface')), 'interface must be XRInterface'

    self.py__primary_interface = interface






    self._ptr.call_with_return(70,tuple([interface._ptr]))


register_cast_function('XRServer', XRServer.cast)
register_class('XRServer', XRServer)
