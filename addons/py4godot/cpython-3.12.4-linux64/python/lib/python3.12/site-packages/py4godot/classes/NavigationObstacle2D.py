# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Node2D as py4godot_node2d 
from py4godot.wrappers.wrappers import CPPNavigationObstacle2DWrapper


class NavigationObstacle2D(py4godot_node2d.Node2D):
  r'''
		An obstacle needs a navigation map and outline `vertices` defined to work correctly. The outlines can not cross or overlap.
		Obstacles can be included in the navigation mesh baking process when `affect_navigation_mesh` is enabled. They do not add walkable geometry, instead their role is to discard other source geometry inside the shape. This can be used to prevent navigation mesh from appearing in unwanted places. If `carve_navigation_mesh` is enabled the baked shape will not be affected by offsets of the navigation mesh baking, e.g. the agent radius.
		With `avoidance_enabled` the obstacle can constrain the avoidance velocities of avoidance using agents. If the obstacle's vertices are wound in clockwise order, avoidance agents will be pushed in by the obstacle, otherwise, avoidance agents will be pushed out. Obstacles using vertices and avoidance can warp to a new position but should not be moved every single frame as each change requires a rebuild of the avoidance map.
	'''

  @staticmethod
  def constructor():
    class_ = NavigationObstacle2D.construct_without_init()
    class_._ptr = constructor(502,0, ())
    return class_
  @staticmethod
  def new():
    class_ = NavigationObstacle2D.construct_without_init()
    class_._ptr = constructor(502,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNavigationObstacle2DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(502,0, ())


  def generate_wrapper(self):
    return CPPNavigationObstacle2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = NavigationObstacle2D.__new__(NavigationObstacle2D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NavigationObstacle2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationObstacle2D.construct_without_init()
    cls._ptr = CPPNavigationObstacle2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationObstacle2D.construct_without_init()
    cls._ptr = CPPNavigationObstacle2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_radius()
    return _ret
  @radius.setter
  def radius(self,  value:'float'):
    self.set_radius(value)
  @property
  def vertices(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_vertices()
    return _ret
  @vertices.setter
  def vertices(self,  value:'PackedVector2Array'):
    self.set_vertices(value)
  @property
  def affect_navigation_mesh(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_affect_navigation_mesh()
    return _ret
  @affect_navigation_mesh.setter
  def affect_navigation_mesh(self,  value:'bool'):
    self.set_affect_navigation_mesh(value)
  @property
  def carve_navigation_mesh(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_carve_navigation_mesh()
    return _ret
  @carve_navigation_mesh.setter
  def carve_navigation_mesh(self,  value:'bool'):
    self.set_carve_navigation_mesh(value)
  @property
  def avoidance_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_avoidance_enabled()
    return _ret
  @avoidance_enabled.setter
  def avoidance_enabled(self,  value:'bool'):
    self.set_avoidance_enabled(value)
  @property
  def velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_velocity()
    return _ret
  @velocity.setter
  def velocity(self,  value:'Vector2'):
    self.set_velocity(value)
  @property
  def avoidance_layers(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_avoidance_layers()
    return _ret
  @avoidance_layers.setter
  def avoidance_layers(self,  value:'int'):
    self.set_avoidance_layers(value)
  @functools.native_method
  def get_rid(self) -> typing.Union['RID']:
    r'''
				Returns the `RID` of this obstacle on the `NavigationServer2D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(303,tuple([]))
    return _ret


  @functools.native_method
  def set_avoidance_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__avoidance_enabled = enabled






    self._ptr.call_with_return(304,tuple([enabled]))

  @functools.native_method
  def get_avoidance_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_map(self, navigation_map:'RID'   ) -> None:
    r'''
				Sets the `RID` of the navigation map this NavigationObstacle node should use and also updates the `obstacle` on the NavigationServer.
			'''

    assert(not navigation_map is None)
    assert isinstance(navigation_map, RID), 'navigation_map must be RID'






    self._ptr.call_with_return(306,tuple([navigation_map._ptr]))

  @functools.native_method
  def get_navigation_map(self) -> typing.Union['RID']:
    r'''
				Returns the `RID` of the navigation map for this NavigationObstacle node. This function returns always the map set on the NavigationObstacle node and not the map of the abstract obstacle on the NavigationServer. If the obstacle map is changed directly with the NavigationServer API the NavigationObstacle node will not be aware of the map change. Use `set_navigation_map` to change the navigation map for the NavigationObstacle and also update the obstacle on the NavigationServer.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(307,tuple([]))
    return _ret


  @functools.native_method
  def set_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'

    self.py__radius = radius






    self._ptr.call_with_return(308,tuple([radius]))

  @functools.native_method
  def get_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(309,tuple([]))

    return _ret


  @functools.native_method
  def set_velocity(self, velocity:'Vector2'   ) -> None:
    r''''''

    assert(not velocity is None)
    assert isinstance(velocity, Vector2), 'velocity must be Vector2'

    self.py__velocity = velocity






    self._ptr.call_with_return(310,tuple([velocity._ptr]))

  @functools.native_method
  def get_velocity(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def set_vertices(self, vertices:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not vertices is None)
    assert isinstance(vertices, PackedVector2Array), 'vertices must be PackedVector2Array'

    self.py__vertices = vertices






    self._ptr.call_with_return(312,tuple([vertices._ptr]))

  @functools.native_method
  def get_vertices(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def set_avoidance_layers(self, layers:'int'   ) -> None:
    r''''''

    assert isinstance(layers, (int, float)), 'layers must be int or float'

    self.py__avoidance_layers = layers






    self._ptr.call_with_return(314,tuple([layers]))

  @functools.native_method
  def get_avoidance_layers(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([]))

    return _ret


  @functools.native_method
  def set_avoidance_layer_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `avoidance_layers` bitmask, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'







    self._ptr.call_with_return(316,tuple([layer_number, value]))

  @functools.native_method
  def get_avoidance_layer_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `avoidance_layers` bitmask is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(317,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_affect_navigation_mesh(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__affect_navigation_mesh = enabled






    self._ptr.call_with_return(318,tuple([enabled]))

  @functools.native_method
  def get_affect_navigation_mesh(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def set_carve_navigation_mesh(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__carve_navigation_mesh = enabled






    self._ptr.call_with_return(320,tuple([enabled]))

  @functools.native_method
  def get_carve_navigation_mesh(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret



register_cast_function('NavigationObstacle2D', NavigationObstacle2D.cast)
register_class('NavigationObstacle2D', NavigationObstacle2D)
