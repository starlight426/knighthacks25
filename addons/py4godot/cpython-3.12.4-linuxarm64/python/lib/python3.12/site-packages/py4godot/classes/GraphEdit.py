# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.Object as py4godot_object 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPGraphEditWrapper

class PanningScheme:
  SCROLL_ZOOMS = 0
  SCROLL_PANS = 1
class GridPattern:
  GRID_PATTERN_LINES = 0
  GRID_PATTERN_DOTS = 1


class GraphEdit(py4godot_control.Control):
  r'''
		`GraphEdit` provides tools for creation, manipulation, and display of various graphs. Its main purpose in the engine is to power the visual programming systems, such as visual shaders, but it is also available for use in user projects.
		`GraphEdit` by itself is only an empty container, representing an infinite grid where `GraphNode`s can be placed. Each `GraphNode` represents a node in the graph, a single unit of data in the connected scheme. `GraphEdit`, in turn, helps to control various interactions with nodes and between nodes. When the user attempts to connect, disconnect, or delete a `GraphNode`, a signal is emitted in the `GraphEdit`, but no action is taken by default. It is the responsibility of the programmer utilizing this control to implement the necessary logic to determine how each request should be handled.
		**Performance:** It is greatly advised to enable low-processor usage mode (see `OS.low_processor_usage_mode`) when using GraphEdits.
		**Note:** Keep in mind that `Node.get_children` will also return the connection layer node named `_connection_layer` due to technical limitations. This behavior may change in future releases.
	'''

  @staticmethod
  def constructor():
    class_ = GraphEdit.construct_without_init()
    class_._ptr = constructor(382,0, ())
    return class_
  @staticmethod
  def new():
    class_ = GraphEdit.construct_without_init()
    class_._ptr = constructor(382,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGraphEditWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(382,0, ())


  def generate_wrapper(self):
    return CPPGraphEditWrapper()
  def init_signals(self):
    super().init_signals()
    connection_request_name = utils.py_string_to_string_name("connection_request")
    self.connection_request = signals.BuiltinSignal(self, connection_request_name)
    disconnection_request_name = utils.py_string_to_string_name("disconnection_request")
    self.disconnection_request = signals.BuiltinSignal(self, disconnection_request_name)
    connection_to_empty_name = utils.py_string_to_string_name("connection_to_empty")
    self.connection_to_empty = signals.BuiltinSignal(self, connection_to_empty_name)
    connection_from_empty_name = utils.py_string_to_string_name("connection_from_empty")
    self.connection_from_empty = signals.BuiltinSignal(self, connection_from_empty_name)
    connection_drag_started_name = utils.py_string_to_string_name("connection_drag_started")
    self.connection_drag_started = signals.BuiltinSignal(self, connection_drag_started_name)
    connection_drag_ended_name = utils.py_string_to_string_name("connection_drag_ended")
    self.connection_drag_ended = signals.BuiltinSignal(self, connection_drag_ended_name)
    copy_nodes_request_name = utils.py_string_to_string_name("copy_nodes_request")
    self.copy_nodes_request = signals.BuiltinSignal(self, copy_nodes_request_name)
    cut_nodes_request_name = utils.py_string_to_string_name("cut_nodes_request")
    self.cut_nodes_request = signals.BuiltinSignal(self, cut_nodes_request_name)
    paste_nodes_request_name = utils.py_string_to_string_name("paste_nodes_request")
    self.paste_nodes_request = signals.BuiltinSignal(self, paste_nodes_request_name)
    duplicate_nodes_request_name = utils.py_string_to_string_name("duplicate_nodes_request")
    self.duplicate_nodes_request = signals.BuiltinSignal(self, duplicate_nodes_request_name)
    delete_nodes_request_name = utils.py_string_to_string_name("delete_nodes_request")
    self.delete_nodes_request = signals.BuiltinSignal(self, delete_nodes_request_name)
    node_selected_name = utils.py_string_to_string_name("node_selected")
    self.node_selected = signals.BuiltinSignal(self, node_selected_name)
    node_deselected_name = utils.py_string_to_string_name("node_deselected")
    self.node_deselected = signals.BuiltinSignal(self, node_deselected_name)
    frame_rect_changed_name = utils.py_string_to_string_name("frame_rect_changed")
    self.frame_rect_changed = signals.BuiltinSignal(self, frame_rect_changed_name)
    popup_request_name = utils.py_string_to_string_name("popup_request")
    self.popup_request = signals.BuiltinSignal(self, popup_request_name)
    begin_node_move_name = utils.py_string_to_string_name("begin_node_move")
    self.begin_node_move = signals.BuiltinSignal(self, begin_node_move_name)
    end_node_move_name = utils.py_string_to_string_name("end_node_move")
    self.end_node_move = signals.BuiltinSignal(self, end_node_move_name)
    graph_elements_linked_to_frame_request_name = utils.py_string_to_string_name("graph_elements_linked_to_frame_request")
    self.graph_elements_linked_to_frame_request = signals.BuiltinSignal(self, graph_elements_linked_to_frame_request_name)
    scroll_offset_changed_name = utils.py_string_to_string_name("scroll_offset_changed")
    self.scroll_offset_changed = signals.BuiltinSignal(self, scroll_offset_changed_name)

  @staticmethod
  def construct_without_init():
    cls = GraphEdit.__new__(GraphEdit)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GraphEdit'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = GraphEdit.construct_without_init()
    cls._ptr = CPPGraphEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = GraphEdit.construct_without_init()
    cls._ptr = CPPGraphEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def scroll_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_scroll_offset()
    return _ret
  @scroll_offset.setter
  def scroll_offset(self,  value:'Vector2'):
    self.set_scroll_offset(value)
  @property
  def show_grid(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_grid()
    return _ret
  @show_grid.setter
  def show_grid(self,  value:'bool'):
    self.set_show_grid(value)
  @property
  def grid_pattern(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_grid_pattern()
    return _ret
  @grid_pattern.setter
  def grid_pattern(self,  value:'int'):
    self.set_grid_pattern(value)
  @property
  def snapping_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_snapping_enabled()
    return _ret
  @snapping_enabled.setter
  def snapping_enabled(self,  value:'bool'):
    self.set_snapping_enabled(value)
  @property
  def snapping_distance(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_snapping_distance()
    return _ret
  @snapping_distance.setter
  def snapping_distance(self,  value:'int'):
    self.set_snapping_distance(value)
  @property
  def panning_scheme(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_panning_scheme()
    return _ret
  @panning_scheme.setter
  def panning_scheme(self,  value:'int'):
    self.set_panning_scheme(value)
  @property
  def right_disconnects(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_right_disconnects_enabled()
    return _ret
  @right_disconnects.setter
  def right_disconnects(self,  value:'bool'):
    self.set_right_disconnects(value)
  @property
  def type_names(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_type_names()
    return _ret
  @type_names.setter
  def type_names(self,  value:'Dictionary'):
    self.set_type_names(value)
  @property
  def connection_lines_curvature(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_connection_lines_curvature()
    return _ret
  @connection_lines_curvature.setter
  def connection_lines_curvature(self,  value:'float'):
    self.set_connection_lines_curvature(value)
  @property
  def connection_lines_thickness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_connection_lines_thickness()
    return _ret
  @connection_lines_thickness.setter
  def connection_lines_thickness(self,  value:'float'):
    self.set_connection_lines_thickness(value)
  @property
  def connection_lines_antialiased(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_connection_lines_antialiased()
    return _ret
  @connection_lines_antialiased.setter
  def connection_lines_antialiased(self,  value:'bool'):
    self.set_connection_lines_antialiased(value)
  @property
  def connections(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r''''''
    _ret = self. get_connection_list()
    return _ret
  @connections.setter
  def connections(self, value:'Array'):
    self.set_connections(value)
  @property
  def zoom(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_zoom()
    return _ret
  @zoom.setter
  def zoom(self,  value:'float'):
    self.set_zoom(value)
  @property
  def zoom_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_zoom_min()
    return _ret
  @zoom_min.setter
  def zoom_min(self,  value:'float'):
    self.set_zoom_min(value)
  @property
  def zoom_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_zoom_max()
    return _ret
  @zoom_max.setter
  def zoom_max(self,  value:'float'):
    self.set_zoom_max(value)
  @property
  def zoom_step(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_zoom_step()
    return _ret
  @zoom_step.setter
  def zoom_step(self,  value:'float'):
    self.set_zoom_step(value)
  @property
  def minimap_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_minimap_enabled()
    return _ret
  @minimap_enabled.setter
  def minimap_enabled(self,  value:'bool'):
    self.set_minimap_enabled(value)
  @property
  def minimap_size(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_minimap_size()
    return _ret
  @minimap_size.setter
  def minimap_size(self,  value:'Vector2'):
    self.set_minimap_size(value)
  @property
  def minimap_opacity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_minimap_opacity()
    return _ret
  @minimap_opacity.setter
  def minimap_opacity(self,  value:'float'):
    self.set_minimap_opacity(value)
  @property
  def show_menu(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_menu()
    return _ret
  @show_menu.setter
  def show_menu(self,  value:'bool'):
    self.set_show_menu(value)
  @property
  def show_zoom_label(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_zoom_label()
    return _ret
  @show_zoom_label.setter
  def show_zoom_label(self,  value:'bool'):
    self.set_show_zoom_label(value)
  @property
  def show_zoom_buttons(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_zoom_buttons()
    return _ret
  @show_zoom_buttons.setter
  def show_zoom_buttons(self,  value:'bool'):
    self.set_show_zoom_buttons(value)
  @property
  def show_grid_buttons(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_grid_buttons()
    return _ret
  @show_grid_buttons.setter
  def show_grid_buttons(self,  value:'bool'):
    self.set_show_grid_buttons(value)
  @property
  def show_minimap_button(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_minimap_button()
    return _ret
  @show_minimap_button.setter
  def show_minimap_button(self,  value:'bool'):
    self.set_show_minimap_button(value)
  @property
  def show_arrange_button(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_arrange_button()
    return _ret
  @show_arrange_button.setter
  def show_arrange_button(self,  value:'bool'):
    self.set_show_arrange_button(value)
  @functools.native_method
  def _is_in_input_hotzone(self, in_node:'py4godot_object.Object'   , in_port:'int'   , mouse_position:'Vector2'   ) -> typing.Union[bool]:
    r'''
				Returns whether the `mouse_position` is in the input hot zone.
				By default, a hot zone is a `Rect2` positioned such that its center is at `in_node`.`GraphNode.get_input_port_position`(`in_port`) (For output's case, call `GraphNode.get_output_port_position` instead). The hot zone's width is twice the Theme Property `port_grab_distance_horizontal`, and its height is twice the `port_grab_distance_vertical`.
				Below is a sample code to help get started:
				```gdscript
				func _is_in_input_hotzone(in_node, in_port, mouse_position):
					var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
					var port_pos = in_node.get_position() + in_node.get_input_port_position(in_port) - port_size / 2
					var rect = Rect2(port_pos, port_size)

					return rect.has_point(mouse_position)
				```
			'''

    assert(not in_node is None)
    assert isinstance(in_node, get_class('Object')), 'in_node must be Object'
    assert isinstance(in_port, (int, float)), 'in_port must be int or float'
    assert(not mouse_position is None)
    assert isinstance(mouse_position, Vector2), 'mouse_position must be Vector2'








    _ret = 0
    _ret = self._ptr.call_with_return(433,tuple([in_node._ptr, in_port, mouse_position._ptr]))
    return _ret


  @functools.native_method
  def _is_in_output_hotzone(self, in_node:'py4godot_object.Object'   , in_port:'int'   , mouse_position:'Vector2'   ) -> typing.Union[bool]:
    r'''
				Returns whether the `mouse_position` is in the output hot zone. For more information on hot zones, see `_is_in_input_hotzone`.
				Below is a sample code to help get started:
				```gdscript
				func _is_in_output_hotzone(in_node, in_port, mouse_position):
					var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
					var port_pos = in_node.get_position() + in_node.get_output_port_position(in_port) - port_size / 2
					var rect = Rect2(port_pos, port_size)

					return rect.has_point(mouse_position)
				```
			'''

    assert(not in_node is None)
    assert isinstance(in_node, get_class('Object')), 'in_node must be Object'
    assert isinstance(in_port, (int, float)), 'in_port must be int or float'
    assert(not mouse_position is None)
    assert isinstance(mouse_position, Vector2), 'mouse_position must be Vector2'








    _ret = 0
    _ret = self._ptr.call_with_return(434,tuple([in_node._ptr, in_port, mouse_position._ptr]))
    return _ret


  @functools.native_method
  def _get_connection_line(self, from_position:'Vector2'   , to_position:'Vector2'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Virtual method which can be overridden to customize how connections are drawn.
			'''

    assert(not from_position is None)
    assert isinstance(from_position, Vector2), 'from_position must be Vector2'
    assert(not to_position is None)
    assert isinstance(to_position, Vector2), 'to_position must be Vector2'







    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(435,tuple([from_position._ptr, to_position._ptr]))
    return _ret


  @functools.native_method
  def _is_node_hover_valid(self, from_node:'object'   , from_port:'int'   , to_node:'object'   , to_port:'int'   ) -> typing.Union[bool]:
    r'''
				This virtual method can be used to insert additional error detection while the user is dragging a connection over a valid port.
				Return `true` if the connection is indeed valid or return `false` if the connection is impossible. If the connection is impossible, no snapping to the port and thus no connection request to that port will happen.
				In this example a connection to same node is suppressed:
				
				```gdscript
				func _is_node_hover_valid(from, from_port, to, to_port):
					return from != to
				```
				
				
			'''

    assert(not from_node is None)
    assert isinstance(from_node, (str, StringName)), 'from_node must be str or StringName'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert(not to_node is None)
    assert isinstance(to_node, (str, StringName)), 'to_node must be str or StringName'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'




    assert(isinstance(from_node, (str, StringName)))
    py_stringname_from_node = from_node if isinstance(from_node, StringName) else c_utils.py_string_to_string_name(from_node)

    assert(isinstance(to_node, (str, StringName)))
    py_stringname_to_node = to_node if isinstance(to_node, StringName) else c_utils.py_string_to_string_name(to_node)


    _ret = 0
    _ret = self._ptr.call_with_return(436,tuple([py_stringname_from_node._ptr, from_port, py_stringname_to_node._ptr, to_port]))
    return _ret


  @functools.native_method
  def connect_node(self, from_node:'object'   , from_port:'int'   , to_node:'object'   , to_port:'int'   , keep_alive:'bool' =False  ) -> typing.Union[int]:
    r'''
				Create a connection between the `from_port` of the `from_node` `GraphNode` and the `to_port` of the `to_node` `GraphNode`. If the connection already exists, no connection is created.
				Connections with `keep_alive` set to `false` may be deleted automatically if invalid during a redraw.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, (str, StringName)), 'from_node must be str or StringName'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert(not to_node is None)
    assert isinstance(to_node, (str, StringName)), 'to_node must be str or StringName'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'
    assert isinstance(keep_alive, bool), 'keep_alive must be bool'




    assert(isinstance(from_node, (str, StringName)))
    py_stringname_from_node = from_node if isinstance(from_node, StringName) else c_utils.py_string_to_string_name(from_node)

    assert(isinstance(to_node, (str, StringName)))
    py_stringname_to_node = to_node if isinstance(to_node, StringName) else c_utils.py_string_to_string_name(to_node)



    _ret:int
    _ret = self._ptr.call_with_return(437,tuple([py_stringname_from_node._ptr, from_port, py_stringname_to_node._ptr, to_port, keep_alive]))
    return _ret


  @functools.native_method
  def is_node_connected(self, from_node:'object'   , from_port:'int'   , to_node:'object'   , to_port:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `from_port` of the `from_node` `GraphNode` is connected to the `to_port` of the `to_node` `GraphNode`.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, (str, StringName)), 'from_node must be str or StringName'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert(not to_node is None)
    assert isinstance(to_node, (str, StringName)), 'to_node must be str or StringName'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'




    assert(isinstance(from_node, (str, StringName)))
    py_stringname_from_node = from_node if isinstance(from_node, StringName) else c_utils.py_string_to_string_name(from_node)

    assert(isinstance(to_node, (str, StringName)))
    py_stringname_to_node = to_node if isinstance(to_node, StringName) else c_utils.py_string_to_string_name(to_node)


    _ret = 0
    _ret = self._ptr.call_with_return(438,tuple([py_stringname_from_node._ptr, from_port, py_stringname_to_node._ptr, to_port]))
    return _ret


  @functools.native_method
  def disconnect_node(self, from_node:'object'   , from_port:'int'   , to_node:'object'   , to_port:'int'   ) -> None:
    r'''
				Removes the connection between the `from_port` of the `from_node` `GraphNode` and the `to_port` of the `to_node` `GraphNode`. If the connection does not exist, no connection is removed.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, (str, StringName)), 'from_node must be str or StringName'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert(not to_node is None)
    assert isinstance(to_node, (str, StringName)), 'to_node must be str or StringName'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'




    assert(isinstance(from_node, (str, StringName)))
    py_stringname_from_node = from_node if isinstance(from_node, StringName) else c_utils.py_string_to_string_name(from_node)

    assert(isinstance(to_node, (str, StringName)))
    py_stringname_to_node = to_node if isinstance(to_node, StringName) else c_utils.py_string_to_string_name(to_node)


    self._ptr.call_with_return(439,tuple([py_stringname_from_node._ptr, from_port, py_stringname_to_node._ptr, to_port]))

  @functools.native_method
  def set_connection_activity(self, from_node:'object'   , from_port:'int'   , to_node:'object'   , to_port:'int'   , amount:'float'   ) -> None:
    r'''
				Sets the coloration of the connection between `from_node`'s `from_port` and `to_node`'s `to_port` with the color provided in the `theme_item activity` theme property. The color is linearly interpolated between the connection color and the activity color using `amount` as weight.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, (str, StringName)), 'from_node must be str or StringName'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert(not to_node is None)
    assert isinstance(to_node, (str, StringName)), 'to_node must be str or StringName'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'
    assert isinstance(amount, (int, float)), 'amount must be int or float'




    assert(isinstance(from_node, (str, StringName)))
    py_stringname_from_node = from_node if isinstance(from_node, StringName) else c_utils.py_string_to_string_name(from_node)

    assert(isinstance(to_node, (str, StringName)))
    py_stringname_to_node = to_node if isinstance(to_node, StringName) else c_utils.py_string_to_string_name(to_node)



    self._ptr.call_with_return(440,tuple([py_stringname_from_node._ptr, from_port, py_stringname_to_node._ptr, to_port, amount]))

  @functools.native_method
  def set_connections(self, connections:'py4godot_dictionarytypedarray.DictionaryTypedArray'   ) -> None:
    r''''''

    assert isinstance(connections, get_class('DictionaryTypedArray')), 'connections must be DictionaryTypedArray'

    self.py__connections = connections






    self._ptr.call_with_return(441,tuple([connections._ptr]))

  @functools.native_method
  def get_connection_list(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r''''''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(442,tuple([]))

    return _ret


  @functools.native_method
  def get_connection_count(self, from_node:'object'   , from_port:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of connections from `from_port` of `from_node`.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, (str, StringName)), 'from_node must be str or StringName'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'




    assert(isinstance(from_node, (str, StringName)))
    py_stringname_from_node = from_node if isinstance(from_node, StringName) else c_utils.py_string_to_string_name(from_node)


    _ret = 0
    _ret = self._ptr.call_with_return(443,tuple([py_stringname_from_node._ptr, from_port]))
    return _ret


  @functools.native_method
  def get_closest_connection_at_point(self, point:'Vector2'   , max_distance:'float' =4.0  ) -> typing.Union['Dictionary']:
    r'''
				Returns the closest connection to the given point in screen space. If no connection is found within `max_distance` pixels, an empty `Dictionary` is returned.
				A connection is represented as a `Dictionary` in the form of:
				```gdscript
				{
					from_node: StringName,
					from_port: int,
					to_node: StringName,
					to_port: int,
					keep_alive: bool
				}
				```
				For example, getting a connection at a given mouse position can be achieved like this:
				
				```gdscript
				var connection = get_closest_connection_at_point(mouse_event.get_position())
				```
				
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'
    assert isinstance(max_distance, (int, float)), 'max_distance must be int or float'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(444,tuple([point._ptr, max_distance]))
    return _ret


  @functools.native_method
  def get_connection_list_from_node(self, node:'object'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an `Array` containing a list of all connections for `node`.
				A connection is represented as a `Dictionary` in the form of:
				```gdscript
				{
					from_node: StringName,
					from_port: int,
					to_node: StringName,
					to_port: int,
					keep_alive: bool
				}
				```
				**Example:** Get all connections on a specific port:
				```gdscript
				func get_connection_list_from_port(node, port):
					var connections = get_connection_list_from_node(node)
					var result = ``
					for connection in connections:
						var dict = {}
						if connection`"from_node"` == node and connection`"from_port"` == port:
							dict`"node"` = connection`"to_node"`
							dict`"port"` = connection`"to_port"`
							dict`"type"` = "left"
							result.push_back(dict)
						elif connection`"to_node"` == node and connection`"to_port"` == port:
							dict`"node"` = connection`"from_node"`
							dict`"port"` = connection`"from_port"`
							dict`"type"` = "right"
							result.push_back(dict)
					return result
				```
			'''

    assert(not node is None)
    assert isinstance(node, (str, StringName)), 'node must be str or StringName'




    assert(isinstance(node, (str, StringName)))
    py_stringname_node = node if isinstance(node, StringName) else c_utils.py_string_to_string_name(node)

    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(445,tuple([py_stringname_node._ptr]))
    return _ret


  @functools.native_method
  def get_connections_intersecting_with_rect(self, rect:'Rect2'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an `Array` containing the list of connections that intersect with the given `Rect2`.
				A connection is represented as a `Dictionary` in the form of:
				```gdscript
				{
					from_node: StringName,
					from_port: int,
					to_node: StringName,
					to_port: int,
					keep_alive: bool
				}
				```
			'''

    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'






    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(446,tuple([rect._ptr]))
    return _ret


  @functools.native_method
  def clear_connections(self) -> None:
    r'''
				Removes all connections between nodes.
			'''




    self._ptr.call_with_return(447,tuple([]))

  @functools.native_method
  def force_connection_drag_end(self) -> None:
    r'''
				Ends the creation of the current connection. In other words, if you are dragging a connection you can use this method to abort the process and remove the line that followed your cursor.
				This is best used together with `signal connection_drag_started` and `signal connection_drag_ended` to add custom behavior like node addition through shortcuts.
				**Note:** This method suppresses any other connection request signals apart from `signal connection_drag_ended`.
			'''




    self._ptr.call_with_return(448,tuple([]))

  @functools.native_method
  def get_scroll_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(449,tuple([]))

    return _ret


  @functools.native_method
  def set_scroll_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'

    self.py__scroll_offset = offset






    self._ptr.call_with_return(450,tuple([offset._ptr]))

  @functools.native_method
  def add_valid_right_disconnect_type(self, type:'int'   ) -> None:
    r'''
				Allows to disconnect nodes when dragging from the right port of the `GraphNode`'s slot if it has the specified type. See also `remove_valid_right_disconnect_type`.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    self._ptr.call_with_return(451,tuple([type]))

  @functools.native_method
  def remove_valid_right_disconnect_type(self, type:'int'   ) -> None:
    r'''
				Disallows to disconnect nodes when dragging from the right port of the `GraphNode`'s slot if it has the specified type. Use this to disable disconnection previously allowed with `add_valid_right_disconnect_type`.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    self._ptr.call_with_return(452,tuple([type]))

  @functools.native_method
  def add_valid_left_disconnect_type(self, type:'int'   ) -> None:
    r'''
				Allows to disconnect nodes when dragging from the left port of the `GraphNode`'s slot if it has the specified type. See also `remove_valid_left_disconnect_type`.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    self._ptr.call_with_return(453,tuple([type]))

  @functools.native_method
  def remove_valid_left_disconnect_type(self, type:'int'   ) -> None:
    r'''
				Disallows to disconnect nodes when dragging from the left port of the `GraphNode`'s slot if it has the specified type. Use this to disable disconnection previously allowed with `add_valid_left_disconnect_type`.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    self._ptr.call_with_return(454,tuple([type]))

  @functools.native_method
  def add_valid_connection_type(self, from_type:'int'   , to_type:'int'   ) -> None:
    r'''
				Allows the connection between two different port types. The port type is defined individually for the left and the right port of each slot with the `GraphNode.set_slot` method.
				See also `is_valid_connection_type` and `remove_valid_connection_type`.
			'''

    assert isinstance(from_type, (int, float)), 'from_type must be int or float'
    assert isinstance(to_type, (int, float)), 'to_type must be int or float'







    self._ptr.call_with_return(455,tuple([from_type, to_type]))

  @functools.native_method
  def remove_valid_connection_type(self, from_type:'int'   , to_type:'int'   ) -> None:
    r'''
				Disallows the connection between two different port types previously allowed by `add_valid_connection_type`. The port type is defined individually for the left and the right port of each slot with the `GraphNode.set_slot` method.
				See also `is_valid_connection_type`.
			'''

    assert isinstance(from_type, (int, float)), 'from_type must be int or float'
    assert isinstance(to_type, (int, float)), 'to_type must be int or float'







    self._ptr.call_with_return(456,tuple([from_type, to_type]))

  @functools.native_method
  def is_valid_connection_type(self, from_type:'int'   , to_type:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether it's possible to make a connection between two different port types. The port type is defined individually for the left and the right port of each slot with the `GraphNode.set_slot` method.
				See also `add_valid_connection_type` and `remove_valid_connection_type`.
			'''

    assert isinstance(from_type, (int, float)), 'from_type must be int or float'
    assert isinstance(to_type, (int, float)), 'to_type must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([from_type, to_type]))
    return _ret


  @functools.native_method
  def get_connection_line(self, from_node:'Vector2'   , to_node:'Vector2'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns the points which would make up a connection between `from_node` and `to_node`.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, Vector2), 'from_node must be Vector2'
    assert(not to_node is None)
    assert isinstance(to_node, Vector2), 'to_node must be Vector2'







    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(458,tuple([from_node._ptr, to_node._ptr]))
    return _ret


  @functools.native_method
  def attach_graph_element_to_frame(self, element:'object'   , frame:'object'   ) -> None:
    r'''
				Attaches the `element` `GraphElement` to the `frame` `GraphFrame`.
			'''

    assert(not element is None)
    assert isinstance(element, (str, StringName)), 'element must be str or StringName'
    assert(not frame is None)
    assert isinstance(frame, (str, StringName)), 'frame must be str or StringName'




    assert(isinstance(element, (str, StringName)))
    py_stringname_element = element if isinstance(element, StringName) else c_utils.py_string_to_string_name(element)
    assert(isinstance(frame, (str, StringName)))
    py_stringname_frame = frame if isinstance(frame, StringName) else c_utils.py_string_to_string_name(frame)

    self._ptr.call_with_return(459,tuple([py_stringname_element._ptr, py_stringname_frame._ptr]))

  @functools.native_method
  def detach_graph_element_from_frame(self, element:'object'   ) -> None:
    r'''
				Detaches the `element` `GraphElement` from the `GraphFrame` it is currently attached to.
			'''

    assert(not element is None)
    assert isinstance(element, (str, StringName)), 'element must be str or StringName'




    assert(isinstance(element, (str, StringName)))
    py_stringname_element = element if isinstance(element, StringName) else c_utils.py_string_to_string_name(element)

    self._ptr.call_with_return(460,tuple([py_stringname_element._ptr]))

  @functools.native_method
  def get_element_frame(self, element:'object'   ) -> typing.Union['py4godot_graphframe.GraphFrame']:
    r'''
				Returns the `GraphFrame` that contains the `GraphElement` with the given name.
			'''

    assert(not element is None)
    assert isinstance(element, (str, StringName)), 'element must be str or StringName'




    assert(isinstance(element, (str, StringName)))
    py_stringname_element = element if isinstance(element, StringName) else c_utils.py_string_to_string_name(element)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: GraphFrame
    _ret._ptr = self._ptr.call_with_return(461,tuple([py_stringname_element._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_attached_nodes_of_frame(self, frame:'object'   ) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
				Returns an array of node names that are attached to the `GraphFrame` with the given name.
			'''

    assert(not frame is None)
    assert isinstance(frame, (str, StringName)), 'frame must be str or StringName'




    assert(isinstance(frame, (str, StringName)))
    py_stringname_frame = frame if isinstance(frame, StringName) else c_utils.py_string_to_string_name(frame)

    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(462,tuple([py_stringname_frame._ptr]))
    return _ret


  @functools.native_method
  def set_panning_scheme(self, scheme:'int'  ) -> None:
    r''''''

    assert isinstance(scheme, (int, float)), 'scheme must be int or float'

    self.py__panning_scheme = scheme






    self._ptr.call_with_return(463,tuple([scheme]))

  @functools.native_method
  def get_panning_scheme(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(464,tuple([]))

    return _ret


  @functools.native_method
  def set_zoom(self, zoom:'float'   ) -> None:
    r''''''

    assert isinstance(zoom, (int, float)), 'zoom must be int or float'

    self.py__zoom = zoom






    self._ptr.call_with_return(465,tuple([zoom]))

  @functools.native_method
  def get_zoom(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(466,tuple([]))

    return _ret


  @functools.native_method
  def set_zoom_min(self, zoom_min:'float'   ) -> None:
    r''''''

    assert isinstance(zoom_min, (int, float)), 'zoom_min must be int or float'

    self.py__zoom_min = zoom_min






    self._ptr.call_with_return(467,tuple([zoom_min]))

  @functools.native_method
  def get_zoom_min(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(468,tuple([]))

    return _ret


  @functools.native_method
  def set_zoom_max(self, zoom_max:'float'   ) -> None:
    r''''''

    assert isinstance(zoom_max, (int, float)), 'zoom_max must be int or float'

    self.py__zoom_max = zoom_max






    self._ptr.call_with_return(469,tuple([zoom_max]))

  @functools.native_method
  def get_zoom_max(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(470,tuple([]))

    return _ret


  @functools.native_method
  def set_zoom_step(self, zoom_step:'float'   ) -> None:
    r''''''

    assert isinstance(zoom_step, (int, float)), 'zoom_step must be int or float'

    self.py__zoom_step = zoom_step






    self._ptr.call_with_return(471,tuple([zoom_step]))

  @functools.native_method
  def get_zoom_step(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(472,tuple([]))

    return _ret


  @functools.native_method
  def set_show_grid(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__show_grid = enable






    self._ptr.call_with_return(473,tuple([enable]))

  @functools.native_method
  def is_showing_grid(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(474,tuple([]))

    return _ret


  @functools.native_method
  def set_grid_pattern(self, pattern:'int'  ) -> None:
    r''''''

    assert isinstance(pattern, (int, float)), 'pattern must be int or float'

    self.py__grid_pattern = pattern






    self._ptr.call_with_return(475,tuple([pattern]))

  @functools.native_method
  def get_grid_pattern(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(476,tuple([]))

    return _ret


  @functools.native_method
  def set_snapping_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__snapping_enabled = enable






    self._ptr.call_with_return(477,tuple([enable]))

  @functools.native_method
  def is_snapping_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(478,tuple([]))

    return _ret


  @functools.native_method
  def set_snapping_distance(self, pixels:'int'   ) -> None:
    r''''''

    assert isinstance(pixels, (int, float)), 'pixels must be int or float'

    self.py__snapping_distance = pixels






    self._ptr.call_with_return(479,tuple([pixels]))

  @functools.native_method
  def get_snapping_distance(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(480,tuple([]))

    return _ret


  @functools.native_method
  def set_connection_lines_curvature(self, curvature:'float'   ) -> None:
    r''''''

    assert isinstance(curvature, (int, float)), 'curvature must be int or float'

    self.py__connection_lines_curvature = curvature






    self._ptr.call_with_return(481,tuple([curvature]))

  @functools.native_method
  def get_connection_lines_curvature(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(482,tuple([]))

    return _ret


  @functools.native_method
  def set_connection_lines_thickness(self, pixels:'float'   ) -> None:
    r''''''

    assert isinstance(pixels, (int, float)), 'pixels must be int or float'

    self.py__connection_lines_thickness = pixels






    self._ptr.call_with_return(483,tuple([pixels]))

  @functools.native_method
  def get_connection_lines_thickness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(484,tuple([]))

    return _ret


  @functools.native_method
  def set_connection_lines_antialiased(self, pixels:'bool'   ) -> None:
    r''''''

    assert isinstance(pixels, bool), 'pixels must be bool'

    self.py__connection_lines_antialiased = pixels






    self._ptr.call_with_return(485,tuple([pixels]))

  @functools.native_method
  def is_connection_lines_antialiased(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(486,tuple([]))

    return _ret


  @functools.native_method
  def set_minimap_size(self, size:'Vector2'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'

    self.py__minimap_size = size






    self._ptr.call_with_return(487,tuple([size._ptr]))

  @functools.native_method
  def get_minimap_size(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(488,tuple([]))

    return _ret


  @functools.native_method
  def set_minimap_opacity(self, opacity:'float'   ) -> None:
    r''''''

    assert isinstance(opacity, (int, float)), 'opacity must be int or float'

    self.py__minimap_opacity = opacity






    self._ptr.call_with_return(489,tuple([opacity]))

  @functools.native_method
  def get_minimap_opacity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(490,tuple([]))

    return _ret


  @functools.native_method
  def set_minimap_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__minimap_enabled = enable






    self._ptr.call_with_return(491,tuple([enable]))

  @functools.native_method
  def is_minimap_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(492,tuple([]))

    return _ret


  @functools.native_method
  def set_show_menu(self, hidden:'bool'   ) -> None:
    r''''''

    assert isinstance(hidden, bool), 'hidden must be bool'

    self.py__show_menu = hidden






    self._ptr.call_with_return(493,tuple([hidden]))

  @functools.native_method
  def is_showing_menu(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(494,tuple([]))

    return _ret


  @functools.native_method
  def set_show_zoom_label(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__show_zoom_label = enable






    self._ptr.call_with_return(495,tuple([enable]))

  @functools.native_method
  def is_showing_zoom_label(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(496,tuple([]))

    return _ret


  @functools.native_method
  def set_show_grid_buttons(self, hidden:'bool'   ) -> None:
    r''''''

    assert isinstance(hidden, bool), 'hidden must be bool'

    self.py__show_grid_buttons = hidden






    self._ptr.call_with_return(497,tuple([hidden]))

  @functools.native_method
  def is_showing_grid_buttons(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(498,tuple([]))

    return _ret


  @functools.native_method
  def set_show_zoom_buttons(self, hidden:'bool'   ) -> None:
    r''''''

    assert isinstance(hidden, bool), 'hidden must be bool'

    self.py__show_zoom_buttons = hidden






    self._ptr.call_with_return(499,tuple([hidden]))

  @functools.native_method
  def is_showing_zoom_buttons(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(500,tuple([]))

    return _ret


  @functools.native_method
  def set_show_minimap_button(self, hidden:'bool'   ) -> None:
    r''''''

    assert isinstance(hidden, bool), 'hidden must be bool'

    self.py__show_minimap_button = hidden






    self._ptr.call_with_return(501,tuple([hidden]))

  @functools.native_method
  def is_showing_minimap_button(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(502,tuple([]))

    return _ret


  @functools.native_method
  def set_show_arrange_button(self, hidden:'bool'   ) -> None:
    r''''''

    assert isinstance(hidden, bool), 'hidden must be bool'

    self.py__show_arrange_button = hidden






    self._ptr.call_with_return(503,tuple([hidden]))

  @functools.native_method
  def is_showing_arrange_button(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(504,tuple([]))

    return _ret


  @functools.native_method
  def set_right_disconnects(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__right_disconnects = enable






    self._ptr.call_with_return(505,tuple([enable]))

  @functools.native_method
  def is_right_disconnects_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(506,tuple([]))

    return _ret


  @functools.native_method
  def set_type_names(self, type_names:'Dictionary'   ) -> None:
    r''''''

    assert(not type_names is None)
    assert isinstance(type_names, Dictionary), 'type_names must be Dictionary'

    self.py__type_names = type_names






    self._ptr.call_with_return(507,tuple([type_names._ptr]))

  @functools.native_method
  def get_type_names(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(508,tuple([]))

    return _ret


  @functools.native_method
  def get_menu_hbox(self) -> typing.Any:
    r'''
				Gets the `HBoxContainer` that contains the zooming and grid snap controls in the top left of the graph. You can use this method to reposition the toolbar or to add your own custom controls to it.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: HBoxContainer
    _ret._ptr = self._ptr.call_with_return(509,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def arrange_nodes(self) -> None:
    r'''
				Rearranges selected nodes in a layout with minimum crossings between connections and uniform horizontal and vertical gap between nodes.
			'''




    self._ptr.call_with_return(510,tuple([]))

  @functools.native_method
  def set_selected(self, node:'py4godot_node.Node'   ) -> None:
    r'''
				Sets the specified `node` as the one selected.
			'''

    assert(not node is None)
    assert isinstance(node, get_class('Node')), 'node must be Node'






    self._ptr.call_with_return(511,tuple([node._ptr]))


register_cast_function('GraphEdit', GraphEdit.cast)
register_class('GraphEdit', GraphEdit)
