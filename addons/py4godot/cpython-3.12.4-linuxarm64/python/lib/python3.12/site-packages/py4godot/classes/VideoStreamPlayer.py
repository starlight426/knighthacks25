# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.VideoStream as py4godot_videostream 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.VideoStreamTheora as py4godot_videostreamtheora 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPVideoStreamPlayerWrapper


class VideoStreamPlayer(py4godot_control.Control):
  r'''
		A control used for playback of `VideoStream` resources.
		Supported video formats are `url=https://www.theora.org/`Ogg Theora`/url` (`.ogv`, `VideoStreamTheora`) and any format exposed via a GDExtension plugin.
		**Warning:** On Web, video playback _will_ perform poorly due to missing architecture-specific assembly optimizations.
	'''

  @staticmethod
  def constructor():
    class_ = VideoStreamPlayer.construct_without_init()
    class_._ptr = constructor(870,0, ())
    return class_
  @staticmethod
  def new():
    class_ = VideoStreamPlayer.construct_without_init()
    class_._ptr = constructor(870,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPVideoStreamPlayerWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(870,0, ())


  def generate_wrapper(self):
    return CPPVideoStreamPlayerWrapper()
  def init_signals(self):
    super().init_signals()
    finished_name = utils.py_string_to_string_name("finished")
    self.finished = signals.BuiltinSignal(self, finished_name)

  @staticmethod
  def construct_without_init():
    cls = VideoStreamPlayer.__new__(VideoStreamPlayer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'VideoStreamPlayer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = VideoStreamPlayer.construct_without_init()
    cls._ptr = CPPVideoStreamPlayerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = VideoStreamPlayer.construct_without_init()
    cls._ptr = CPPVideoStreamPlayerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def audio_track(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_audio_track()
    return _ret
  @audio_track.setter
  def audio_track(self,  value:'int'):
    self.set_audio_track(value)
  @property
  def stream(self) -> typing.Union['py4godot_videostream.VideoStream','py4godot_videostreamtheora.VideoStreamTheora']:
    r''''''
    _ret = self. get_stream()
    return _ret
  @stream.setter
  def stream(self,  value:'py4godot_object.Object'):
    self.set_stream(value)
  @property
  def volume_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume_db()
    return _ret
  @volume_db.setter
  def volume_db(self,  value:'float'):
    self.set_volume_db(value)
  @property
  def volume(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume()
    return _ret
  @volume.setter
  def volume(self,  value:'float'):
    self.set_volume(value)
  @property
  def speed_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_speed_scale()
    return _ret
  @speed_scale.setter
  def speed_scale(self,  value:'float'):
    self.set_speed_scale(value)
  @property
  def autoplay(self) -> typing.Union[bool]:
    r''''''
    _ret = self. has_autoplay()
    return _ret
  @autoplay.setter
  def autoplay(self,  value:'bool'):
    self.set_autoplay(value)
  @property
  def paused(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_paused()
    return _ret
  @paused.setter
  def paused(self,  value:'bool'):
    self.set_paused(value)
  @property
  def expand(self) -> typing.Union[bool]:
    r''''''
    _ret = self. has_expand()
    return _ret
  @expand.setter
  def expand(self,  value:'bool'):
    self.set_expand(value)
  @property
  def loop(self) -> typing.Union[bool]:
    r''''''
    _ret = self. has_loop()
    return _ret
  @loop.setter
  def loop(self,  value:'bool'):
    self.set_loop(value)
  @property
  def buffering_msec(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_buffering_msec()
    return _ret
  @buffering_msec.setter
  def buffering_msec(self,  value:'int'):
    self.set_buffering_msec(value)
  @property
  def stream_position(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_stream_position()
    return _ret
  @stream_position.setter
  def stream_position(self,  value:'float'):
    self.set_stream_position(value)
  @property
  def bus(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_bus()
    return _ret
  @bus.setter
  def bus(self,  value:'object'):
    self.set_bus(value)
  @functools.native_method
  def set_stream(self, stream:'py4godot_videostream.VideoStream'   ) -> None:
    r''''''

    assert(not stream is None)
    assert isinstance(stream, get_class('VideoStream')), 'stream must be VideoStream'

    self.py__stream = stream






    self._ptr.call_with_return(433,tuple([stream._ptr]))

  @functools.native_method
  def get_stream(self) -> typing.Union['py4godot_videostream.VideoStream','py4godot_videostreamtheora.VideoStreamTheora']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VideoStream
    _ret._ptr = self._ptr.call_with_return(434,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def play(self) -> None:
    r'''
				Starts the video playback from the beginning. If the video is paused, this will not unpause the video.
			'''




    self._ptr.call_with_return(435,tuple([]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the video playback and sets the stream position to 0.
				**Note:** Although the stream position will be set to 0, the first frame of the video stream won't become the current frame.
			'''




    self._ptr.call_with_return(436,tuple([]))

  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the video is playing.
				**Note:** The video is still considered playing if paused during playback.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(437,tuple([]))
    return _ret


  @functools.native_method
  def set_paused(self, paused:'bool'   ) -> None:
    r''''''

    assert isinstance(paused, bool), 'paused must be bool'

    self.py__paused = paused






    self._ptr.call_with_return(438,tuple([paused]))

  @functools.native_method
  def is_paused(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(439,tuple([]))

    return _ret


  @functools.native_method
  def set_loop(self, loop:'bool'   ) -> None:
    r''''''

    assert isinstance(loop, bool), 'loop must be bool'

    self.py__loop = loop






    self._ptr.call_with_return(440,tuple([loop]))

  @functools.native_method
  def has_loop(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(441,tuple([]))

    return _ret


  @functools.native_method
  def set_volume(self, volume:'float'   ) -> None:
    r''''''

    assert isinstance(volume, (int, float)), 'volume must be int or float'

    self.py__volume = volume






    self._ptr.call_with_return(442,tuple([volume]))

  @functools.native_method
  def get_volume(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(443,tuple([]))

    return _ret


  @functools.native_method
  def set_volume_db(self, db:'float'   ) -> None:
    r''''''

    assert isinstance(db, (int, float)), 'db must be int or float'

    self.py__volume_db = db






    self._ptr.call_with_return(444,tuple([db]))

  @functools.native_method
  def get_volume_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(445,tuple([]))

    return _ret


  @functools.native_method
  def set_speed_scale(self, speed_scale:'float'   ) -> None:
    r''''''

    assert isinstance(speed_scale, (int, float)), 'speed_scale must be int or float'

    self.py__speed_scale = speed_scale






    self._ptr.call_with_return(446,tuple([speed_scale]))

  @functools.native_method
  def get_speed_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(447,tuple([]))

    return _ret


  @functools.native_method
  def set_audio_track(self, track:'int'   ) -> None:
    r''''''

    assert isinstance(track, (int, float)), 'track must be int or float'

    self.py__audio_track = track






    self._ptr.call_with_return(448,tuple([track]))

  @functools.native_method
  def get_audio_track(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(449,tuple([]))

    return _ret


  @functools.native_method
  def get_stream_name(self) -> typing.Union[str]:
    r'''
				Returns the video stream's name, or `"<No Stream>"` if no video stream is assigned.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(450,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_stream_length(self) -> typing.Union[float]:
    r'''
				The length of the current stream, in seconds.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(451,tuple([]))
    return _ret


  @functools.native_method
  def set_stream_position(self, position:'float'   ) -> None:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'

    self.py__stream_position = position






    self._ptr.call_with_return(452,tuple([position]))

  @functools.native_method
  def get_stream_position(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(453,tuple([]))

    return _ret


  @functools.native_method
  def set_autoplay(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__autoplay = enabled






    self._ptr.call_with_return(454,tuple([enabled]))

  @functools.native_method
  def has_autoplay(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(455,tuple([]))

    return _ret


  @functools.native_method
  def set_expand(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__expand = enable






    self._ptr.call_with_return(456,tuple([enable]))

  @functools.native_method
  def has_expand(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([]))

    return _ret


  @functools.native_method
  def set_buffering_msec(self, msec:'int'   ) -> None:
    r''''''

    assert isinstance(msec, (int, float)), 'msec must be int or float'

    self.py__buffering_msec = msec






    self._ptr.call_with_return(458,tuple([msec]))

  @functools.native_method
  def get_buffering_msec(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(459,tuple([]))

    return _ret


  @functools.native_method
  def set_bus(self, bus:'object'   ) -> None:
    r''''''

    assert(not bus is None)
    assert isinstance(bus, (str, StringName)), 'bus must be str or StringName'

    self.py__bus = bus



    assert(isinstance(bus, (str, StringName)))
    py_stringname_bus = bus if isinstance(bus, StringName) else c_utils.py_string_to_string_name(bus)


    self._ptr.call_with_return(460,tuple([py_stringname_bus._ptr]))

  @functools.native_method
  def get_bus(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(461,tuple([]))

    return _ret


  @functools.native_method
  def get_video_texture(self) -> typing.Any:
    r'''
				Returns the current frame as a `Texture2D`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(462,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('VideoStreamPlayer', VideoStreamPlayer.cast)
register_class('VideoStreamPlayer', VideoStreamPlayer)
