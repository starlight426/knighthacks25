# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TranslationDomain as py4godot_translationdomain 
  import py4godot.classes.Translation as py4godot_translation 
  import py4godot.classes.OptimizedTranslation as py4godot_optimizedtranslation 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPTranslationServerWrapper

_TranslationServer_singleton_instance = None

class TranslationServer(py4godot_object.Object):
  r'''
		The translation server is the API backend that manages all language translations.
		Translations are stored in `TranslationDomain`s, which can be accessed by name. The most commonly used translation domain is the main translation domain. It always exists and can be accessed using an empty `StringName`. The translation server provides wrapper methods for accessing the main translation domain directly, without having to fetch the translation domain first. Custom translation domains are mainly for advanced usages like editor plugins. Names starting with `godot.` are reserved for engine internals.
	'''


  def generate_wrapper(self):
    return CPPTranslationServerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TranslationServer.__new__(TranslationServer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TranslationServer'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TranslationServer.construct_without_init()
    cls._ptr = CPPTranslationServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TranslationServer.construct_without_init()
    cls._ptr = CPPTranslationServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _TranslationServer_singleton_instance
    if _TranslationServer_singleton_instance is None:
      singleton = TranslationServer()
      singleton._ptr = constructor(848,0, ())
      _TranslationServer_singleton_instance = singleton
    return _TranslationServer_singleton_instance

  @property
  def pseudolocalization_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pseudolocalization_enabled()
    return _ret
  @pseudolocalization_enabled.setter
  def pseudolocalization_enabled(self,  value:'bool'):
    self.set_pseudolocalization_enabled(value)
  @functools.native_method
  def set_locale(self, locale:'str'   ) -> None:
    r'''
				Sets the locale of the project. The `locale` string will be standardized to match known locales (e.g. `en-US` would be matched to `en_US`).
				If translations have been loaded beforehand for the new locale, they will be applied.
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'




    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    self._ptr.call_with_return(49,tuple([py_string_locale._ptr]))

  @functools.native_method
  def get_locale(self) -> typing.Union[str]:
    r'''
				Returns the current locale of the project.
				See also `OS.get_locale` and `OS.get_locale_language` to query the locale of the user system.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_tool_locale(self) -> typing.Union[str]:
    r'''
				Returns the current locale of the editor.
				**Note:** When called from an exported project returns the same value as `get_locale`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def compare_locales(self, locale_a:'str'   , locale_b:'str'   ) -> typing.Union[int]:
    r'''
				Compares two locales and returns a similarity score between `0` (no match) and `10` (full match).
			'''

    assert(not locale_a is None)
    assert isinstance(locale_a, (str, String)), 'locale_a must be str or String'
    assert(not locale_b is None)
    assert isinstance(locale_b, (str, String)), 'locale_b must be str or String'




    assert(isinstance(locale_a, (str, String)))
    py_string_locale_a = locale_a if isinstance(locale_a, StringName) else c_utils.py_string_to_string(locale_a)
    assert(isinstance(locale_b, (str, String)))
    py_string_locale_b = locale_b if isinstance(locale_b, StringName) else c_utils.py_string_to_string(locale_b)

    _ret = 0
    _ret = self._ptr.call_with_return(52,tuple([py_string_locale_a._ptr, py_string_locale_b._ptr]))
    return _ret


  @functools.native_method
  def standardize_locale(self, locale:'str'   , add_defaults:'bool' =False  ) -> typing.Union[str]:
    r'''
				Returns a `locale` string standardized to match known locales (e.g. `en-US` would be matched to `en_US`). If `add_defaults` is `true`, the locale may have a default script or country added.
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'
    assert isinstance(add_defaults, bool), 'add_defaults must be bool'




    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([py_string_locale._ptr, add_defaults]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_all_languages(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns array of known language codes.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return _ret


  @functools.native_method
  def get_language_name(self, language:'str'   ) -> typing.Union[str]:
    r'''
				Returns a readable language name for the `language` code.
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'




    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_all_scripts(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array of known script codes.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def get_script_name(self, script:'str'   ) -> typing.Union[str]:
    r'''
				Returns a readable script name for the `script` code.
			'''

    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'




    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([py_string_script._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_all_countries(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array of known country codes.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return _ret


  @functools.native_method
  def get_country_name(self, country:'str'   ) -> typing.Union[str]:
    r'''
				Returns a readable country name for the `country` code.
			'''

    assert(not country is None)
    assert isinstance(country, (str, String)), 'country must be str or String'




    assert(isinstance(country, (str, String)))
    py_string_country = country if isinstance(country, StringName) else c_utils.py_string_to_string(country)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([py_string_country._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_locale_name(self, locale:'str'   ) -> typing.Union[str]:
    r'''
				Returns a locale's language and its variant (e.g. `"en_US"` would return `"English (United States)"`).
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'




    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([py_string_locale._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def translate(self, message:'object'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns the current locale's translation for the given message and context.
				**Note:** This method always uses the main translation domain.
			'''
    if context is None:
      context = StringName.new0()
    if context is None:
      context = StringName.new0()

    assert(not message is None)
    assert isinstance(message, (str, StringName)), 'message must be str or StringName'




    assert(isinstance(message, (str, StringName)))
    py_stringname_message = message if isinstance(message, StringName) else c_utils.py_string_to_string_name(message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([py_stringname_message._ptr, py_stringname_context._ptr]))
    return _ret


  @functools.native_method
  def translate_plural(self, message:'object'   , plural_message:'object'   , n:'int'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns the current locale's translation for the given message, plural message and context.
				The number `n` is the number or quantity of the plural object. It will be used to guide the translation system to fetch the correct plural form for the selected language.
				**Note:** This method always uses the main translation domain.
			'''
    if context is None:
      context = StringName.new0()
    if context is None:
      context = StringName.new0()

    assert(not message is None)
    assert isinstance(message, (str, StringName)), 'message must be str or StringName'
    assert(not plural_message is None)
    assert isinstance(plural_message, (str, StringName)), 'plural_message must be str or StringName'
    assert isinstance(n, (int, float)), 'n must be int or float'




    assert(isinstance(message, (str, StringName)))
    py_stringname_message = message if isinstance(message, StringName) else c_utils.py_string_to_string_name(message)
    assert(isinstance(plural_message, (str, StringName)))
    py_stringname_plural_message = plural_message if isinstance(plural_message, StringName) else c_utils.py_string_to_string_name(plural_message)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([py_stringname_message._ptr, py_stringname_plural_message._ptr, n, py_stringname_context._ptr]))
    return _ret


  @functools.native_method
  def add_translation(self, translation:'py4godot_translation.Translation'   ) -> None:
    r'''
				Adds a translation to the main translation domain.
			'''

    assert(not translation is None)
    assert isinstance(translation, get_class('Translation')), 'translation must be Translation'






    self._ptr.call_with_return(63,tuple([translation._ptr]))

  @functools.native_method
  def remove_translation(self, translation:'py4godot_translation.Translation'   ) -> None:
    r'''
				Removes the given translation from the main translation domain.
			'''

    assert(not translation is None)
    assert isinstance(translation, get_class('Translation')), 'translation must be Translation'






    self._ptr.call_with_return(64,tuple([translation._ptr]))

  @functools.native_method
  def get_translation_object(self, locale:'str'   ) -> typing.Union['py4godot_translation.Translation','py4godot_optimizedtranslation.OptimizedTranslation']:
    r'''
				Returns the `Translation` instance that best matches `locale` in the main translation domain. Returns `null` if there are no matches.
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'




    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Translation
    _ret._ptr = self._ptr.call_with_return(65,tuple([py_string_locale._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def has_domain(self, domain:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a translation domain with the specified name exists.
			'''

    assert(not domain is None)
    assert isinstance(domain, (str, StringName)), 'domain must be str or StringName'




    assert(isinstance(domain, (str, StringName)))
    py_stringname_domain = domain if isinstance(domain, StringName) else c_utils.py_string_to_string_name(domain)

    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([py_stringname_domain._ptr]))
    return _ret


  @functools.native_method
  def get_or_add_domain(self, domain:'object'   ) -> typing.Union['py4godot_translationdomain.TranslationDomain']:
    r'''
				Returns the translation domain with the specified name. An empty translation domain will be created and added if it does not exist.
			'''

    assert(not domain is None)
    assert isinstance(domain, (str, StringName)), 'domain must be str or StringName'




    assert(isinstance(domain, (str, StringName)))
    py_stringname_domain = domain if isinstance(domain, StringName) else c_utils.py_string_to_string_name(domain)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TranslationDomain
    _ret._ptr = self._ptr.call_with_return(67,tuple([py_stringname_domain._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def remove_domain(self, domain:'object'   ) -> None:
    r'''
				Removes the translation domain with the specified name.
				**Note:** Trying to remove the main translation domain is an error.
			'''

    assert(not domain is None)
    assert isinstance(domain, (str, StringName)), 'domain must be str or StringName'




    assert(isinstance(domain, (str, StringName)))
    py_stringname_domain = domain if isinstance(domain, StringName) else c_utils.py_string_to_string_name(domain)

    self._ptr.call_with_return(68,tuple([py_stringname_domain._ptr]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Removes all translations from the main translation domain.
			'''




    self._ptr.call_with_return(69,tuple([]))

  @functools.native_method
  def get_loaded_locales(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array of all loaded locales of the project.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def is_pseudolocalization_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__pseudolocalization_enabled = enabled






    self._ptr.call_with_return(72,tuple([enabled]))

  @functools.native_method
  def reload_pseudolocalization(self) -> None:
    r'''
				Reparses the pseudolocalization options and reloads the translation for the main translation domain.
			'''




    self._ptr.call_with_return(73,tuple([]))

  @functools.native_method
  def pseudolocalize(self, message:'object'   ) -> typing.Union['StringName']:
    r'''
				Returns the pseudolocalized string based on the `message` passed in.
				**Note:** This method always uses the main translation domain.
			'''

    assert(not message is None)
    assert isinstance(message, (str, StringName)), 'message must be str or StringName'




    assert(isinstance(message, (str, StringName)))
    py_stringname_message = message if isinstance(message, StringName) else c_utils.py_string_to_string_name(message)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([py_stringname_message._ptr]))
    return _ret



register_cast_function('TranslationServer', TranslationServer.cast)
register_class('TranslationServer', TranslationServer)
