# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.XRPositionalTracker as py4godot_xrpositionaltracker 
  import py4godot.classes.XRControllerTracker as py4godot_xrcontrollertracker 
  import py4godot.classes.XRHandTracker as py4godot_xrhandtracker 
  import py4godot.classes.XRBodyTracker as py4godot_xrbodytracker 
import py4godot.classes.XRNode3D as py4godot_xrnode3d 
from py4godot.wrappers.wrappers import CPPXRController3DWrapper


class XRController3D(py4godot_xrnode3d.XRNode3D):
  r'''
		This is a helper 3D node that is linked to the tracking of controllers. It also offers several handy passthroughs to the state of buttons and such on the controllers.
		Controllers are linked by their ID. You can create controller nodes before the controllers are available. If your game always uses two controllers (one for each hand), you can predefine the controllers with ID 1 and 2; they will become active as soon as the controllers are identified. If you expect additional controllers to be used, you should react to the signals and add XRController3D nodes to your scene.
		The position of the controller node is automatically updated by the `XRServer`. This makes this node ideal to add child nodes to visualize the controller.
		The current `XRInterface` defines the names of inputs. In the case of OpenXR, these are the names of actions in the current action set from the OpenXR action map.
	'''

  @staticmethod
  def constructor():
    class_ = XRController3D.construct_without_init()
    class_._ptr = constructor(1015,0, ())
    return class_
  @staticmethod
  def new():
    class_ = XRController3D.construct_without_init()
    class_._ptr = constructor(1015,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPXRController3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(1015,0, ())


  def generate_wrapper(self):
    return CPPXRController3DWrapper()
  def init_signals(self):
    super().init_signals()
    button_pressed_name = utils.py_string_to_string_name("button_pressed")
    self.button_pressed = signals.BuiltinSignal(self, button_pressed_name)
    button_released_name = utils.py_string_to_string_name("button_released")
    self.button_released = signals.BuiltinSignal(self, button_released_name)
    input_float_changed_name = utils.py_string_to_string_name("input_float_changed")
    self.input_float_changed = signals.BuiltinSignal(self, input_float_changed_name)
    input_vector2_changed_name = utils.py_string_to_string_name("input_vector2_changed")
    self.input_vector2_changed = signals.BuiltinSignal(self, input_vector2_changed_name)
    profile_changed_name = utils.py_string_to_string_name("profile_changed")
    self.profile_changed = signals.BuiltinSignal(self, profile_changed_name)

  @staticmethod
  def construct_without_init():
    cls = XRController3D.__new__(XRController3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'XRController3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRController3D.construct_without_init()
    cls._ptr = CPPXRController3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRController3D.construct_without_init()
    cls._ptr = CPPXRController3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def is_button_pressed(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the button with the given `name` is pressed.
				**Note:** The current `XRInterface` defines the `name` for each input. In the case of OpenXR, these are the names of actions in the current action set.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(261,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_input(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns a `Variant` for the input with the given `name`. This works for any input type, the variant will be typed according to the actions configuration.
				**Note:** The current `XRInterface` defines the `name` for each input. In the case of OpenXR, these are the names of actions in the current action set.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(262,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_float(self, name:'object'   ) -> typing.Union[float]:
    r'''
				Returns a numeric value for the input with the given `name`. This is used for triggers and grip sensors.
				**Note:** The current `XRInterface` defines the `name` for each input. In the case of OpenXR, these are the names of actions in the current action set.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_vector2(self, name:'object'   ) -> typing.Union['Vector2']:
    r'''
				Returns a `Vector2` for the input with the given `name`. This is used for thumbsticks and thumbpads found on many controllers.
				**Note:** The current `XRInterface` defines the `name` for each input. In the case of OpenXR, these are the names of actions in the current action set.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(264,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_tracker_hand(self) -> typing.Union[int]:
    r'''
				Returns the hand holding this controller, if known.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(265,tuple([]))
    return _ret



register_cast_function('XRController3D', XRController3D.cast)
register_class('XRController3D', XRController3D)
