# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
  import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
import py4godot.classes.RefCounted as py4godot_refcounted 
import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
from py4godot.wrappers.wrappers import CPPSurfaceToolWrapper

class CustomFormat:
  CUSTOM_RGBA8_UNORM = 0
  CUSTOM_RGBA8_SNORM = 1
  CUSTOM_RG_HALF = 2
  CUSTOM_RGBA_HALF = 3
  CUSTOM_R_FLOAT = 4
  CUSTOM_RG_FLOAT = 5
  CUSTOM_RGB_FLOAT = 6
  CUSTOM_RGBA_FLOAT = 7
  CUSTOM_MAX = 8
class SkinWeightCount:
  SKIN_4_WEIGHTS = 0
  SKIN_8_WEIGHTS = 1


class SurfaceTool(py4godot_refcounted.RefCounted):
  r'''
		The `SurfaceTool` is used to construct a `Mesh` by specifying vertex attributes individually. It can be used to construct a `Mesh` from a script. All properties except indices need to be added before calling `add_vertex`. For example, to add vertex colors and UVs:
		
		```gdscript
		var st = SurfaceTool.new()
		st.begin(Mesh.PRIMITIVE_TRIANGLES)
		st.set_color(Color(1, 0, 0))
		st.set_uv(Vector2(0, 0))
		st.add_vertex(Vector3(0, 0, 0))
		```
		
		
		The above `SurfaceTool` now contains one vertex of a triangle which has a UV coordinate and a specified `Color`. If another vertex were added without calling `set_uv` or `set_color`, then the last values would be used.
		Vertex attributes must be passed **before** calling `add_vertex`. Failure to do so will result in an error when committing the vertex information to a mesh.
		Additionally, the attributes used before the first vertex is added determine the format of the mesh. For example, if you only add UVs to the first vertex, you cannot add color to any of the subsequent vertices.
		See also `ArrayMesh`, `ImmediateMesh` and `MeshDataTool` for procedural geometry generation.
		**Note:** Godot uses clockwise `url=https://learnopengl.com/Advanced-OpenGL/Face-culling`winding order`/url` for front faces of triangle primitive modes.
	'''

  @staticmethod
  def constructor():
    class_ = SurfaceTool.construct_without_init()
    class_._ptr = constructor(801,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SurfaceTool.construct_without_init()
    class_._ptr = constructor(801,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSurfaceToolWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(801,0, ())


  def generate_wrapper(self):
    return CPPSurfaceToolWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SurfaceTool.__new__(SurfaceTool)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SurfaceTool'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SurfaceTool.construct_without_init()
    cls._ptr = CPPSurfaceToolWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SurfaceTool.construct_without_init()
    cls._ptr = CPPSurfaceToolWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def set_skin_weight_count(self, count:'int'  ) -> None:
    r'''
				Set to `constant SKIN_8_WEIGHTS` to indicate that up to 8 bone influences per vertex may be used.
				By default, only 4 bone influences are used (`constant SKIN_4_WEIGHTS`).
				**Note:** This function takes an enum, not the exact number of weights.
			'''

    assert isinstance(count, (int, float)), 'count must be int or float'






    self._ptr.call_with_return(53,tuple([count]))

  @functools.native_method
  def get_skin_weight_count(self) -> typing.Union[int]:
    r'''
				By default, returns `constant SKIN_4_WEIGHTS` to indicate only 4 bone influences per vertex are used.
				Returns `constant SKIN_8_WEIGHTS` if up to 8 influences are used.
				**Note:** This function returns an enum, not the exact number of weights.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(54,tuple([]))
    return _ret


  @functools.native_method
  def set_custom_format(self, channel_index:'int'   , format:'int'  ) -> None:
    r'''
				Sets the color format for this custom `channel_index`. Use `constant CUSTOM_MAX` to disable.
				Must be invoked after `begin` and should be set before `commit` or `commit_to_arrays`.
			'''

    assert isinstance(channel_index, (int, float)), 'channel_index must be int or float'
    assert isinstance(format, (int, float)), 'format must be int or float'







    self._ptr.call_with_return(55,tuple([channel_index, format]))

  @functools.native_method
  def get_custom_format(self, channel_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the format for custom `channel_index` (currently up to 4). Returns `constant CUSTOM_MAX` if this custom channel is unused.
			'''

    assert isinstance(channel_index, (int, float)), 'channel_index must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(56,tuple([channel_index]))
    return _ret


  @functools.native_method
  def begin(self, primitive:'int'  ) -> None:
    r'''
				Called before adding any vertices. Takes the primitive type as an argument (e.g. `constant Mesh.PRIMITIVE_TRIANGLES`).
			'''

    assert isinstance(primitive, (int, float)), 'primitive must be int or float'






    self._ptr.call_with_return(57,tuple([primitive]))

  @functools.native_method
  def add_vertex(self, vertex:'Vector3'   ) -> None:
    r'''
				Specifies the position of current vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
			'''

    assert(not vertex is None)
    assert isinstance(vertex, Vector3), 'vertex must be Vector3'






    self._ptr.call_with_return(58,tuple([vertex._ptr]))

  @functools.native_method
  def set_color(self, color:'Color'   ) -> None:
    r'''
				Specifies a `Color` to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
				**Note:** The material must have `BaseMaterial3D.vertex_color_use_as_albedo` enabled for the vertex color to be visible.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'






    self._ptr.call_with_return(59,tuple([color._ptr]))

  @functools.native_method
  def set_normal(self, normal:'Vector3'   ) -> None:
    r'''
				Specifies a normal to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			'''

    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'






    self._ptr.call_with_return(60,tuple([normal._ptr]))

  @functools.native_method
  def set_tangent(self, tangent:'Plane'   ) -> None:
    r'''
				Specifies a tangent to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			'''

    assert(not tangent is None)
    assert isinstance(tangent, Plane), 'tangent must be Plane'






    self._ptr.call_with_return(61,tuple([tangent._ptr]))

  @functools.native_method
  def set_uv(self, uv:'Vector2'   ) -> None:
    r'''
				Specifies a set of UV coordinates to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			'''

    assert(not uv is None)
    assert isinstance(uv, Vector2), 'uv must be Vector2'






    self._ptr.call_with_return(62,tuple([uv._ptr]))

  @functools.native_method
  def set_uv2(self, uv2:'Vector2'   ) -> None:
    r'''
				Specifies an optional second set of UV coordinates to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			'''

    assert(not uv2 is None)
    assert isinstance(uv2, Vector2), 'uv2 must be Vector2'






    self._ptr.call_with_return(63,tuple([uv2._ptr]))

  @functools.native_method
  def set_bones(self, bones:'PackedInt32Array'   ) -> None:
    r'''
				Specifies an array of bones to use for the _next_ vertex. `bones` must contain 4 integers.
			'''

    assert(not bones is None)
    assert isinstance(bones, PackedInt32Array), 'bones must be PackedInt32Array'






    self._ptr.call_with_return(64,tuple([bones._ptr]))

  @functools.native_method
  def set_weights(self, weights:'PackedFloat32Array'   ) -> None:
    r'''
				Specifies weight values to use for the _next_ vertex. `weights` must contain 4 values. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			'''

    assert(not weights is None)
    assert isinstance(weights, PackedFloat32Array), 'weights must be PackedFloat32Array'






    self._ptr.call_with_return(65,tuple([weights._ptr]))

  @functools.native_method
  def set_custom(self, channel_index:'int'   , custom_color:'Color'   ) -> None:
    r'''
				Sets the custom value on this vertex for `channel_index`.
				`set_custom_format` must be called first for this `channel_index`. Formats which are not RGBA will ignore other color channels.
			'''

    assert isinstance(channel_index, (int, float)), 'channel_index must be int or float'
    assert(not custom_color is None)
    assert isinstance(custom_color, Color), 'custom_color must be Color'







    self._ptr.call_with_return(66,tuple([channel_index, custom_color._ptr]))

  @functools.native_method
  def set_smooth_group(self, index:'int'   ) -> None:
    r'''
				Specifies the smooth group to use for the _next_ vertex. If this is never called, all vertices will have the default smooth group of `0` and will be smoothed with adjacent vertices of the same group. To produce a mesh with flat normals, set the smooth group to `-1`.
				**Note:** This function actually takes a `uint32_t`, so C# users should use `uint32.MaxValue` instead of `-1` to produce a mesh with flat normals.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(67,tuple([index]))

  @functools.native_method
  def add_triangle_fan(self, vertices:'PackedVector3Array'   , uvs:'PackedVector2Array' = None  , colors:'PackedColorArray' = None  , uv2s:'PackedVector2Array' = None  , normals:'PackedVector3Array' = None  , tangents:'py4godot_planetypedarray.PlaneTypedArray' = None  ) -> None:
    r'''
				Inserts a triangle fan made of array data into `Mesh` being constructed.
				Requires the primitive type be set to `constant Mesh.PRIMITIVE_TRIANGLES`.
			'''
    if uvs is None:
      uvs = PackedVector2Array.new0()
    if colors is None:
      colors = PackedColorArray.new0()
    if uv2s is None:
      uv2s = PackedVector2Array.new0()
    if normals is None:
      normals = PackedVector3Array.new0()

    if uvs is None:
      uvs = PackedVector2Array.new0()
    if colors is None:
      colors = PackedColorArray.new0()
    if uv2s is None:
      uv2s = PackedVector2Array.new0()
    if normals is None:
      normals = PackedVector3Array.new0()


    assert(not vertices is None)
    assert isinstance(vertices, PackedVector3Array), 'vertices must be PackedVector3Array'
    assert isinstance(tangents, get_class('PlaneTypedArray')), 'tangents must be PlaneTypedArray'











    self._ptr.call_with_return(68,tuple([vertices._ptr, uvs._ptr, colors._ptr, uv2s._ptr, normals._ptr, tangents._ptr]))

  @functools.native_method
  def add_index(self, index:'int'   ) -> None:
    r'''
				Adds a vertex to index array if you are using indexed vertices. Does not need to be called before adding vertices.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(69,tuple([index]))

  @functools.native_method
  def index(self) -> None:
    r'''
				Shrinks the vertex array by creating an index array. This can improve performance by avoiding vertex reuse.
			'''




    self._ptr.call_with_return(70,tuple([]))

  @functools.native_method
  def deindex(self) -> None:
    r'''
				Removes the index array by expanding the vertex array.
			'''




    self._ptr.call_with_return(71,tuple([]))

  @functools.native_method
  def generate_normals(self, flip:'bool' =False  ) -> None:
    r'''
				Generates normals from vertices so you do not have to do it manually. If `flip` is `true`, the resulting normals will be inverted. `generate_normals` should be called _after_ generating geometry and _before_ committing the mesh using `commit` or `commit_to_arrays`. For correct display of normal-mapped surfaces, you will also have to generate tangents using `generate_tangents`.
				**Note:** `generate_normals` only works if the primitive type is set to `constant Mesh.PRIMITIVE_TRIANGLES`.
				**Note:** `generate_normals` takes smooth groups into account. To generate smooth normals, set the smooth group to a value greater than or equal to `0` using `set_smooth_group` or leave the smooth group at the default of `0`. To generate flat normals, set the smooth group to `-1` using `set_smooth_group` prior to adding vertices.
			'''

    assert isinstance(flip, bool), 'flip must be bool'






    self._ptr.call_with_return(72,tuple([flip]))

  @functools.native_method
  def generate_tangents(self) -> None:
    r'''
				Generates a tangent vector for each vertex. Requires that each vertex already has UVs and normals set (see `generate_normals`).
			'''




    self._ptr.call_with_return(73,tuple([]))

  @functools.native_method
  def optimize_indices_for_cache(self) -> None:
    r'''
				Optimizes triangle sorting for performance. Requires that `get_primitive_type` is `constant Mesh.PRIMITIVE_TRIANGLES`.
			'''




    self._ptr.call_with_return(74,tuple([]))

  @functools.native_method
  def get_aabb(self) -> typing.Union['AABB']:
    r'''
				Returns the axis-aligned bounding box of the vertex positions.
			'''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([]))
    return _ret


  @functools.native_method
  def generate_lod(self, nd_threshold:'float'   , target_index_count:'int' =3  ) -> typing.Union['PackedInt32Array']:
    r'''
				Generates an LOD for a given `nd_threshold` in linear units (square root of quadric error metric), using at most `target_index_count` indices.
			'''

    assert isinstance(nd_threshold, (int, float)), 'nd_threshold must be int or float'
    assert isinstance(target_index_count, (int, float)), 'target_index_count must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([nd_threshold, target_index_count]))
    return _ret


  @functools.native_method
  def set_material(self, material:'py4godot_material.Material'   ) -> None:
    r'''
				Sets `Material` to be used by the `Mesh` you are constructing.
			'''

    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'






    self._ptr.call_with_return(77,tuple([material._ptr]))

  @functools.native_method
  def get_primitive_type(self) -> typing.Union[int]:
    r'''
				Returns the type of mesh geometry, such as `constant Mesh.PRIMITIVE_TRIANGLES`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r'''
				Clear all information passed into the surface tool so far.
			'''




    self._ptr.call_with_return(79,tuple([]))

  @functools.native_method
  def create_from(self, existing:'py4godot_mesh.Mesh'   , surface:'int'   ) -> None:
    r'''
				Creates a vertex array from an existing `Mesh`.
			'''

    assert(not existing is None)
    assert isinstance(existing, get_class('Mesh')), 'existing must be Mesh'
    assert isinstance(surface, (int, float)), 'surface must be int or float'







    self._ptr.call_with_return(80,tuple([existing._ptr, surface]))

  @functools.native_method
  def create_from_arrays(self, arrays:'Array'   , primitive_type:'int'  =3) -> None:
    r'''
				Creates this SurfaceTool from existing vertex arrays such as returned by `commit_to_arrays`, `Mesh.surface_get_arrays`, `Mesh.surface_get_blend_shape_arrays`, `ImporterMesh.get_surface_arrays`, and `ImporterMesh.get_surface_blend_shape_arrays`. `primitive_type` controls the type of mesh data, defaulting to `constant Mesh.PRIMITIVE_TRIANGLES`.
			'''



    assert(not arrays is None)
    assert isinstance(arrays, Array), 'arrays must be Array'
    assert isinstance(primitive_type, (int, float)), 'primitive_type must be int or float'







    self._ptr.call_with_return(81,tuple([arrays._ptr, primitive_type]))

  @functools.native_method
  def create_from_blend_shape(self, existing:'py4godot_mesh.Mesh'   , surface:'int'   , blend_shape:'str'   ) -> None:
    r'''
				Creates a vertex array from the specified blend shape of an existing `Mesh`. This can be used to extract a specific pose from a blend shape.
			'''

    assert(not existing is None)
    assert isinstance(existing, get_class('Mesh')), 'existing must be Mesh'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert(not blend_shape is None)
    assert isinstance(blend_shape, (str, String)), 'blend_shape must be str or String'






    assert(isinstance(blend_shape, (str, String)))
    py_string_blend_shape = blend_shape if isinstance(blend_shape, StringName) else c_utils.py_string_to_string(blend_shape)

    self._ptr.call_with_return(82,tuple([existing._ptr, surface, py_string_blend_shape._ptr]))

  @functools.native_method
  def append_from(self, existing:'py4godot_mesh.Mesh'   , surface:'int'   , transform:'Transform3D'   ) -> None:
    r'''
				Append vertices from a given `Mesh` surface onto the current vertex array with specified `Transform3D`.
			'''

    assert(not existing is None)
    assert isinstance(existing, get_class('Mesh')), 'existing must be Mesh'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'








    self._ptr.call_with_return(83,tuple([existing._ptr, surface, transform._ptr]))

  @functools.native_method
  def commit(self, existing:'py4godot_arraymesh.ArrayMesh' = None  , flags:'int' =0  ) -> typing.Union['py4godot_arraymesh.ArrayMesh']:
    r'''
				Returns a constructed `ArrayMesh` from current information passed in. If an existing `ArrayMesh` is passed in as an argument, will add an extra surface to the existing `ArrayMesh`.
				The `flags` argument can be the bitwise OR of `constant Mesh.ARRAY_FLAG_USE_DYNAMIC_UPDATE`, `constant Mesh.ARRAY_FLAG_USE_8_BONE_WEIGHTS`, or `constant Mesh.ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY`.
			'''
    if existing is None:
      existing = c_utils.empty_object
    if existing is None:
      existing = c_utils.empty_object

    assert isinstance(flags, (int, float)), 'flags must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ArrayMesh
    _ret._ptr = self._ptr.call_with_return(84,tuple([existing._ptr, flags]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def commit_to_arrays(self) -> typing.Union['Array']:
    r'''
				Commits the data to the same format used by `ArrayMesh.add_surface_from_arrays`, `ImporterMesh.add_surface`, and `create_from_arrays`. This way you can further process the mesh data using the `ArrayMesh` or `ImporterMesh` APIs.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([]))
    return _ret



register_cast_function('SurfaceTool', SurfaceTool.cast)
register_class('SurfaceTool', SurfaceTool)
