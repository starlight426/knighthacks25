# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
  import py4godot.classes.FontTypedArray as py4godot_fonttypedarray 
import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
import py4godot.classes.FontTypedArray as py4godot_fonttypedarray 
from py4godot.wrappers.wrappers import CPPFontWrapper


class Font(py4godot_resource.Resource):
  r'''
		Abstract base class for different font types. It has methods for drawing text and font character introspection.
	'''

  @staticmethod
  def constructor():
    class_ = Font.construct_without_init()
    class_._ptr = constructor(337,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Font.construct_without_init()
    class_._ptr = constructor(337,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPFontWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(337,0, ())


  def generate_wrapper(self):
    return CPPFontWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Font.__new__(Font)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Font'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Font.construct_without_init()
    cls._ptr = CPPFontWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Font.construct_without_init()
    cls._ptr = CPPFontWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def fallbacks(self) -> typing.Union['py4godot_fonttypedarray.FontTypedArray']:
    r''''''
    _ret = self. get_fallbacks()
    return _ret
  @fallbacks.setter
  def fallbacks(self, value:'Array'):
    self.set_fallbacks(value)
  @functools.native_method
  def set_fallbacks(self, fallbacks:'py4godot_fonttypedarray.FontTypedArray'   ) -> None:
    r''''''

    assert isinstance(fallbacks, get_class('FontTypedArray')), 'fallbacks must be FontTypedArray'

    self.py__fallbacks = fallbacks






    self._ptr.call_with_return(77,tuple([fallbacks._ptr]))

  @functools.native_method
  def get_fallbacks(self) -> typing.Union['py4godot_fonttypedarray.FontTypedArray']:
    r''''''




    _ret = py4godot_fonttypedarray.FontTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def find_variation(self, variation_coordinates:'Dictionary'   , face_index:'int' =0  , strength:'float' =0.0  , transform:'Transform2D' = None  , spacing_top:'int' =0  , spacing_bottom:'int' =0  , spacing_space:'int' =0  , spacing_glyph:'int' =0  , baseline_offset:'float' =0.0  ) -> typing.Union['RID']:
    r'''
				Returns `TextServer` RID of the font cache for specific variation.
			'''
    if transform is None:
      transform = Transform2D.new0()
    if transform is None:
      transform = Transform2D.new0()

    assert(not variation_coordinates is None)
    assert isinstance(variation_coordinates, Dictionary), 'variation_coordinates must be Dictionary'
    assert isinstance(face_index, (int, float)), 'face_index must be int or float'
    assert isinstance(strength, (int, float)), 'strength must be int or float'
    assert isinstance(spacing_top, (int, float)), 'spacing_top must be int or float'
    assert isinstance(spacing_bottom, (int, float)), 'spacing_bottom must be int or float'
    assert isinstance(spacing_space, (int, float)), 'spacing_space must be int or float'
    assert isinstance(spacing_glyph, (int, float)), 'spacing_glyph must be int or float'
    assert isinstance(baseline_offset, (int, float)), 'baseline_offset must be int or float'














    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([variation_coordinates._ptr, face_index, strength, transform._ptr, spacing_top, spacing_bottom, spacing_space, spacing_glyph, baseline_offset]))
    return _ret


  @functools.native_method
  def get_rids(self) -> typing.Union['py4godot_ridtypedarray.RIDTypedArray']:
    r'''
				Returns `Array` of valid `Font` `RID`s, which can be passed to the `TextServer` methods.
			'''




    _ret = py4godot_ridtypedarray.RIDTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def get_height(self, font_size:'int' =16  ) -> typing.Union[float]:
    r'''
				Returns the total average font height (ascent plus descent) in pixels.
				**Note:** Real height of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the height of empty line).
			'''

    assert isinstance(font_size, (int, float)), 'font_size must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([font_size]))
    return _ret


  @functools.native_method
  def get_ascent(self, font_size:'int' =16  ) -> typing.Union[float]:
    r'''
				Returns the average font ascent (number of pixels above the baseline).
				**Note:** Real ascent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the ascent of empty line).
			'''

    assert isinstance(font_size, (int, float)), 'font_size must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([font_size]))
    return _ret


  @functools.native_method
  def get_descent(self, font_size:'int' =16  ) -> typing.Union[float]:
    r'''
				Returns the average font descent (number of pixels below the baseline).
				**Note:** Real descent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the descent of empty line).
			'''

    assert isinstance(font_size, (int, float)), 'font_size must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([font_size]))
    return _ret


  @functools.native_method
  def get_underline_position(self, font_size:'int' =16  ) -> typing.Union[float]:
    r'''
				Returns average pixel offset of the underline below the baseline.
				**Note:** Real underline position of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
			'''

    assert isinstance(font_size, (int, float)), 'font_size must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([font_size]))
    return _ret


  @functools.native_method
  def get_underline_thickness(self, font_size:'int' =16  ) -> typing.Union[float]:
    r'''
				Returns average thickness of the underline.
				**Note:** Real underline thickness of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
			'''

    assert isinstance(font_size, (int, float)), 'font_size must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([font_size]))
    return _ret


  @functools.native_method
  def get_font_name(self) -> typing.Union[str]:
    r'''
				Returns font family name.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_font_style_name(self) -> typing.Union[str]:
    r'''
				Returns font style name.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_ot_name_strings(self) -> typing.Union['Dictionary']:
    r'''
				Returns `Dictionary` with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def get_font_style(self) -> typing.Union[int]:
    r'''
				Returns font style flags.
			'''




    _ret
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def get_font_weight(self) -> typing.Union[int]:
    r'''
				Returns weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def get_font_stretch(self) -> typing.Union[int]:
    r'''
				Returns font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([]))
    return _ret


  @functools.native_method
  def get_spacing(self, spacing:'int'  ) -> typing.Union[int]:
    r'''
				Returns the amount of spacing for the given `spacing` type.
			'''

    assert isinstance(spacing, (int, float)), 'spacing must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([spacing]))
    return _ret


  @functools.native_method
  def get_opentype_features(self) -> typing.Union['Dictionary']:
    r'''
				Returns a set of OpenType feature tags. More info: `url=https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags`OpenType feature tags`/url`.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))
    return _ret


  @functools.native_method
  def set_cache_capacity(self, single_line:'int'   , multi_line:'int'   ) -> None:
    r'''
				Sets LRU cache capacity for `draw_*` methods.
			'''

    assert isinstance(single_line, (int, float)), 'single_line must be int or float'
    assert isinstance(multi_line, (int, float)), 'multi_line must be int or float'







    self._ptr.call_with_return(94,tuple([single_line, multi_line]))

  @functools.native_method
  def get_string_size(self, text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0) -> typing.Union['Vector2']:
    r'''
				Returns the size of a bounding box of a single-line string, taking kerning, advance and subpixel positioning into account. See also `get_multiline_string_size` and `draw_string`.
				For example, to get the string size as displayed by a single-line Label, use:
				
				```gdscript
				var string_size = $Label.get_theme_font("font").get_string_size($Label.text, HORIZONTAL_ALIGNMENT_LEFT, -1, $Label.get_theme_font_size("font_size"))
				```
				
				
				**Note:** Since kerning, advance and subpixel positioning are taken into account by `get_string_size`, using separate `get_string_size` calls on substrings of a string then adding the results together will return a different result compared to using a single `get_string_size` call on the full string.
				**Note:** Real height of the string is context-dependent and can be significantly different from the value returned by `get_height`.
			'''









    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'




    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([py_string_text._ptr, alignment, width, font_size, justification_flags, direction, orientation]))
    return _ret


  @functools.native_method
  def get_multiline_string_size(self, text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , max_lines:'int' =-1  , brk_flags:'int' =3  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0) -> typing.Union['Vector2']:
    r'''
				Returns the size of a bounding box of a string broken into the lines, taking kerning and advance into account.
				See also `draw_multiline_string`.
			'''











    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(max_lines, (int, float)), 'max_lines must be int or float'
    assert isinstance(brk_flags, (int, float)), 'brk_flags must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'




    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([py_string_text._ptr, alignment, width, font_size, max_lines, brk_flags, justification_flags, direction, orientation]))
    return _ret


  @functools.native_method
  def draw_string(self, canvas_item:'RID'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , modulate:'Color' = None  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Draw `text` into a canvas item using the font, at a given position, with `modulate` color, optionally clipping the width and aligning horizontally. `pos` specifies the baseline, not the top. To draw from the top, _ascent_ must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				See also `CanvasItem.draw_string`.
			'''

    if modulate is None:
      modulate = Color.new0()




    if modulate is None:
      modulate = Color.new0()




    assert(not canvas_item is None)
    assert isinstance(canvas_item, RID), 'canvas_item must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)









    self._ptr.call_with_return(97,tuple([canvas_item._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, modulate._ptr, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def draw_multiline_string(self, canvas_item:'RID'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , max_lines:'int' =-1  , modulate:'Color' = None  , brk_flags:'int' =3  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Breaks `text` into lines using rules specified by `brk_flags` and draws it into a canvas item using the font, at a given position, with `modulate` color, optionally clipping the width and aligning horizontally. `pos` specifies the baseline of the first line, not the top. To draw from the top, _ascent_ must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				See also `CanvasItem.draw_multiline_string`.
			'''

    if modulate is None:
      modulate = Color.new0()





    if modulate is None:
      modulate = Color.new0()





    assert(not canvas_item is None)
    assert isinstance(canvas_item, RID), 'canvas_item must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(max_lines, (int, float)), 'max_lines must be int or float'
    assert isinstance(brk_flags, (int, float)), 'brk_flags must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)











    self._ptr.call_with_return(98,tuple([canvas_item._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, max_lines, modulate._ptr, brk_flags, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def draw_string_outline(self, canvas_item:'RID'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , size:'int' =1  , modulate:'Color' = None  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Draw `text` outline into a canvas item using the font, at a given position, with `modulate` color and `size` outline size, optionally clipping the width and aligning horizontally. `pos` specifies the baseline, not the top. To draw from the top, _ascent_ must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				See also `CanvasItem.draw_string_outline`.
			'''

    if modulate is None:
      modulate = Color.new0()




    if modulate is None:
      modulate = Color.new0()




    assert(not canvas_item is None)
    assert isinstance(canvas_item, RID), 'canvas_item must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)










    self._ptr.call_with_return(99,tuple([canvas_item._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, size, modulate._ptr, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def draw_multiline_string_outline(self, canvas_item:'RID'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , max_lines:'int' =-1  , size:'int' =1  , modulate:'Color' = None  , brk_flags:'int' =3  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Breaks `text` to the lines using rules specified by `brk_flags` and draws text outline into a canvas item using the font, at a given position, with `modulate` color and `size` outline size, optionally clipping the width and aligning horizontally. `pos` specifies the baseline of the first line, not the top. To draw from the top, _ascent_ must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				See also `CanvasItem.draw_multiline_string_outline`.
			'''

    if modulate is None:
      modulate = Color.new0()





    if modulate is None:
      modulate = Color.new0()





    assert(not canvas_item is None)
    assert isinstance(canvas_item, RID), 'canvas_item must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(max_lines, (int, float)), 'max_lines must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(brk_flags, (int, float)), 'brk_flags must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)












    self._ptr.call_with_return(100,tuple([canvas_item._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, max_lines, size, modulate._ptr, brk_flags, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def get_char_size(self, char:'int'   , font_size:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the size of a character. Does not take kerning into account.
				**Note:** Do not use this function to calculate width of the string character by character, use `get_string_size` or `TextLine` instead. The height returned is the font height (see also `get_height`) and has no relation to the glyph height.
			'''

    assert isinstance(char, (int, float)), 'char must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([char, font_size]))
    return _ret


  @functools.native_method
  def draw_char(self, canvas_item:'RID'   , pos:'Vector2'   , char:'int'   , font_size:'int'   , modulate:'Color' = None  , oversampling:'float' =0.0  ) -> typing.Union[float]:
    r'''
				Draw a single Unicode character `char` into a canvas item using the font, at a given position, with `modulate` color. `pos` specifies the baseline, not the top. To draw from the top, _ascent_ must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				**Note:** Do not use this function to draw strings character by character, use `draw_string` or `TextLine` instead.
			'''
    if modulate is None:
      modulate = Color.new0()
    if modulate is None:
      modulate = Color.new0()

    assert(not canvas_item is None)
    assert isinstance(canvas_item, RID), 'canvas_item must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(char, (int, float)), 'char must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'











    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([canvas_item._ptr, pos._ptr, char, font_size, modulate._ptr, oversampling]))
    return _ret


  @functools.native_method
  def draw_char_outline(self, canvas_item:'RID'   , pos:'Vector2'   , char:'int'   , font_size:'int'   , size:'int' =-1  , modulate:'Color' = None  , oversampling:'float' =0.0  ) -> typing.Union[float]:
    r'''
				Draw a single Unicode character `char` outline into a canvas item using the font, at a given position, with `modulate` color and `size` outline size. `pos` specifies the baseline, not the top. To draw from the top, _ascent_ must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				**Note:** Do not use this function to draw strings character by character, use `draw_string` or `TextLine` instead.
			'''
    if modulate is None:
      modulate = Color.new0()
    if modulate is None:
      modulate = Color.new0()

    assert(not canvas_item is None)
    assert isinstance(canvas_item, RID), 'canvas_item must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(char, (int, float)), 'char must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'












    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([canvas_item._ptr, pos._ptr, char, font_size, size, modulate._ptr, oversampling]))
    return _ret


  @functools.native_method
  def has_char(self, char:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a Unicode `char` is available in the font.
			'''

    assert isinstance(char, (int, float)), 'char must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([char]))
    return _ret


  @functools.native_method
  def get_supported_chars(self) -> typing.Union[str]:
    r'''
				Returns a string containing all the characters available in the font.
				If a given character is included in more than one font data source, it appears only once in the returned string.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_language_supported(self, language:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true`, if font supports given language (`url=https://en.wikipedia.org/wiki/ISO_639-1`ISO 639`/url` code).
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'




    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([py_string_language._ptr]))
    return _ret


  @functools.native_method
  def is_script_supported(self, script:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true`, if font supports given script (`url=https://en.wikipedia.org/wiki/ISO_15924`ISO 15924`/url` code).
			'''

    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'




    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([py_string_script._ptr]))
    return _ret


  @functools.native_method
  def get_supported_feature_list(self) -> typing.Union['Dictionary']:
    r'''
				Returns list of OpenType features supported by font.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))
    return _ret


  @functools.native_method
  def get_supported_variation_list(self) -> typing.Union['Dictionary']:
    r'''
				Returns list of supported `url=https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg`variation coordinates`/url`, each coordinate is returned as `tag: Vector3i(min_value,max_value,default_value)`.
				Font variations allow for continuous change of glyph characteristics along some given design axis, such as weight, width or slant.
				To print available variation axes of a variable font:
				```gdscript
				var fv = FontVariation.new()
				fv.base_font = load("res://RobotoFlex.ttf")
				var variation_list = fv.get_supported_variation_list()
				for tag in variation_list:
					var name = TextServerManager.get_primary_interface().tag_to_name(tag)
					var values = variation_list`tag`
					print("variation axis: %s (%d)\n\tmin, max, default: %s" % `name, tag, values`)
				```
				**Note:** To set and get variation coordinates of a `FontVariation`, use `FontVariation.variation_opentype`.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(109,tuple([]))
    return _ret


  @functools.native_method
  def get_face_count(self) -> typing.Union[int]:
    r'''
				Returns number of faces in the TrueType / OpenType collection.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([]))
    return _ret



register_cast_function('Font', Font.cast)
register_class('Font', Font)
