# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
  import py4godot.classes.PackedVector2ArrayTypedArray as py4godot_packedvector2arraytypedarray 
import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.PackedVector2ArrayTypedArray as py4godot_packedvector2arraytypedarray 
from py4godot.wrappers.wrappers import CPPGeometry2DWrapper

_Geometry2D_singleton_instance = None
class PolyBooleanOperation:
  OPERATION_UNION = 0
  OPERATION_DIFFERENCE = 1
  OPERATION_INTERSECTION = 2
  OPERATION_XOR = 3
class PolyJoinType:
  JOIN_SQUARE = 0
  JOIN_ROUND = 1
  JOIN_MITER = 2
class PolyEndType:
  END_POLYGON = 0
  END_JOINED = 1
  END_BUTT = 2
  END_SQUARE = 3
  END_ROUND = 4


class Geometry2D(py4godot_object.Object):
  r'''
		Provides a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations in 2D.
	'''


  def generate_wrapper(self):
    return CPPGeometry2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Geometry2D.__new__(Geometry2D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Geometry2D'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Geometry2D.construct_without_init()
    cls._ptr = CPPGeometry2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Geometry2D.construct_without_init()
    cls._ptr = CPPGeometry2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _Geometry2D_singleton_instance
    if _Geometry2D_singleton_instance is None:
      singleton = Geometry2D()
      singleton._ptr = constructor(376,0, ())
      _Geometry2D_singleton_instance = singleton
    return _Geometry2D_singleton_instance

  @functools.native_method
  def is_point_in_circle(self, point:'Vector2'   , circle_position:'Vector2'   , circle_radius:'float'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `point` is inside the circle or if it's located exactly _on_ the circle's boundary, otherwise returns `false`.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'
    assert(not circle_position is None)
    assert isinstance(circle_position, Vector2), 'circle_position must be Vector2'
    assert isinstance(circle_radius, (int, float)), 'circle_radius must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([point._ptr, circle_position._ptr, circle_radius]))
    return _ret


  @functools.native_method
  def segment_intersects_circle(self, segment_from:'Vector2'   , segment_to:'Vector2'   , circle_position:'Vector2'   , circle_radius:'float'   ) -> typing.Union[float]:
    r'''
				Given the 2D segment (`segment_from`, `segment_to`), returns the position on the segment (as a number between 0 and 1) at which the segment hits the circle that is located at position `circle_position` and has radius `circle_radius`. If the segment does not intersect the circle, -1 is returned (this is also the case if the line extending the segment would intersect the circle, but the segment does not).
			'''

    assert(not segment_from is None)
    assert isinstance(segment_from, Vector2), 'segment_from must be Vector2'
    assert(not segment_to is None)
    assert isinstance(segment_to, Vector2), 'segment_to must be Vector2'
    assert(not circle_position is None)
    assert isinstance(circle_position, Vector2), 'circle_position must be Vector2'
    assert isinstance(circle_radius, (int, float)), 'circle_radius must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([segment_from._ptr, segment_to._ptr, circle_position._ptr, circle_radius]))
    return _ret


  @functools.native_method
  def segment_intersects_segment(self, from_a:'Vector2'   , to_a:'Vector2'   , from_b:'Vector2'   , to_b:'Vector2'   ) -> typing.Union[typing.Any]:
    r'''
				Checks if the two segments (`from_a`, `to_a`) and (`from_b`, `to_b`) intersect. If yes, return the point of intersection as `Vector2`. If no intersection takes place, returns `null`.
			'''

    assert(not from_a is None)
    assert isinstance(from_a, Vector2), 'from_a must be Vector2'
    assert(not to_a is None)
    assert isinstance(to_a, Vector2), 'to_a must be Vector2'
    assert(not from_b is None)
    assert isinstance(from_b, Vector2), 'from_b must be Vector2'
    assert(not to_b is None)
    assert isinstance(to_b, Vector2), 'to_b must be Vector2'









    _ret = None
    _ret = self._ptr.call_with_return(51,tuple([from_a._ptr, to_a._ptr, from_b._ptr, to_b._ptr]))
    return _ret


  @functools.native_method
  def line_intersects_line(self, from_a:'Vector2'   , dir_a:'Vector2'   , from_b:'Vector2'   , dir_b:'Vector2'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the point of intersection between the two lines (`from_a`, `dir_a`) and (`from_b`, `dir_b`). Returns a `Vector2`, or `null` if the lines are parallel.
				`from` and `dir` are _not_ endpoints of a line segment or ray but the slope (`dir`) and a known point (`from`) on that line.
				
				```gdscript
				var from_a = Vector2.ZERO
				var dir_a = Vector2.RIGHT
				var from_b = Vector2.DOWN

				# Returns Vector2(1, 0)
				Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2(1, -1))
				# Returns Vector2(-1, 0)
				Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2(-1, -1))
				# Returns null
				Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2.RIGHT)
				```
				
				
			'''

    assert(not from_a is None)
    assert isinstance(from_a, Vector2), 'from_a must be Vector2'
    assert(not dir_a is None)
    assert isinstance(dir_a, Vector2), 'dir_a must be Vector2'
    assert(not from_b is None)
    assert isinstance(from_b, Vector2), 'from_b must be Vector2'
    assert(not dir_b is None)
    assert isinstance(dir_b, Vector2), 'dir_b must be Vector2'









    _ret = None
    _ret = self._ptr.call_with_return(52,tuple([from_a._ptr, dir_a._ptr, from_b._ptr, dir_b._ptr]))
    return _ret


  @functools.native_method
  def get_closest_points_between_segments(self, p1:'Vector2'   , q1:'Vector2'   , p2:'Vector2'   , q2:'Vector2'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Given the two 2D segments (`p1`, `q1`) and (`p2`, `q2`), finds those two points on the two segments that are closest to each other. Returns a `PackedVector2Array` that contains this point on (`p1`, `q1`) as well the accompanying point on (`p2`, `q2`).
			'''

    assert(not p1 is None)
    assert isinstance(p1, Vector2), 'p1 must be Vector2'
    assert(not q1 is None)
    assert isinstance(q1, Vector2), 'q1 must be Vector2'
    assert(not p2 is None)
    assert isinstance(p2, Vector2), 'p2 must be Vector2'
    assert(not q2 is None)
    assert isinstance(q2, Vector2), 'q2 must be Vector2'









    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([p1._ptr, q1._ptr, p2._ptr, q2._ptr]))
    return _ret


  @functools.native_method
  def get_closest_point_to_segment(self, point:'Vector2'   , s1:'Vector2'   , s2:'Vector2'   ) -> typing.Union['Vector2']:
    r'''
				Returns the 2D point on the 2D segment (`s1`, `s2`) that is closest to `point`. The returned point will always be inside the specified segment.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'
    assert(not s1 is None)
    assert isinstance(s1, Vector2), 's1 must be Vector2'
    assert(not s2 is None)
    assert isinstance(s2, Vector2), 's2 must be Vector2'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([point._ptr, s1._ptr, s2._ptr]))
    return _ret


  @functools.native_method
  def get_closest_point_to_segment_uncapped(self, point:'Vector2'   , s1:'Vector2'   , s2:'Vector2'   ) -> typing.Union['Vector2']:
    r'''
				Returns the 2D point on the 2D line defined by (`s1`, `s2`) that is closest to `point`. The returned point can be inside the segment (`s1`, `s2`) or outside of it, i.e. somewhere on the line extending from the segment.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'
    assert(not s1 is None)
    assert isinstance(s1, Vector2), 's1 must be Vector2'
    assert(not s2 is None)
    assert isinstance(s2, Vector2), 's2 must be Vector2'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([point._ptr, s1._ptr, s2._ptr]))
    return _ret


  @functools.native_method
  def point_is_inside_triangle(self, point:'Vector2'   , a:'Vector2'   , b:'Vector2'   , c:'Vector2'   ) -> typing.Union[bool]:
    r'''
				Returns if `point` is inside the triangle specified by `a`, `b` and `c`.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'
    assert(not a is None)
    assert isinstance(a, Vector2), 'a must be Vector2'
    assert(not b is None)
    assert isinstance(b, Vector2), 'b must be Vector2'
    assert(not c is None)
    assert isinstance(c, Vector2), 'c must be Vector2'









    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([point._ptr, a._ptr, b._ptr, c._ptr]))
    return _ret


  @functools.native_method
  def is_polygon_clockwise(self, polygon:'PackedVector2Array'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `polygon`'s vertices are ordered in clockwise order, otherwise returns `false`.
				**Note:** Assumes a Cartesian coordinate system where `+x` is right and `+y` is up. If using screen coordinates (`+y` is down), the result will need to be flipped (i.e. a `true` result will indicate counter-clockwise).
			'''

    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'






    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([polygon._ptr]))
    return _ret


  @functools.native_method
  def is_point_in_polygon(self, point:'Vector2'   , polygon:'PackedVector2Array'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `point` is inside `polygon` or if it's located exactly _on_ polygon's boundary, otherwise returns `false`.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'
    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'







    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([point._ptr, polygon._ptr]))
    return _ret


  @functools.native_method
  def triangulate_polygon(self, polygon:'PackedVector2Array'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Triangulates the polygon specified by the points in `polygon`. Returns a `PackedInt32Array` where each triangle consists of three consecutive point indices into `polygon` (i.e. the returned array will have `n * 3` elements, with `n` being the number of found triangles). Output triangles will always be counter clockwise, and the contour will be flipped if it's clockwise. If the triangulation did not succeed, an empty `PackedInt32Array` is returned.
			'''

    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'






    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([polygon._ptr]))
    return _ret


  @functools.native_method
  def triangulate_delaunay(self, points:'PackedVector2Array'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Triangulates the area specified by discrete set of `points` such that no point is inside the circumcircle of any resulting triangle. Returns a `PackedInt32Array` where each triangle consists of three consecutive point indices into `points` (i.e. the returned array will have `n * 3` elements, with `n` being the number of found triangles). If the triangulation did not succeed, an empty `PackedInt32Array` is returned.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'






    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([points._ptr]))
    return _ret


  @functools.native_method
  def convex_hull(self, points:'PackedVector2Array'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Given an array of `Vector2`s, returns the convex hull as a list of points in counterclockwise order. The last point is the same as the first one.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'






    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([points._ptr]))
    return _ret


  @functools.native_method
  def decompose_polygon_in_convex(self, polygon:'PackedVector2Array'   ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Decomposes the `polygon` into multiple convex hulls and returns an array of `PackedVector2Array`.
			'''

    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'






    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([polygon._ptr]))
    return _ret


  @functools.native_method
  def merge_polygons(self, polygon_a:'PackedVector2Array'   , polygon_b:'PackedVector2Array'   ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Merges (combines) `polygon_a` and `polygon_b` and returns an array of merged polygons. This performs `constant OPERATION_UNION` between polygons.
				The operation may result in an outer polygon (boundary) and multiple inner polygons (holes) produced which could be distinguished by calling `is_polygon_clockwise`.
			'''

    assert(not polygon_a is None)
    assert isinstance(polygon_a, PackedVector2Array), 'polygon_a must be PackedVector2Array'
    assert(not polygon_b is None)
    assert isinstance(polygon_b, PackedVector2Array), 'polygon_b must be PackedVector2Array'







    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([polygon_a._ptr, polygon_b._ptr]))
    return _ret


  @functools.native_method
  def clip_polygons(self, polygon_a:'PackedVector2Array'   , polygon_b:'PackedVector2Array'   ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Clips `polygon_a` against `polygon_b` and returns an array of clipped polygons. This performs `constant OPERATION_DIFFERENCE` between polygons. Returns an empty array if `polygon_b` completely overlaps `polygon_a`.
				If `polygon_b` is enclosed by `polygon_a`, returns an outer polygon (boundary) and inner polygon (hole) which could be distinguished by calling `is_polygon_clockwise`.
			'''

    assert(not polygon_a is None)
    assert isinstance(polygon_a, PackedVector2Array), 'polygon_a must be PackedVector2Array'
    assert(not polygon_b is None)
    assert isinstance(polygon_b, PackedVector2Array), 'polygon_b must be PackedVector2Array'







    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([polygon_a._ptr, polygon_b._ptr]))
    return _ret


  @functools.native_method
  def intersect_polygons(self, polygon_a:'PackedVector2Array'   , polygon_b:'PackedVector2Array'   ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Intersects `polygon_a` with `polygon_b` and returns an array of intersected polygons. This performs `constant OPERATION_INTERSECTION` between polygons. In other words, returns common area shared by polygons. Returns an empty array if no intersection occurs.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
			'''

    assert(not polygon_a is None)
    assert isinstance(polygon_a, PackedVector2Array), 'polygon_a must be PackedVector2Array'
    assert(not polygon_b is None)
    assert isinstance(polygon_b, PackedVector2Array), 'polygon_b must be PackedVector2Array'







    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(65,tuple([polygon_a._ptr, polygon_b._ptr]))
    return _ret


  @functools.native_method
  def exclude_polygons(self, polygon_a:'PackedVector2Array'   , polygon_b:'PackedVector2Array'   ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Mutually excludes common area defined by intersection of `polygon_a` and `polygon_b` (see `intersect_polygons`) and returns an array of excluded polygons. This performs `constant OPERATION_XOR` between polygons. In other words, returns all but common area between polygons.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
			'''

    assert(not polygon_a is None)
    assert isinstance(polygon_a, PackedVector2Array), 'polygon_a must be PackedVector2Array'
    assert(not polygon_b is None)
    assert isinstance(polygon_b, PackedVector2Array), 'polygon_b must be PackedVector2Array'







    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([polygon_a._ptr, polygon_b._ptr]))
    return _ret


  @functools.native_method
  def clip_polyline_with_polygon(self, polyline:'PackedVector2Array'   , polygon:'PackedVector2Array'   ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Clips `polyline` against `polygon` and returns an array of clipped polylines. This performs `constant OPERATION_DIFFERENCE` between the polyline and the polygon. This operation can be thought of as cutting a line with a closed shape.
			'''

    assert(not polyline is None)
    assert isinstance(polyline, PackedVector2Array), 'polyline must be PackedVector2Array'
    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'







    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([polyline._ptr, polygon._ptr]))
    return _ret


  @functools.native_method
  def intersect_polyline_with_polygon(self, polyline:'PackedVector2Array'   , polygon:'PackedVector2Array'   ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Intersects `polyline` with `polygon` and returns an array of intersected polylines. This performs `constant OPERATION_INTERSECTION` between the polyline and the polygon. This operation can be thought of as chopping a line with a closed shape.
			'''

    assert(not polyline is None)
    assert isinstance(polyline, PackedVector2Array), 'polyline must be PackedVector2Array'
    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'







    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([polyline._ptr, polygon._ptr]))
    return _ret


  @functools.native_method
  def offset_polygon(self, polygon:'PackedVector2Array'   , delta:'float'   , join_type:'int'  =0) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Inflates or deflates `polygon` by `delta` units (pixels). If `delta` is positive, makes the polygon grow outward. If `delta` is negative, shrinks the polygon inward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. Returns an empty array if `delta` is negative and the absolute value of it approximately exceeds the minimum bounding rectangle dimensions of the polygon.
				Each polygon's vertices will be rounded as determined by `join_type`.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
				**Note:** To translate the polygon's vertices specifically, multiply them to a `Transform2D`:
				
				```gdscript
				var polygon = PackedVector2Array(`Vector2(0, 0), Vector2(100, 0), Vector2(100, 100), Vector2(0, 100)`)
				var offset = Vector2(50, 50)
				polygon = Transform2D(0, offset) * polygon
				print(polygon) # Prints `(50.0, 50.0), (150.0, 50.0), (150.0, 150.0), (50.0, 150.0)`
				```
				
				
			'''



    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'
    assert isinstance(delta, (int, float)), 'delta must be int or float'
    assert isinstance(join_type, (int, float)), 'join_type must be int or float'








    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(69,tuple([polygon._ptr, delta, join_type]))
    return _ret


  @functools.native_method
  def offset_polyline(self, polyline:'PackedVector2Array'   , delta:'float'   , join_type:'int'  =0, end_type:'int'  =3) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Inflates or deflates `polyline` by `delta` units (pixels), producing polygons. If `delta` is positive, makes the polyline grow outward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. If `delta` is negative, returns an empty array.
				Each polygon's vertices will be rounded as determined by `join_type`.
				Each polygon's endpoints will be rounded as determined by `end_type`.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
			'''





    assert(not polyline is None)
    assert isinstance(polyline, PackedVector2Array), 'polyline must be PackedVector2Array'
    assert isinstance(delta, (int, float)), 'delta must be int or float'
    assert isinstance(join_type, (int, float)), 'join_type must be int or float'
    assert isinstance(end_type, (int, float)), 'end_type must be int or float'









    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([polyline._ptr, delta, join_type, end_type]))
    return _ret


  @functools.native_method
  def make_atlas(self, sizes:'PackedVector2Array'   ) -> typing.Union['Dictionary']:
    r'''
				Given an array of `Vector2`s representing tiles, builds an atlas. The returned dictionary has two keys: `points` is a `PackedVector2Array` that specifies the positions of each tile, `size` contains the overall size of the whole atlas as `Vector2i`.
			'''

    assert(not sizes is None)
    assert isinstance(sizes, PackedVector2Array), 'sizes must be PackedVector2Array'






    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([sizes._ptr]))
    return _ret


  @functools.native_method
  def bresenham_line(self, from_:'Vector2i'   , to:'Vector2i'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns the `url=https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm`Bresenham line`/url` between the `from` and `to` points. A Bresenham line is a series of pixels that draws a line and is always 1-pixel thick on every row and column of the drawing (never more, never less).
				Example code to draw a line between two `Marker2D` nodes using a series of `CanvasItem.draw_rect` calls:
				```gdscript
				func _draw():
					for pixel in Geometry2D.bresenham_line($MarkerA.position, $MarkerB.position):
						draw_rect(Rect2(pixel, Vector2.ONE), Color.WHITE)
				```
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector2i), 'from_ must be Vector2i'
    assert(not to is None)
    assert isinstance(to, Vector2i), 'to must be Vector2i'







    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([from_._ptr, to._ptr]))
    return _ret



register_cast_function('Geometry2D', Geometry2D.cast)
register_class('Geometry2D', Geometry2D)
