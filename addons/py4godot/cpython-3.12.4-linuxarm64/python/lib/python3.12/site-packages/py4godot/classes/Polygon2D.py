# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.Node2D as py4godot_node2d 
from py4godot.wrappers.wrappers import CPPPolygon2DWrapper


class Polygon2D(py4godot_node2d.Node2D):
  r'''
		A Polygon2D is defined by a set of points. Each point is connected to the next, with the final point being connected to the first, resulting in a closed polygon. Polygon2Ds can be filled with color (solid or gradient) or filled with a given texture.
	'''

  @staticmethod
  def constructor():
    class_ = Polygon2D.construct_without_init()
    class_._ptr = constructor(630,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Polygon2D.construct_without_init()
    class_._ptr = constructor(630,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPolygon2DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(630,0, ())


  def generate_wrapper(self):
    return CPPPolygon2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Polygon2D.__new__(Polygon2D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Polygon2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Polygon2D.construct_without_init()
    cls._ptr = CPPPolygon2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Polygon2D.construct_without_init()
    cls._ptr = CPPPolygon2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_color()
    return _ret
  @color.setter
  def color(self,  value:'Color'):
    self.set_color(value)
  @property
  def offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_offset()
    return _ret
  @offset.setter
  def offset(self,  value:'Vector2'):
    self.set_offset(value)
  @property
  def antialiased(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_antialiased()
    return _ret
  @antialiased.setter
  def antialiased(self,  value:'bool'):
    self.set_antialiased(value)
  @property
  def texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture()
    return _ret
  @texture.setter
  def texture(self,  value:'py4godot_object.Object'):
    self.set_texture(value)
  @property
  def texture_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_texture_offset()
    return _ret
  @texture_offset.setter
  def texture_offset(self,  value:'Vector2'):
    self.set_texture_offset(value)
  @property
  def texture_scale(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_texture_scale()
    return _ret
  @texture_scale.setter
  def texture_scale(self,  value:'Vector2'):
    self.set_texture_scale(value)
  @property
  def texture_rotation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_texture_rotation()
    return _ret
  @texture_rotation.setter
  def texture_rotation(self,  value:'float'):
    self.set_texture_rotation(value)
  @property
  def skeleton(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_skeleton()
    return _ret
  @skeleton.setter
  def skeleton(self,  value:'object'):
    self.set_skeleton(value)
  @property
  def invert_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_invert_enabled()
    return _ret
  @invert_enabled.setter
  def invert_enabled(self,  value:'bool'):
    self.set_invert_enabled(value)
  @property
  def invert_border(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_invert_border()
    return _ret
  @invert_border.setter
  def invert_border(self,  value:'float'):
    self.set_invert_border(value)
  @property
  def polygon(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_polygon()
    return _ret
  @polygon.setter
  def polygon(self,  value:'PackedVector2Array'):
    self.set_polygon(value)
  @property
  def uv(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_uv()
    return _ret
  @uv.setter
  def uv(self,  value:'PackedVector2Array'):
    self.set_uv(value)
  @property
  def vertex_colors(self) -> typing.Union['PackedColorArray']:
    r''''''
    _ret = self. get_vertex_colors()
    return _ret
  @vertex_colors.setter
  def vertex_colors(self,  value:'PackedColorArray'):
    self.set_vertex_colors(value)
  @property
  def polygons(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_polygons()
    return _ret
  @polygons.setter
  def polygons(self,  value:'Array'):
    self.set_polygons(value)
  @property
  def bones(self) -> typing.Union['Array']:
    r''''''
    _ret = self. _get_bones()
    return _ret
  @bones.setter
  def bones(self,  value:'Array'):
    self._set_bones(value)
  @property
  def internal_vertex_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_internal_vertex_count()
    return _ret
  @internal_vertex_count.setter
  def internal_vertex_count(self,  value:'int'):
    self.set_internal_vertex_count(value)
  @functools.native_method
  def set_polygon(self, polygon:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'

    self.py__polygon = polygon






    self._ptr.call_with_return(303,tuple([polygon._ptr]))

  @functools.native_method
  def get_polygon(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(304,tuple([]))

    return _ret


  @functools.native_method
  def set_uv(self, uv:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not uv is None)
    assert isinstance(uv, PackedVector2Array), 'uv must be PackedVector2Array'

    self.py__uv = uv






    self._ptr.call_with_return(305,tuple([uv._ptr]))

  @functools.native_method
  def get_uv(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(306,tuple([]))

    return _ret


  @functools.native_method
  def set_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__color = color






    self._ptr.call_with_return(307,tuple([color._ptr]))

  @functools.native_method
  def get_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(308,tuple([]))

    return _ret


  @functools.native_method
  def set_polygons(self, polygons:'Array'   ) -> None:
    r''''''

    assert(not polygons is None)
    assert isinstance(polygons, Array), 'polygons must be Array'

    self.py__polygons = polygons






    self._ptr.call_with_return(309,tuple([polygons._ptr]))

  @functools.native_method
  def get_polygons(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(310,tuple([]))

    return _ret


  @functools.native_method
  def set_vertex_colors(self, vertex_colors:'PackedColorArray'   ) -> None:
    r''''''

    assert(not vertex_colors is None)
    assert isinstance(vertex_colors, PackedColorArray), 'vertex_colors must be PackedColorArray'

    self.py__vertex_colors = vertex_colors






    self._ptr.call_with_return(311,tuple([vertex_colors._ptr]))

  @functools.native_method
  def get_vertex_colors(self) -> typing.Union['PackedColorArray']:
    r''''''




    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(312,tuple([]))

    return _ret


  @functools.native_method
  def set_texture(self, texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'

    self.py__texture = texture






    self._ptr.call_with_return(313,tuple([texture._ptr]))

  @functools.native_method
  def get_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(314,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_texture_offset(self, texture_offset:'Vector2'   ) -> None:
    r''''''

    assert(not texture_offset is None)
    assert isinstance(texture_offset, Vector2), 'texture_offset must be Vector2'

    self.py__texture_offset = texture_offset






    self._ptr.call_with_return(315,tuple([texture_offset._ptr]))

  @functools.native_method
  def get_texture_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(316,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_rotation(self, texture_rotation:'float'   ) -> None:
    r''''''

    assert isinstance(texture_rotation, (int, float)), 'texture_rotation must be int or float'

    self.py__texture_rotation = texture_rotation






    self._ptr.call_with_return(317,tuple([texture_rotation]))

  @functools.native_method
  def get_texture_rotation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(318,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_scale(self, texture_scale:'Vector2'   ) -> None:
    r''''''

    assert(not texture_scale is None)
    assert isinstance(texture_scale, Vector2), 'texture_scale must be Vector2'

    self.py__texture_scale = texture_scale






    self._ptr.call_with_return(319,tuple([texture_scale._ptr]))

  @functools.native_method
  def get_texture_scale(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(320,tuple([]))

    return _ret


  @functools.native_method
  def set_invert_enabled(self, invert:'bool'   ) -> None:
    r''''''

    assert isinstance(invert, bool), 'invert must be bool'

    self.py__invert_enabled = invert






    self._ptr.call_with_return(321,tuple([invert]))

  @functools.native_method
  def get_invert_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([]))

    return _ret


  @functools.native_method
  def set_antialiased(self, antialiased:'bool'   ) -> None:
    r''''''

    assert isinstance(antialiased, bool), 'antialiased must be bool'

    self.py__antialiased = antialiased






    self._ptr.call_with_return(323,tuple([antialiased]))

  @functools.native_method
  def get_antialiased(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(324,tuple([]))

    return _ret


  @functools.native_method
  def set_invert_border(self, invert_border:'float'   ) -> None:
    r''''''

    assert isinstance(invert_border, (int, float)), 'invert_border must be int or float'

    self.py__invert_border = invert_border






    self._ptr.call_with_return(325,tuple([invert_border]))

  @functools.native_method
  def get_invert_border(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(326,tuple([]))

    return _ret


  @functools.native_method
  def set_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'

    self.py__offset = offset






    self._ptr.call_with_return(327,tuple([offset._ptr]))

  @functools.native_method
  def get_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(328,tuple([]))

    return _ret


  @functools.native_method
  def add_bone(self, path:'object'   , weights:'PackedFloat32Array'   ) -> None:
    r'''
				Adds a bone with the specified `path` and `weights`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'
    assert(not weights is None)
    assert isinstance(weights, PackedFloat32Array), 'weights must be PackedFloat32Array'




    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)


    self._ptr.call_with_return(329,tuple([py_nodepath_path._ptr, weights._ptr]))

  @functools.native_method
  def get_bone_count(self) -> typing.Union[int]:
    r'''
				Returns the number of bones in this `Polygon2D`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(330,tuple([]))
    return _ret


  @functools.native_method
  def get_bone_path(self, index:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the path to the node associated with the specified bone.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(331,tuple([index]))
    return _ret


  @functools.native_method
  def get_bone_weights(self, index:'int'   ) -> typing.Union['PackedFloat32Array']:
    r'''
				Returns the weight values of the specified bone.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(332,tuple([index]))
    return _ret


  @functools.native_method
  def erase_bone(self, index:'int'   ) -> None:
    r'''
				Removes the specified bone from this `Polygon2D`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(333,tuple([index]))

  @functools.native_method
  def clear_bones(self) -> None:
    r'''
				Removes all bones from this `Polygon2D`.
			'''




    self._ptr.call_with_return(334,tuple([]))

  @functools.native_method
  def set_bone_path(self, index:'int'   , path:'object'   ) -> None:
    r'''
				Sets the path to the node associated with the specified bone.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'





    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)

    self._ptr.call_with_return(335,tuple([index, py_nodepath_path._ptr]))

  @functools.native_method
  def set_bone_weights(self, index:'int'   , weights:'PackedFloat32Array'   ) -> None:
    r'''
				Sets the weight values for the specified bone.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not weights is None)
    assert isinstance(weights, PackedFloat32Array), 'weights must be PackedFloat32Array'







    self._ptr.call_with_return(336,tuple([index, weights._ptr]))

  @functools.native_method
  def set_skeleton(self, skeleton:'object'   ) -> None:
    r''''''

    assert(not skeleton is None)
    assert isinstance(skeleton, (str, NodePath)), 'skeleton must be str or NodePath'

    self.py__skeleton = skeleton



    assert(isinstance(skeleton, (str, NodePath)))
    py_nodepath_skeleton = skeleton if isinstance(skeleton,NodePath) else NodePath.new2(skeleton)


    self._ptr.call_with_return(337,tuple([py_nodepath_skeleton._ptr]))

  @functools.native_method
  def get_skeleton(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(338,tuple([]))

    return _ret


  @functools.native_method
  def set_internal_vertex_count(self, internal_vertex_count:'int'   ) -> None:
    r''''''

    assert isinstance(internal_vertex_count, (int, float)), 'internal_vertex_count must be int or float'

    self.py__internal_vertex_count = internal_vertex_count






    self._ptr.call_with_return(339,tuple([internal_vertex_count]))

  @functools.native_method
  def get_internal_vertex_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(340,tuple([]))

    return _ret



register_cast_function('Polygon2D', Polygon2D.cast)
register_class('Polygon2D', Polygon2D)
