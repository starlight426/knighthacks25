# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.ArrayTypedArray as py4godot_arraytypedarray 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
import py4godot.classes.ArrayTypedArray as py4godot_arraytypedarray 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPImporterMeshWrapper


class ImporterMesh(py4godot_resource.Resource):
  r'''
		ImporterMesh is a type of `Resource` analogous to `ArrayMesh`. It contains vertex array-based geometry, divided in _surfaces_. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
		Unlike its runtime counterpart, `ImporterMesh` contains mesh data before various import steps, such as lod and shadow mesh generation, have taken place. Modify surface data by calling `clear`, followed by `add_surface` for each surface.
	'''

  @staticmethod
  def constructor():
    class_ = ImporterMesh.construct_without_init()
    class_._ptr = constructor(410,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ImporterMesh.construct_without_init()
    class_._ptr = constructor(410,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPImporterMeshWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(410,0, ())


  def generate_wrapper(self):
    return CPPImporterMeshWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ImporterMesh.__new__(ImporterMesh)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ImporterMesh'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ImporterMesh.construct_without_init()
    cls._ptr = CPPImporterMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ImporterMesh.construct_without_init()
    cls._ptr = CPPImporterMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def add_blend_shape(self, name:'str'   ) -> None:
    r'''
				Adds name for a blend shape that will be added with `add_surface`. Must be called before surface is added.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(77,tuple([py_string_name._ptr]))

  @functools.native_method
  def get_blend_shape_count(self) -> typing.Union[int]:
    r'''
				Returns the number of blend shapes that the mesh holds.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def get_blend_shape_name(self, blend_shape_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the blend shape at this index.
			'''

    assert isinstance(blend_shape_idx, (int, float)), 'blend_shape_idx must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([blend_shape_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_blend_shape_mode(self, mode:'int'  ) -> None:
    r'''
				Sets the blend shape mode.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'






    self._ptr.call_with_return(80,tuple([mode]))

  @functools.native_method
  def get_blend_shape_mode(self) -> typing.Union[int]:
    r'''
				Returns the blend shape mode for this Mesh.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def add_surface(self, primitive:'int'  , arrays:'Array'   , blend_shapes:'py4godot_arraytypedarray.ArrayTypedArray' = None  , lods:'Dictionary' = None  , material:'py4godot_material.Material' = None  , name:'str' =""  , flags:'int' =0  ) -> None:
    r'''
				Creates a new surface. `Mesh.get_surface_count` will become the `surf_idx` for this new surface.
				Surfaces are created to be rendered using a `primitive`, which may be any of the values defined in `enum Mesh.PrimitiveType`.
				The `arrays` argument is an array of arrays. Each of the `constant Mesh.ARRAY_MAX` elements contains an array with some of the mesh data for this surface as described by the corresponding member of `enum Mesh.ArrayType` or `null` if it is not used by the surface. For example, `arrays`0`` is the array of vertices. That first vertex sub-array is always required; the others are optional. Adding an index array puts this surface into "index mode" where the vertex and other arrays become the sources of data and the index array defines the vertex order. All sub-arrays must have the same length as the vertex array (or be an exact multiple of the vertex array's length, when multiple elements of a sub-array correspond to a single vertex) or be empty, except for `constant Mesh.ARRAY_INDEX` if it is used.
				The `blend_shapes` argument is an array of vertex data for each blend shape. Each element is an array of the same structure as `arrays`, but `constant Mesh.ARRAY_VERTEX`, `constant Mesh.ARRAY_NORMAL`, and `constant Mesh.ARRAY_TANGENT` are set if and only if they are set in `arrays` and all other entries are `null`.
				The `lods` argument is a dictionary with `float` keys and `PackedInt32Array` values. Each entry in the dictionary represents an LOD level of the surface, where the value is the `constant Mesh.ARRAY_INDEX` array to use for the LOD level and the key is roughly proportional to the distance at which the LOD stats being used. I.e., increasing the key of an LOD also increases the distance that the objects has to be from the camera before the LOD is used.
				The `flags` argument is the bitwise OR of, as required: One value of `enum Mesh.ArrayCustomFormat` left shifted by `ARRAY_FORMAT_CUSTOMn_SHIFT` for each custom channel in use, `constant Mesh.ARRAY_FLAG_USE_DYNAMIC_UPDATE`, `constant Mesh.ARRAY_FLAG_USE_8_BONE_WEIGHTS`, or `constant Mesh.ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY`.
				**Note:** When using indices, it is recommended to only use points, lines, or triangles.
			'''

    if lods is None:
      lods = Dictionary.new0()
    if material is None:
      material = c_utils.empty_object
    if name is None:
      name = String.new0()

    if lods is None:
      lods = Dictionary.new0()
    if material is None:
      material = c_utils.empty_object
    if name is None:
      name = String.new0()

    assert isinstance(primitive, (int, float)), 'primitive must be int or float'
    assert(not arrays is None)
    assert isinstance(arrays, Array), 'arrays must be Array'
    assert isinstance(blend_shapes, get_class('ArrayTypedArray')), 'blend_shapes must be ArrayTypedArray'
    assert isinstance(flags, (int, float)), 'flags must be int or float'









    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(82,tuple([primitive, arrays._ptr, blend_shapes._ptr, lods._ptr, material._ptr, py_string_name._ptr, flags]))

  @functools.native_method
  def get_surface_count(self) -> typing.Union[int]:
    r'''
				Returns the number of surfaces that the mesh holds.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def get_surface_primitive_type(self, surface_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the primitive type of the requested surface (see `add_surface`).
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(84,tuple([surface_idx]))
    return _ret


  @functools.native_method
  def get_surface_name(self, surface_idx:'int'   ) -> typing.Union[str]:
    r'''
				Gets the name assigned to this surface.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([surface_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_surface_arrays(self, surface_idx:'int'   ) -> typing.Union['Array']:
    r'''
				Returns the arrays for the vertices, normals, UVs, etc. that make up the requested surface. See `add_surface`.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'






    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([surface_idx]))
    return _ret


  @functools.native_method
  def get_surface_blend_shape_arrays(self, surface_idx:'int'   , blend_shape_idx:'int'   ) -> typing.Union['Array']:
    r'''
				Returns a single set of blend shape arrays for the requested blend shape index for a surface.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'
    assert isinstance(blend_shape_idx, (int, float)), 'blend_shape_idx must be int or float'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([surface_idx, blend_shape_idx]))
    return _ret


  @functools.native_method
  def get_surface_lod_count(self, surface_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of lods that the mesh holds on a given surface.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([surface_idx]))
    return _ret


  @functools.native_method
  def get_surface_lod_size(self, surface_idx:'int'   , lod_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the screen ratio which activates a lod for a surface.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'
    assert isinstance(lod_idx, (int, float)), 'lod_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([surface_idx, lod_idx]))
    return _ret


  @functools.native_method
  def get_surface_lod_indices(self, surface_idx:'int'   , lod_idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns the index buffer of a lod for a surface.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'
    assert isinstance(lod_idx, (int, float)), 'lod_idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([surface_idx, lod_idx]))
    return _ret


  @functools.native_method
  def get_surface_material(self, surface_idx:'int'   ) -> typing.Any:
    r'''
				Returns a `Material` in a given surface. Surface is rendered using this material.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(91,tuple([surface_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_surface_format(self, surface_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the format of the surface that the mesh holds.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([surface_idx]))
    return _ret


  @functools.native_method
  def set_surface_name(self, surface_idx:'int'   , name:'str'   ) -> None:
    r'''
				Sets a name for a given surface.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(93,tuple([surface_idx, py_string_name._ptr]))

  @functools.native_method
  def set_surface_material(self, surface_idx:'int'   , material:'py4godot_material.Material'   ) -> None:
    r'''
				Sets a `Material` for a given surface. Surface will be rendered using this material.
			'''

    assert isinstance(surface_idx, (int, float)), 'surface_idx must be int or float'
    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'







    self._ptr.call_with_return(94,tuple([surface_idx, material._ptr]))

  @functools.native_method
  def generate_lods(self, normal_merge_angle:'float'   , normal_split_angle:'float'   , bone_transform_array:'Array'   ) -> None:
    r'''
				Generates all lods for this ImporterMesh.
				`normal_merge_angle` is in degrees and used in the same way as the importer settings in `lods`.
				`normal_split_angle` is not used and only remains for compatibility with older versions of the API.
				The number of generated lods can be accessed using `get_surface_lod_count`, and each LOD is available in `get_surface_lod_size` and `get_surface_lod_indices`.
				`bone_transform_array` is an `Array` which can be either empty or contain `Transform3D`s which, for each of the mesh's bone IDs, will apply mesh skinning when generating the LOD mesh variations. This is usually used to account for discrepancies in scale between the mesh itself and its skinning data.
			'''

    assert isinstance(normal_merge_angle, (int, float)), 'normal_merge_angle must be int or float'
    assert isinstance(normal_split_angle, (int, float)), 'normal_split_angle must be int or float'
    assert(not bone_transform_array is None)
    assert isinstance(bone_transform_array, Array), 'bone_transform_array must be Array'








    self._ptr.call_with_return(95,tuple([normal_merge_angle, normal_split_angle, bone_transform_array._ptr]))

  @functools.native_method
  def get_mesh(self, base_mesh:'py4godot_arraymesh.ArrayMesh' = None  ) -> typing.Union['py4godot_arraymesh.ArrayMesh']:
    r'''
				Returns the mesh data represented by this `ImporterMesh` as a usable `ArrayMesh`.
				This method caches the returned mesh, and subsequent calls will return the cached data until `clear` is called.
				If not yet cached and `base_mesh` is provided, `base_mesh` will be used and mutated.
			'''
    if base_mesh is None:
      base_mesh = c_utils.empty_object
    if base_mesh is None:
      base_mesh = c_utils.empty_object







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ArrayMesh
    _ret._ptr = self._ptr.call_with_return(96,tuple([base_mesh._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def clear(self) -> None:
    r'''
				Removes all surfaces and blend shapes from this `ImporterMesh`.
			'''




    self._ptr.call_with_return(97,tuple([]))

  @functools.native_method
  def set_lightmap_size_hint(self, size:'Vector2i'   ) -> None:
    r'''
				Sets the size hint of this mesh for lightmap-unwrapping in UV-space.
			'''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'






    self._ptr.call_with_return(98,tuple([size._ptr]))

  @functools.native_method
  def get_lightmap_size_hint(self) -> typing.Union['Vector2i']:
    r'''
				Returns the size hint of this mesh for lightmap-unwrapping in UV-space.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([]))
    return _ret



register_cast_function('ImporterMesh', ImporterMesh.cast)
register_class('ImporterMesh', ImporterMesh)
