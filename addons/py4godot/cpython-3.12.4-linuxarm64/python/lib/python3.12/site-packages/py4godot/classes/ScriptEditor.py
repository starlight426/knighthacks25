# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Script as py4godot_script 
  import py4godot.classes.ScriptTypedArray as py4godot_scripttypedarray 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.EditorSyntaxHighlighter as py4godot_editorsyntaxhighlighter 
  import py4godot.classes.GDScript as py4godot_gdscript 
  import py4godot.classes.ScriptExtension as py4godot_scriptextension 
  import py4godot.classes.ScriptEditorBaseTypedArray as py4godot_scripteditorbasetypedarray 
import py4godot.classes.PanelContainer as py4godot_panelcontainer 
import py4godot.classes.ScriptTypedArray as py4godot_scripttypedarray 
import py4godot.classes.ScriptEditorBaseTypedArray as py4godot_scripteditorbasetypedarray 
from py4godot.wrappers.wrappers import CPPScriptEditorWrapper


class ScriptEditor(py4godot_panelcontainer.PanelContainer):
  r'''
		Godot editor's script editor.
		**Note:** This class shouldn't be instantiated directly. Instead, access the singleton using `EditorInterface.get_script_editor`.
	'''

  @staticmethod
  def constructor():
    class_ = ScriptEditor.construct_without_init()
    class_._ptr = constructor(724,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ScriptEditor.construct_without_init()
    class_._ptr = constructor(724,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPScriptEditorWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(724,0, ())


  def generate_wrapper(self):
    return CPPScriptEditorWrapper()
  def init_signals(self):
    super().init_signals()
    editor_script_changed_name = utils.py_string_to_string_name("editor_script_changed")
    self.editor_script_changed = signals.BuiltinSignal(self, editor_script_changed_name)
    script_close_name = utils.py_string_to_string_name("script_close")
    self.script_close = signals.BuiltinSignal(self, script_close_name)

  @staticmethod
  def construct_without_init():
    cls = ScriptEditor.__new__(ScriptEditor)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ScriptEditor'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ScriptEditor.construct_without_init()
    cls._ptr = CPPScriptEditorWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ScriptEditor.construct_without_init()
    cls._ptr = CPPScriptEditorWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def get_current_editor(self) -> typing.Union['py4godot_scripteditorbase.ScriptEditorBase']:
    r'''
				Returns the `ScriptEditorBase` object that the user is currently editing.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ScriptEditorBase
    _ret._ptr = self._ptr.call_with_return(437,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_open_script_editors(self) -> typing.Union['py4godot_scripteditorbasetypedarray.ScriptEditorBaseTypedArray']:
    r'''
				Returns an array with all `ScriptEditorBase` objects which are currently open in editor.
			'''




    _ret = py4godot_scripteditorbasetypedarray.ScriptEditorBaseTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(438,tuple([]))
    return _ret


  @functools.native_method
  def get_breakpoints(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns array of breakpoints.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(439,tuple([]))
    return _ret


  @functools.native_method
  def register_syntax_highlighter(self, syntax_highlighter:'py4godot_editorsyntaxhighlighter.EditorSyntaxHighlighter'   ) -> None:
    r'''
				Registers the `EditorSyntaxHighlighter` to the editor, the `EditorSyntaxHighlighter` will be available on all open scripts.
				**Note:** Does not apply to scripts that are already opened.
			'''

    assert(not syntax_highlighter is None)
    assert isinstance(syntax_highlighter, get_class('EditorSyntaxHighlighter')), 'syntax_highlighter must be EditorSyntaxHighlighter'






    self._ptr.call_with_return(440,tuple([syntax_highlighter._ptr]))

  @functools.native_method
  def unregister_syntax_highlighter(self, syntax_highlighter:'py4godot_editorsyntaxhighlighter.EditorSyntaxHighlighter'   ) -> None:
    r'''
				Unregisters the `EditorSyntaxHighlighter` from the editor.
				**Note:** The `EditorSyntaxHighlighter` will still be applied to scripts that are already opened.
			'''

    assert(not syntax_highlighter is None)
    assert isinstance(syntax_highlighter, get_class('EditorSyntaxHighlighter')), 'syntax_highlighter must be EditorSyntaxHighlighter'






    self._ptr.call_with_return(441,tuple([syntax_highlighter._ptr]))

  @functools.native_method
  def goto_line(self, line_number:'int'   ) -> None:
    r'''
				Goes to the specified line in the current script.
			'''

    assert isinstance(line_number, (int, float)), 'line_number must be int or float'






    self._ptr.call_with_return(442,tuple([line_number]))

  @functools.native_method
  def get_current_script(self) -> typing.Union['py4godot_script.Script','py4godot_gdscript.GDScript','py4godot_scriptextension.ScriptExtension']:
    r'''
				Returns a `Script` that is currently active in editor.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Script
    _ret._ptr = self._ptr.call_with_return(443,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_open_scripts(self) -> typing.Union['py4godot_scripttypedarray.ScriptTypedArray']:
    r'''
				Returns an array with all `Script` objects which are currently open in editor.
			'''




    _ret = py4godot_scripttypedarray.ScriptTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(444,tuple([]))
    return _ret


  @functools.native_method
  def open_script_create_dialog(self, base_name:'str'   , base_path:'str'   ) -> None:
    r'''
				Opens the script create dialog. The script will extend `base_name`. The file extension can be omitted from `base_path`. It will be added based on the selected scripting language.
			'''

    assert(not base_name is None)
    assert isinstance(base_name, (str, String)), 'base_name must be str or String'
    assert(not base_path is None)
    assert isinstance(base_path, (str, String)), 'base_path must be str or String'




    assert(isinstance(base_name, (str, String)))
    py_string_base_name = base_name if isinstance(base_name, StringName) else c_utils.py_string_to_string(base_name)
    assert(isinstance(base_path, (str, String)))
    py_string_base_path = base_path if isinstance(base_path, StringName) else c_utils.py_string_to_string(base_path)

    self._ptr.call_with_return(445,tuple([py_string_base_name._ptr, py_string_base_path._ptr]))

  @functools.native_method
  def goto_help(self, topic:'str'   ) -> None:
    r'''
				Opens help for the given topic. The `topic` is an encoded string that controls which class, method, constant, signal, annotation, property, or theme item should be focused.
				The supported `topic` formats include `class_name:class`, `class_method:class:method`, `class_constant:class:constant`, `class_signal:class:signal`, `class_annotation:class:@annotation`, `class_property:class:property`, and `class_theme_item:class:item`, where `class` is the class name, `method` is the method name, `constant` is the constant name, `signal` is the signal name, `annotation` is the annotation name, `property` is the property name, and `item` is the theme item.
				```gdscript
				# Shows help for the Node class.
				class_name:Node
				# Shows help for the global min function.
				# Global objects are accessible in the `@GlobalScope` namespace, shown here.
				class_method:@GlobalScope:min
				# Shows help for get_viewport in the Node class.
				class_method:Node:get_viewport
				# Shows help for the Input constant MOUSE_BUTTON_MIDDLE.
				class_constant:Input:MOUSE_BUTTON_MIDDLE
				# Shows help for the BaseButton signal pressed.
				class_signal:BaseButton:pressed
				# Shows help for the CanvasItem property visible.
				class_property:CanvasItem:visible
				# Shows help for the GDScript annotation export.
				# Annotations should be prefixed with the `@` symbol in the descriptor, as shown here.
				class_annotation:@GDScript:@export
				# Shows help for the GraphNode theme item named panel_selected.
				class_theme_item:GraphNode:panel_selected
				```
			'''

    assert(not topic is None)
    assert isinstance(topic, (str, String)), 'topic must be str or String'




    assert(isinstance(topic, (str, String)))
    py_string_topic = topic if isinstance(topic, StringName) else c_utils.py_string_to_string(topic)

    self._ptr.call_with_return(446,tuple([py_string_topic._ptr]))

  @functools.native_method
  def update_docs_from_script(self, script:'py4godot_script.Script'   ) -> None:
    r'''
				Updates the documentation for the given `script`.
				**Note:** This should be called whenever the script is changed to keep the open documentation state up to date.
			'''

    assert(not script is None)
    assert isinstance(script, get_class('Script')), 'script must be Script'






    self._ptr.call_with_return(447,tuple([script._ptr]))

  @functools.native_method
  def clear_docs_from_script(self, script:'py4godot_script.Script'   ) -> None:
    r'''
				Removes the documentation for the given `script`.
				**Note:** This should be called whenever the script is changed to keep the open documentation state up to date.
			'''

    assert(not script is None)
    assert isinstance(script, get_class('Script')), 'script must be Script'






    self._ptr.call_with_return(448,tuple([script._ptr]))


register_cast_function('ScriptEditor', ScriptEditor.cast)
register_class('ScriptEditor', ScriptEditor)
