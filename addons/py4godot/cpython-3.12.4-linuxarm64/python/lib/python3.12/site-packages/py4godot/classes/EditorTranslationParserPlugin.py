# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PackedStringArrayTypedArray as py4godot_packedstringarraytypedarray 
import py4godot.classes.PackedStringArrayTypedArray as py4godot_packedstringarraytypedarray 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPEditorTranslationParserPluginWrapper


class EditorTranslationParserPlugin(py4godot_refcounted.RefCounted):
  r'''
		`EditorTranslationParserPlugin` is invoked when a file is being parsed to extract strings that require translation. To define the parsing and string extraction logic, override the `_parse_file` method in script.
		The return value should be an `Array` of `PackedStringArray`s, one for each extracted translatable string. Each entry should contain ``msgid, msgctxt, msgid_plural, comment``, where all except `msgid` are optional. Empty strings will be ignored.
		The extracted strings will be written into a POT file selected by user under "POT Generation" in "Localization" tab in "Project Settings" menu.
		Below shows an example of a custom parser that extracts strings from a CSV file to write into a POT.
		
		```gdscript
		@tool
		extends EditorTranslationParserPlugin

		func _parse_file(path):
			var ret: Array`PackedStringArray` = ``
			var file = FileAccess.open(path, FileAccess.READ)
			var text = file.get_as_text()
			var split_strs = text.split(",", false)
			for s in split_strs:
				ret.append(PackedStringArray(`s`))
				#print("Extracted string: " + s)

			return ret

		func _get_recognized_extensions():
			return `"csv"`
		```
		
		
		To add a translatable string associated with a context, plural, or comment:
		
		```gdscript
		# This will add a message with msgid "Test 1", msgctxt "context", msgid_plural "test 1 plurals", and comment "test 1 comment".
		ret.append(PackedStringArray(`"Test 1", "context", "test 1 plurals", "test 1 comment"`))
		# This will add a message with msgid "A test without context" and msgid_plural "plurals".
		ret.append(PackedStringArray(`"A test without context", "", "plurals"`))
		# This will add a message with msgid "Only with context" and msgctxt "a friendly context".
		ret.append(PackedStringArray(`"Only with context", "a friendly context"`))
		```
		
		
		**Note:** If you override parsing logic for standard script types (GDScript, C#, etc.), it would be better to load the `path` argument using `ResourceLoader.load`. This is because built-in scripts are loaded as `Resource` type, not `FileAccess` type. For example:
		
		```gdscript
		func _parse_file(path):
			var res = ResourceLoader.load(path, "Script")
			var text = res.source_code
			# Parsing logic.

		func _get_recognized_extensions():
			return `"gd"`
		```
		
		
		To use `EditorTranslationParserPlugin`, register it using the `EditorPlugin.add_translation_parser_plugin` method first.
	'''

  @staticmethod
  def constructor():
    class_ = EditorTranslationParserPlugin.construct_without_init()
    class_._ptr = constructor(316,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorTranslationParserPlugin.construct_without_init()
    class_._ptr = constructor(316,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorTranslationParserPluginWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(316,0, ())


  def generate_wrapper(self):
    return CPPEditorTranslationParserPluginWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorTranslationParserPlugin.__new__(EditorTranslationParserPlugin)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorTranslationParserPlugin'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorTranslationParserPlugin.construct_without_init()
    cls._ptr = CPPEditorTranslationParserPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorTranslationParserPlugin.construct_without_init()
    cls._ptr = CPPEditorTranslationParserPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _parse_file(self, path:'str'   ) -> typing.Union['py4godot_packedstringarraytypedarray.PackedStringArrayTypedArray']:
    r'''
				Override this method to define a custom parsing logic to extract the translatable strings.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = py4godot_packedstringarraytypedarray.PackedStringArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def _get_recognized_extensions(self) -> typing.Union['PackedStringArray']:
    r'''
				Gets the list of file extensions to associate with this parser, e.g. ``"csv"``.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return _ret



register_cast_function('EditorTranslationParserPlugin', EditorTranslationParserPlugin.cast)
register_class('EditorTranslationParserPlugin', EditorTranslationParserPlugin)
