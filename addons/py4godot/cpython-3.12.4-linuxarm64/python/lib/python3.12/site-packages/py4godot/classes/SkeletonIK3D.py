# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
from py4godot.wrappers.wrappers import CPPSkeletonIK3DWrapper


class SkeletonIK3D(py4godot_skeletonmodifier3d.SkeletonModifier3D):
  r'''
		SkeletonIK3D is used to rotate all bones of a `Skeleton3D` bone chain a way that places the end bone at a desired 3D position. A typical scenario for IK in games is to place a character's feet on the ground or a character's hands on a currently held object. SkeletonIK uses FabrikInverseKinematic internally to solve the bone chain and applies the results to the `Skeleton3D` `bones_global_pose_override` property for all affected bones in the chain. If fully applied, this overwrites any bone transform from `Animation`s or bone custom poses set by users. The applied amount can be controlled with the `SkeletonModifier3D.influence` property.
		```gdscript
		# Apply IK effect automatically on every new frame (not the current)
		skeleton_ik_node.start()

		# Apply IK effect only on the current frame
		skeleton_ik_node.start(true)

		# Stop IK effect and reset bones_global_pose_override on Skeleton
		skeleton_ik_node.stop()

		# Apply full IK effect
		skeleton_ik_node.set_influence(1.0)

		# Apply half IK effect
		skeleton_ik_node.set_influence(0.5)

		# Apply zero IK effect (a value at or below 0.01 also removes bones_global_pose_override on Skeleton)
		skeleton_ik_node.set_influence(0.0)
		```
	'''

  @staticmethod
  def constructor():
    class_ = SkeletonIK3D.construct_without_init()
    class_._ptr = constructor(748,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SkeletonIK3D.construct_without_init()
    class_._ptr = constructor(748,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeletonIK3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(748,0, ())


  def generate_wrapper(self):
    return CPPSkeletonIK3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SkeletonIK3D.__new__(SkeletonIK3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SkeletonIK3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonIK3D.construct_without_init()
    cls._ptr = CPPSkeletonIK3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonIK3D.construct_without_init()
    cls._ptr = CPPSkeletonIK3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def root_bone(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_root_bone()
    return _ret
  @root_bone.setter
  def root_bone(self,  value:'object'):
    self.set_root_bone(value)
  @property
  def tip_bone(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_tip_bone()
    return _ret
  @tip_bone.setter
  def tip_bone(self,  value:'object'):
    self.set_tip_bone(value)
  @property
  def target(self) -> typing.Union['Transform3D']:
    r''''''
    _ret = self. get_target_transform()
    return _ret
  @target.setter
  def target(self,  value:'Transform3D'):
    self.set_target_transform(value)
  @property
  def override_tip_basis(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_override_tip_basis()
    return _ret
  @override_tip_basis.setter
  def override_tip_basis(self,  value:'bool'):
    self.set_override_tip_basis(value)
  @property
  def use_magnet(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_magnet()
    return _ret
  @use_magnet.setter
  def use_magnet(self,  value:'bool'):
    self.set_use_magnet(value)
  @property
  def magnet(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_magnet_position()
    return _ret
  @magnet.setter
  def magnet(self,  value:'Vector3'):
    self.set_magnet_position(value)
  @property
  def target_node(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_target_node()
    return _ret
  @target_node.setter
  def target_node(self,  value:'object'):
    self.set_target_node(value)
  @property
  def min_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_min_distance()
    return _ret
  @min_distance.setter
  def min_distance(self,  value:'float'):
    self.set_min_distance(value)
  @property
  def max_iterations(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_iterations()
    return _ret
  @max_iterations.setter
  def max_iterations(self,  value:'int'):
    self.set_max_iterations(value)
  @property
  def interpolation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_interpolation()
    return _ret
  @interpolation.setter
  def interpolation(self,  value:'float'):
    self.set_interpolation(value)
  @functools.native_method
  def set_root_bone(self, root_bone:'object'   ) -> None:
    r''''''

    assert(not root_bone is None)
    assert isinstance(root_bone, (str, StringName)), 'root_bone must be str or StringName'

    self.py__root_bone = root_bone



    assert(isinstance(root_bone, (str, StringName)))
    py_stringname_root_bone = root_bone if isinstance(root_bone, StringName) else c_utils.py_string_to_string_name(root_bone)


    self._ptr.call_with_return(260,tuple([py_stringname_root_bone._ptr]))

  @functools.native_method
  def get_root_bone(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(261,tuple([]))

    return _ret


  @functools.native_method
  def set_tip_bone(self, tip_bone:'object'   ) -> None:
    r''''''

    assert(not tip_bone is None)
    assert isinstance(tip_bone, (str, StringName)), 'tip_bone must be str or StringName'

    self.py__tip_bone = tip_bone



    assert(isinstance(tip_bone, (str, StringName)))
    py_stringname_tip_bone = tip_bone if isinstance(tip_bone, StringName) else c_utils.py_string_to_string_name(tip_bone)


    self._ptr.call_with_return(262,tuple([py_stringname_tip_bone._ptr]))

  @functools.native_method
  def get_tip_bone(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(263,tuple([]))

    return _ret


  @functools.native_method
  def set_target_transform(self, target:'Transform3D'   ) -> None:
    r''''''

    assert(not target is None)
    assert isinstance(target, Transform3D), 'target must be Transform3D'

    self.py__target = target






    self._ptr.call_with_return(264,tuple([target._ptr]))

  @functools.native_method
  def get_target_transform(self) -> typing.Union['Transform3D']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_target_node(self, node:'object'   ) -> None:
    r''''''

    assert(not node is None)
    assert isinstance(node, (str, NodePath)), 'node must be str or NodePath'

    self.py__target_node = node



    assert(isinstance(node, (str, NodePath)))
    py_nodepath_node = node if isinstance(node,NodePath) else NodePath.new2(node)


    self._ptr.call_with_return(266,tuple([py_nodepath_node._ptr]))

  @functools.native_method
  def get_target_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(267,tuple([]))

    return _ret


  @functools.native_method
  def set_override_tip_basis(self, override:'bool'   ) -> None:
    r''''''

    assert isinstance(override, bool), 'override must be bool'

    self.py__override_tip_basis = override






    self._ptr.call_with_return(268,tuple([override]))

  @functools.native_method
  def is_override_tip_basis(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_use_magnet(self, use:'bool'   ) -> None:
    r''''''

    assert isinstance(use, bool), 'use must be bool'

    self.py__use_magnet = use






    self._ptr.call_with_return(270,tuple([use]))

  @functools.native_method
  def is_using_magnet(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_magnet_position(self, local_position:'Vector3'   ) -> None:
    r''''''

    assert(not local_position is None)
    assert isinstance(local_position, Vector3), 'local_position must be Vector3'

    self.py__magnet = local_position






    self._ptr.call_with_return(272,tuple([local_position._ptr]))

  @functools.native_method
  def get_magnet_position(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def get_parent_skeleton(self) -> typing.Union['py4godot_skeleton3d.Skeleton3D']:
    r'''
				Returns the parent `Skeleton3D` node that was present when SkeletonIK entered the scene tree. Returns `null` if the parent node was not a `Skeleton3D` node when SkeletonIK3D entered the scene tree.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Skeleton3D
    _ret._ptr = self._ptr.call_with_return(274,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_running(self) -> typing.Union[bool]:
    r'''
				Returns `true` if SkeletonIK is applying IK effects on continues frames to the `Skeleton3D` bones. Returns `false` if SkeletonIK is stopped or `start` was used with the `one_time` parameter set to `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(275,tuple([]))
    return _ret


  @functools.native_method
  def set_min_distance(self, min_distance:'float'   ) -> None:
    r''''''

    assert isinstance(min_distance, (int, float)), 'min_distance must be int or float'

    self.py__min_distance = min_distance






    self._ptr.call_with_return(276,tuple([min_distance]))

  @functools.native_method
  def get_min_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))

    return _ret


  @functools.native_method
  def set_max_iterations(self, iterations:'int'   ) -> None:
    r''''''

    assert isinstance(iterations, (int, float)), 'iterations must be int or float'

    self.py__max_iterations = iterations






    self._ptr.call_with_return(278,tuple([iterations]))

  @functools.native_method
  def get_max_iterations(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def start(self, one_time:'bool' =False  ) -> None:
    r'''
				Starts applying IK effects on each frame to the `Skeleton3D` bones but will only take effect starting on the next frame. If `one_time` is `true`, this will take effect immediately but also reset on the next frame.
			'''

    assert isinstance(one_time, bool), 'one_time must be bool'






    self._ptr.call_with_return(280,tuple([one_time]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops applying IK effects on each frame to the `Skeleton3D` bones and also calls `Skeleton3D.clear_bones_global_pose_override` to remove existing overrides on all bones.
			'''




    self._ptr.call_with_return(281,tuple([]))

  @functools.native_method
  def set_interpolation(self, interpolation:'float'   ) -> None:
    r''''''

    assert isinstance(interpolation, (int, float)), 'interpolation must be int or float'

    self.py__interpolation = interpolation






    self._ptr.call_with_return(282,tuple([interpolation]))

  @functools.native_method
  def get_interpolation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(283,tuple([]))

    return _ret



register_cast_function('SkeletonIK3D', SkeletonIK3D.cast)
register_class('SkeletonIK3D', SkeletonIK3D)
