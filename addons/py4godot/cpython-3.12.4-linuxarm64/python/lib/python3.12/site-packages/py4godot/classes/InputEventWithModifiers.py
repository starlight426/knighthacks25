# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.InputEventFromWindow as py4godot_inputeventfromwindow 
from py4godot.wrappers.wrappers import CPPInputEventWithModifiersWrapper


class InputEventWithModifiers(py4godot_inputeventfromwindow.InputEventFromWindow):
  r'''
		Stores information about mouse, keyboard, and touch gesture input events. This includes information about which modifier keys are pressed, such as `kbd`Shift`/kbd` or `kbd`Alt`/kbd`. See `Node._input`.
		**Note:** Modifier keys are considered modifiers only when used in combination with another key. As a result, their corresponding member variables, such as `ctrl_pressed`, will return `false` if the key is pressed on its own.
	'''

  @staticmethod
  def constructor():
    class_ = InputEventWithModifiers.construct_without_init()
    class_._ptr = constructor(429,0, ())
    return class_
  @staticmethod
  def new():
    class_ = InputEventWithModifiers.construct_without_init()
    class_._ptr = constructor(429,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPInputEventWithModifiersWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(429,0, ())


  def generate_wrapper(self):
    return CPPInputEventWithModifiersWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = InputEventWithModifiers.__new__(InputEventWithModifiers)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'InputEventWithModifiers'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEventWithModifiers.construct_without_init()
    cls._ptr = CPPInputEventWithModifiersWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEventWithModifiers.construct_without_init()
    cls._ptr = CPPInputEventWithModifiersWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def command_or_control_autoremap(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_command_or_control_autoremap()
    return _ret
  @command_or_control_autoremap.setter
  def command_or_control_autoremap(self,  value:'bool'):
    self.set_command_or_control_autoremap(value)
  @property
  def alt_pressed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_alt_pressed()
    return _ret
  @alt_pressed.setter
  def alt_pressed(self,  value:'bool'):
    self.set_alt_pressed(value)
  @property
  def shift_pressed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_shift_pressed()
    return _ret
  @shift_pressed.setter
  def shift_pressed(self,  value:'bool'):
    self.set_shift_pressed(value)
  @property
  def ctrl_pressed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ctrl_pressed()
    return _ret
  @ctrl_pressed.setter
  def ctrl_pressed(self,  value:'bool'):
    self.set_ctrl_pressed(value)
  @property
  def meta_pressed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_meta_pressed()
    return _ret
  @meta_pressed.setter
  def meta_pressed(self,  value:'bool'):
    self.set_meta_pressed(value)
  @functools.native_method
  def set_command_or_control_autoremap(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__command_or_control_autoremap = enable






    self._ptr.call_with_return(94,tuple([enable]))

  @functools.native_method
  def is_command_or_control_autoremap(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def is_command_or_control_pressed(self) -> typing.Union[bool]:
    r'''
				On macOS, returns `true` if `kbd`Meta`/kbd` (`kbd`Cmd`/kbd`) is pressed.
				On other platforms, returns `true` if `kbd`Ctrl`/kbd` is pressed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def set_alt_pressed(self, pressed:'bool'   ) -> None:
    r''''''

    assert isinstance(pressed, bool), 'pressed must be bool'

    self.py__alt_pressed = pressed






    self._ptr.call_with_return(97,tuple([pressed]))

  @functools.native_method
  def is_alt_pressed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_shift_pressed(self, pressed:'bool'   ) -> None:
    r''''''

    assert isinstance(pressed, bool), 'pressed must be bool'

    self.py__shift_pressed = pressed






    self._ptr.call_with_return(99,tuple([pressed]))

  @functools.native_method
  def is_shift_pressed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_ctrl_pressed(self, pressed:'bool'   ) -> None:
    r''''''

    assert isinstance(pressed, bool), 'pressed must be bool'

    self.py__ctrl_pressed = pressed






    self._ptr.call_with_return(101,tuple([pressed]))

  @functools.native_method
  def is_ctrl_pressed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def set_meta_pressed(self, pressed:'bool'   ) -> None:
    r''''''

    assert isinstance(pressed, bool), 'pressed must be bool'

    self.py__meta_pressed = pressed






    self._ptr.call_with_return(103,tuple([pressed]))

  @functools.native_method
  def is_meta_pressed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([]))

    return _ret


  @functools.native_method
  def get_modifiers_mask(self) -> typing.Union[int]:
    r'''
				Returns the keycode combination of modifier keys.
			'''




    _ret
    _ret = self._ptr.call_with_return(105,tuple([]))
    return _ret



register_cast_function('InputEventWithModifiers', InputEventWithModifiers.cast)
register_class('InputEventWithModifiers', InputEventWithModifiers)
