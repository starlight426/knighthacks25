# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.SkeletonProfile as py4godot_skeletonprofile 
  import py4godot.classes.SkeletonProfileHumanoid as py4godot_skeletonprofilehumanoid 
import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
from py4godot.wrappers.wrappers import CPPRetargetModifier3DWrapper

class TransformFlag:
  TRANSFORM_FLAG_POSITION = 1
  TRANSFORM_FLAG_ROTATION = 2
  TRANSFORM_FLAG_SCALE = 4
  TRANSFORM_FLAG_ALL = 7


class RetargetModifier3D(py4godot_skeletonmodifier3d.SkeletonModifier3D):
  r'''
		Retrieves the pose (or global pose) relative to the parent Skeleton's rest in model space and transfers it to the child Skeleton.
		This modifier rewrites the pose of the child skeleton directly in the parent skeleton's update process. This means that it overwrites the mapped bone pose set in the normal process on the target skeleton. If you want to set the target skeleton bone pose after retargeting, you will need to add a `SkeletonModifier3D` child to the target skeleton and thereby modify the pose.
		**Note:** When the `use_global_pose` is enabled, even if it is an unmapped bone, it can cause visual problems because the global pose is applied ignoring the parent bone's pose **if it has mapped bone children**. See also `use_global_pose`.
	'''

  @staticmethod
  def constructor():
    class_ = RetargetModifier3D.construct_without_init()
    class_._ptr = constructor(709,0, ())
    return class_
  @staticmethod
  def new():
    class_ = RetargetModifier3D.construct_without_init()
    class_._ptr = constructor(709,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRetargetModifier3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(709,0, ())


  def generate_wrapper(self):
    return CPPRetargetModifier3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = RetargetModifier3D.__new__(RetargetModifier3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RetargetModifier3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RetargetModifier3D.construct_without_init()
    cls._ptr = CPPRetargetModifier3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RetargetModifier3D.construct_without_init()
    cls._ptr = CPPRetargetModifier3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def profile(self) -> typing.Union['py4godot_skeletonprofile.SkeletonProfile','py4godot_skeletonprofilehumanoid.SkeletonProfileHumanoid']:
    r''''''
    _ret = self. get_profile()
    return _ret
  @profile.setter
  def profile(self,  value:'py4godot_object.Object'):
    self.set_profile(value)
  @property
  def use_global_pose(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_global_pose()
    return _ret
  @use_global_pose.setter
  def use_global_pose(self,  value:'bool'):
    self.set_use_global_pose(value)
  @property
  def enable(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_enable_flags()
    return _ret
  @enable.setter
  def enable(self,  value:'int'):
    self.set_enable_flags(value)
  @functools.native_method
  def set_profile(self, profile:'py4godot_skeletonprofile.SkeletonProfile'   ) -> None:
    r''''''

    assert(not profile is None)
    assert isinstance(profile, get_class('SkeletonProfile')), 'profile must be SkeletonProfile'

    self.py__profile = profile






    self._ptr.call_with_return(260,tuple([profile._ptr]))

  @functools.native_method
  def get_profile(self) -> typing.Union['py4godot_skeletonprofile.SkeletonProfile','py4godot_skeletonprofilehumanoid.SkeletonProfileHumanoid']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SkeletonProfile
    _ret._ptr = self._ptr.call_with_return(261,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_use_global_pose(self, use_global_pose:'bool'   ) -> None:
    r''''''

    assert isinstance(use_global_pose, bool), 'use_global_pose must be bool'

    self.py__use_global_pose = use_global_pose






    self._ptr.call_with_return(262,tuple([use_global_pose]))

  @functools.native_method
  def is_using_global_pose(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([]))

    return _ret


  @functools.native_method
  def set_enable_flags(self, enable_flags:'int'   ) -> None:
    r''''''

    assert isinstance(enable_flags, (int, float)), 'enable_flags must be int or float'

    self.py__enable = enable_flags






    self._ptr.call_with_return(264,tuple([enable_flags]))

  @functools.native_method
  def get_enable_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_position_enabled(self, enabled:'bool'   ) -> None:
    r'''
				Sets `constant TRANSFORM_FLAG_POSITION` into `enable`.
			'''

    assert isinstance(enabled, bool), 'enabled must be bool'






    self._ptr.call_with_return(266,tuple([enabled]))

  @functools.native_method
  def is_position_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `enable` has `constant TRANSFORM_FLAG_POSITION`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(267,tuple([]))
    return _ret


  @functools.native_method
  def set_rotation_enabled(self, enabled:'bool'   ) -> None:
    r'''
				Sets `constant TRANSFORM_FLAG_ROTATION` into `enable`.
			'''

    assert isinstance(enabled, bool), 'enabled must be bool'






    self._ptr.call_with_return(268,tuple([enabled]))

  @functools.native_method
  def is_rotation_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `enable` has `constant TRANSFORM_FLAG_ROTATION`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([]))
    return _ret


  @functools.native_method
  def set_scale_enabled(self, enabled:'bool'   ) -> None:
    r'''
				Sets `constant TRANSFORM_FLAG_SCALE` into `enable`.
			'''

    assert isinstance(enabled, bool), 'enabled must be bool'






    self._ptr.call_with_return(270,tuple([enabled]))

  @functools.native_method
  def is_scale_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `enable` has `constant TRANSFORM_FLAG_SCALE`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))
    return _ret



register_cast_function('RetargetModifier3D', RetargetModifier3D.cast)
register_class('RetargetModifier3D', RetargetModifier3D)
