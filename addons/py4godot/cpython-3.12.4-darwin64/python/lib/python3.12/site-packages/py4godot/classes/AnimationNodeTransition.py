# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Curve as py4godot_curve 
import py4godot.classes.AnimationNodeSync as py4godot_animationnodesync 
from py4godot.wrappers.wrappers import CPPAnimationNodeTransitionWrapper


class AnimationNodeTransition(py4godot_animationnodesync.AnimationNodeSync):
  r'''
		Simple state machine for cases which don't require a more advanced `AnimationNodeStateMachine`. Animations can be connected to the inputs and transition times can be specified.
		After setting the request and changing the animation playback, the transition node automatically clears the request on the next process frame by setting its `transition_request` value to empty.
		**Note:** When using a cross-fade, `current_state` and `current_index` change to the next state immediately after the cross-fade begins.
		
		```gdscript
		# Play child animation connected to "state_2" port.
		animation_tree.set("parameters/Transition/transition_request", "state_2")
		# Alternative syntax (same result as above).
		animation_tree`"parameters/Transition/transition_request"` = "state_2"

		# Get current state name (read-only).
		animation_tree.get("parameters/Transition/current_state")
		# Alternative syntax (same result as above).
		animation_tree`"parameters/Transition/current_state"`

		# Get current state index (read-only).
		animation_tree.get("parameters/Transition/current_index")
		# Alternative syntax (same result as above).
		animation_tree`"parameters/Transition/current_index"`
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = AnimationNodeTransition.construct_without_init()
    class_._ptr = constructor(94,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimationNodeTransition.construct_without_init()
    class_._ptr = constructor(94,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimationNodeTransitionWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(94,0, ())


  def generate_wrapper(self):
    return CPPAnimationNodeTransitionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = AnimationNodeTransition.__new__(AnimationNodeTransition)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimationNodeTransition'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNodeTransition.construct_without_init()
    cls._ptr = CPPAnimationNodeTransitionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNodeTransition.construct_without_init()
    cls._ptr = CPPAnimationNodeTransitionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def xfade_time(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_xfade_time()
    return _ret
  @xfade_time.setter
  def xfade_time(self,  value:'float'):
    self.set_xfade_time(value)
  @property
  def xfade_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_xfade_curve()
    return _ret
  @xfade_curve.setter
  def xfade_curve(self,  value:'py4godot_object.Object'):
    self.set_xfade_curve(value)
  @property
  def allow_transition_to_self(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_allow_transition_to_self()
    return _ret
  @allow_transition_to_self.setter
  def allow_transition_to_self(self,  value:'bool'):
    self.set_allow_transition_to_self(value)
  @property
  def input_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_input_count()
    return _ret
  @input_count.setter
  def input_count(self,  value:'int'):
    self.set_input_count(value)
  @functools.native_method
  def set_input_count(self, input_count:'int'   ) -> None:
    r''''''

    assert isinstance(input_count, (int, float)), 'input_count must be int or float'

    self.py__input_count = input_count






    self._ptr.call_with_return(104,tuple([input_count]))

  @functools.native_method
  def set_input_as_auto_advance(self, input:'int'   , enable:'bool'   ) -> None:
    r'''
				Enables or disables auto-advance for the given `input` index. If enabled, state changes to the next input after playing the animation once. If enabled for the last input state, it loops to the first.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(105,tuple([input, enable]))

  @functools.native_method
  def is_input_set_as_auto_advance(self, input:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if auto-advance is enabled for the given `input` index.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([input]))
    return _ret


  @functools.native_method
  def set_input_break_loop_at_end(self, input:'int'   , enable:'bool'   ) -> None:
    r'''
				If `true`, breaks the loop at the end of the loop cycle for transition, even if the animation is looping.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(107,tuple([input, enable]))

  @functools.native_method
  def is_input_loop_broken_at_end(self, input:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the animation breaks the loop at the end of the loop cycle for transition.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(108,tuple([input]))
    return _ret


  @functools.native_method
  def set_input_reset(self, input:'int'   , enable:'bool'   ) -> None:
    r'''
				If `true`, the destination animation is restarted when the animation transitions.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(109,tuple([input, enable]))

  @functools.native_method
  def is_input_reset(self, input:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the animation restarts when the animation transitions from the other animation.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([input]))
    return _ret


  @functools.native_method
  def set_xfade_time(self, time:'float'   ) -> None:
    r''''''

    assert isinstance(time, (int, float)), 'time must be int or float'

    self.py__xfade_time = time






    self._ptr.call_with_return(111,tuple([time]))

  @functools.native_method
  def get_xfade_time(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([]))

    return _ret


  @functools.native_method
  def set_xfade_curve(self, curve:'py4godot_curve.Curve'   ) -> None:
    r''''''

    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'

    self.py__xfade_curve = curve






    self._ptr.call_with_return(113,tuple([curve._ptr]))

  @functools.native_method
  def get_xfade_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(114,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_allow_transition_to_self(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__allow_transition_to_self = enable






    self._ptr.call_with_return(115,tuple([enable]))

  @functools.native_method
  def is_allow_transition_to_self(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(116,tuple([]))

    return _ret



register_cast_function('AnimationNodeTransition', AnimationNodeTransition.cast)
register_class('AnimationNodeTransition', AnimationNodeTransition)
