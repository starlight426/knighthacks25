# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Object as py4godot_object 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPExpressionWrapper


class Expression(py4godot_refcounted.RefCounted):
  r'''
		An expression can be made of any arithmetic operation, built-in math function call, method call of a passed instance, or built-in type construction call.
		An example expression text using the built-in math functions could be `sqrt(pow(3, 2) + pow(4, 2))`.
		In the following example we use a `LineEdit` node to write our expression and show the result.
		
		```gdscript
		var expression = Expression.new()

		func _ready():
			$LineEdit.text_submitted.connect(self._on_text_submitted)

		func _on_text_submitted(command):
			var error = expression.parse(command)
			if error != OK:
				print(expression.get_error_text())
				return
			var result = expression.execute()
			if not expression.has_execute_failed():
				$LineEdit.text = str(result)
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = Expression.construct_without_init()
    class_._ptr = constructor(324,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Expression.construct_without_init()
    class_._ptr = constructor(324,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPExpressionWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(324,0, ())


  def generate_wrapper(self):
    return CPPExpressionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Expression.__new__(Expression)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Expression'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Expression.construct_without_init()
    cls._ptr = CPPExpressionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Expression.construct_without_init()
    cls._ptr = CPPExpressionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def parse(self, expression:'str'   , input_names:'PackedStringArray' = None  ) -> typing.Union[int]:
    r'''
				Parses the expression and returns an `enum Error` code.
				You can optionally specify names of variables that may appear in the expression with `input_names`, so that you can bind them when it gets executed.
			'''
    if input_names is None:
      input_names = PackedStringArray.new0()
    if input_names is None:
      input_names = PackedStringArray.new0()

    assert(not expression is None)
    assert isinstance(expression, (str, String)), 'expression must be str or String'




    assert(isinstance(expression, (str, String)))
    py_string_expression = expression if isinstance(expression, StringName) else c_utils.py_string_to_string(expression)


    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([py_string_expression._ptr, input_names._ptr]))
    return _ret


  @functools.native_method
  def execute(self, inputs:'Array' = None  , base_instance:'py4godot_object.Object' = None  , show_error:'bool' =True  , const_calls_only:'bool' =False  ) -> typing.Union[typing.Any]:
    r'''
				Executes the expression that was previously parsed by `parse` and returns the result. Before you use the returned object, you should check if the method failed by calling `has_execute_failed`.
				If you defined input variables in `parse`, you can specify their values in the inputs array, in the same order.
			'''
    if inputs is None:
      inputs = Array.new0()
    if base_instance is None:
      base_instance = c_utils.empty_object
    if inputs is None:
      inputs = Array.new0()
    if base_instance is None:
      base_instance = c_utils.empty_object

    assert isinstance(show_error, bool), 'show_error must be bool'
    assert isinstance(const_calls_only, bool), 'const_calls_only must be bool'









    _ret = None
    _ret = self._ptr.call_with_return(54,tuple([inputs._ptr, base_instance._ptr, show_error, const_calls_only]))
    return _ret


  @functools.native_method
  def has_execute_failed(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `execute` has failed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def get_error_text(self) -> typing.Union[str]:
    r'''
				Returns the error text if `parse` or `execute` has failed.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))
    return utils.gd_string_to_py_string(_ret)



register_cast_function('Expression', Expression.cast)
register_class('Expression', Expression)
