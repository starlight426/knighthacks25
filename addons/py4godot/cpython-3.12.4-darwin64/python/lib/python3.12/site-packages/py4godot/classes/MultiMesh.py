# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPMultiMeshWrapper

class TransformFormat:
  TRANSFORM_2D = 0
  TRANSFORM_3D = 1
class PhysicsInterpolationQuality:
  INTERP_QUALITY_FAST = 0
  INTERP_QUALITY_HIGH = 1


class MultiMesh(py4godot_resource.Resource):
  r'''
		MultiMesh provides low-level mesh instancing. Drawing thousands of `MeshInstance3D` nodes can be slow, since each object is submitted to the GPU then drawn individually.
		MultiMesh is much faster as it can draw thousands of instances with a single draw call, resulting in less API overhead.
		As a drawback, if the instances are too far away from each other, performance may be reduced as every single instance will always render (they are spatially indexed as one, for the whole object).
		Since instances may have any behavior, the AABB used for visibility must be provided by the user.
		**Note:** A MultiMesh is a single object, therefore the same maximum lights per object restriction applies. This means, that once the maximum lights are consumed by one or more instances, the rest of the MultiMesh instances will **not** receive any lighting.
		**Note:** Blend Shapes will be ignored if used in a MultiMesh.
	'''

  @staticmethod
  def constructor():
    class_ = MultiMesh.construct_without_init()
    class_._ptr = constructor(483,0, ())
    return class_
  @staticmethod
  def new():
    class_ = MultiMesh.construct_without_init()
    class_._ptr = constructor(483,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPMultiMeshWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(483,0, ())


  def generate_wrapper(self):
    return CPPMultiMeshWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = MultiMesh.__new__(MultiMesh)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'MultiMesh'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = MultiMesh.construct_without_init()
    cls._ptr = CPPMultiMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = MultiMesh.construct_without_init()
    cls._ptr = CPPMultiMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def transform_format(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_transform_format()
    return _ret
  @transform_format.setter
  def transform_format(self,  value:'int'):
    self.set_transform_format(value)
  @property
  def use_colors(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_colors()
    return _ret
  @use_colors.setter
  def use_colors(self,  value:'bool'):
    self.set_use_colors(value)
  @property
  def use_custom_data(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_custom_data()
    return _ret
  @use_custom_data.setter
  def use_custom_data(self,  value:'bool'):
    self.set_use_custom_data(value)
  @property
  def custom_aabb(self) -> typing.Union['AABB']:
    r''''''
    _ret = self. get_custom_aabb()
    return _ret
  @custom_aabb.setter
  def custom_aabb(self,  value:'AABB'):
    self.set_custom_aabb(value)
  @property
  def instance_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_instance_count()
    return _ret
  @instance_count.setter
  def instance_count(self,  value:'int'):
    self.set_instance_count(value)
  @property
  def visible_instance_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visible_instance_count()
    return _ret
  @visible_instance_count.setter
  def visible_instance_count(self,  value:'int'):
    self.set_visible_instance_count(value)
  @property
  def mesh(self) -> typing.Any:
    r''''''
    _ret = self. get_mesh()
    return _ret
  @mesh.setter
  def mesh(self,  value:'py4godot_object.Object'):
    self.set_mesh(value)
  @property
  def buffer(self) -> typing.Union['PackedFloat32Array']:
    r''''''
    _ret = self. get_buffer()
    return _ret
  @buffer.setter
  def buffer(self,  value:'PackedFloat32Array'):
    self.set_buffer(value)
  @property
  def transform_array(self) -> typing.Union['PackedVector3Array']:
    r''''''
    _ret = self. _get_transform_array()
    return _ret
  @transform_array.setter
  def transform_array(self,  value:'PackedVector3Array'):
    self._set_transform_array(value)
  @property
  def transform_2d_array(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. _get_transform_2d_array()
    return _ret
  @transform_2d_array.setter
  def transform_2d_array(self,  value:'PackedVector2Array'):
    self._set_transform_2d_array(value)
  @property
  def color_array(self) -> typing.Union['PackedColorArray']:
    r''''''
    _ret = self. _get_color_array()
    return _ret
  @color_array.setter
  def color_array(self,  value:'PackedColorArray'):
    self._set_color_array(value)
  @property
  def custom_data_array(self) -> typing.Union['PackedColorArray']:
    r''''''
    _ret = self. _get_custom_data_array()
    return _ret
  @custom_data_array.setter
  def custom_data_array(self,  value:'PackedColorArray'):
    self._set_custom_data_array(value)
  @property
  def physics_interpolation_quality(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_physics_interpolation_quality()
    return _ret
  @physics_interpolation_quality.setter
  def physics_interpolation_quality(self,  value:'int'):
    self.set_physics_interpolation_quality(value)
  @functools.native_method
  def set_mesh(self, mesh:'py4godot_mesh.Mesh'   ) -> None:
    r''''''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('Mesh')), 'mesh must be Mesh'

    self.py__mesh = mesh






    self._ptr.call_with_return(77,tuple([mesh._ptr]))

  @functools.native_method
  def get_mesh(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Mesh
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_use_colors(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__use_colors = enable






    self._ptr.call_with_return(79,tuple([enable]))

  @functools.native_method
  def is_using_colors(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([]))

    return _ret


  @functools.native_method
  def set_use_custom_data(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__use_custom_data = enable






    self._ptr.call_with_return(81,tuple([enable]))

  @functools.native_method
  def is_using_custom_data(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))

    return _ret


  @functools.native_method
  def set_transform_format(self, format:'int'  ) -> None:
    r''''''

    assert isinstance(format, (int, float)), 'format must be int or float'

    self.py__transform_format = format






    self._ptr.call_with_return(83,tuple([format]))

  @functools.native_method
  def get_transform_format(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(84,tuple([]))

    return _ret


  @functools.native_method
  def set_instance_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'

    self.py__instance_count = count






    self._ptr.call_with_return(85,tuple([count]))

  @functools.native_method
  def get_instance_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))

    return _ret


  @functools.native_method
  def set_visible_instance_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'

    self.py__visible_instance_count = count






    self._ptr.call_with_return(87,tuple([count]))

  @functools.native_method
  def get_visible_instance_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_physics_interpolation_quality(self, quality:'int'  ) -> None:
    r''''''

    assert isinstance(quality, (int, float)), 'quality must be int or float'

    self.py__physics_interpolation_quality = quality






    self._ptr.call_with_return(89,tuple([quality]))

  @functools.native_method
  def get_physics_interpolation_quality(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_instance_transform(self, instance:'int'   , transform:'Transform3D'   ) -> None:
    r'''
				Sets the `Transform3D` for a specific instance.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'







    self._ptr.call_with_return(91,tuple([instance, transform._ptr]))

  @functools.native_method
  def set_instance_transform_2d(self, instance:'int'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets the `Transform2D` for a specific instance.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(92,tuple([instance, transform._ptr]))

  @functools.native_method
  def get_instance_transform(self, instance:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the `Transform3D` of a specific instance.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'






    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([instance]))
    return _ret


  @functools.native_method
  def get_instance_transform_2d(self, instance:'int'   ) -> typing.Union['Transform2D']:
    r'''
				Returns the `Transform2D` of a specific instance.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'






    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([instance]))
    return _ret


  @functools.native_method
  def set_instance_color(self, instance:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the color of a specific instance by _multiplying_ the mesh's existing vertex colors. This allows for different color tinting per instance.
				**Note:** Each component is stored in 32 bits in the Forward+ and Mobile rendering methods, but is packed into 16 bits in the Compatibility rendering method.
				For the color to take effect, ensure that `use_colors` is `true` on the `MultiMesh` and `BaseMaterial3D.vertex_color_use_as_albedo` is `true` on the material. If you intend to set an absolute color instead of tinting, make sure the material's albedo color is set to pure white (`Color(1, 1, 1)`).
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(95,tuple([instance, color._ptr]))

  @functools.native_method
  def get_instance_color(self, instance:'int'   ) -> typing.Union['Color']:
    r'''
				Gets a specific instance's color multiplier.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([instance]))
    return _ret


  @functools.native_method
  def set_instance_custom_data(self, instance:'int'   , custom_data:'Color'   ) -> None:
    r'''
				Sets custom data for a specific instance. `custom_data` is a `Color` type only to contain 4 floating-point numbers.
				**Note:** Each number is stored in 32 bits in the Forward+ and Mobile rendering methods, but is packed into 16 bits in the Compatibility rendering method.
				For the custom data to be used, ensure that `use_custom_data` is `true`.
				This custom instance data has to be manually accessed in your custom shader using `INSTANCE_CUSTOM`.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'
    assert(not custom_data is None)
    assert isinstance(custom_data, Color), 'custom_data must be Color'







    self._ptr.call_with_return(97,tuple([instance, custom_data._ptr]))

  @functools.native_method
  def get_instance_custom_data(self, instance:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the custom data that has been set for a specific instance.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([instance]))
    return _ret


  @functools.native_method
  def reset_instance_physics_interpolation(self, instance:'int'   ) -> None:
    r'''
				When using _physics interpolation_, this function allows you to prevent interpolation on an instance in the current physics tick.
				This allows you to move instances instantaneously, and should usually be used when initially placing an instance such as a bullet to prevent graphical glitches.
			'''

    assert isinstance(instance, (int, float)), 'instance must be int or float'






    self._ptr.call_with_return(99,tuple([instance]))

  @functools.native_method
  def set_custom_aabb(self, aabb:'AABB'   ) -> None:
    r''''''

    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'

    self.py__custom_aabb = aabb






    self._ptr.call_with_return(100,tuple([aabb._ptr]))

  @functools.native_method
  def get_custom_aabb(self) -> typing.Union['AABB']:
    r''''''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([]))

    return _ret


  @functools.native_method
  def get_aabb(self) -> typing.Union['AABB']:
    r'''
				Returns the visibility axis-aligned bounding box in local space.
			'''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(102,tuple([]))
    return _ret


  @functools.native_method
  def get_buffer(self) -> typing.Union['PackedFloat32Array']:
    r''''''




    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))

    return _ret


  @functools.native_method
  def set_buffer(self, buffer:'PackedFloat32Array'   ) -> None:
    r''''''

    assert(not buffer is None)
    assert isinstance(buffer, PackedFloat32Array), 'buffer must be PackedFloat32Array'

    self.py__buffer = buffer






    self._ptr.call_with_return(104,tuple([buffer._ptr]))

  @functools.native_method
  def set_buffer_interpolated(self, buffer_curr:'PackedFloat32Array'   , buffer_prev:'PackedFloat32Array'   ) -> None:
    r'''
				An alternative to setting the `buffer` property, which can be used with _physics interpolation_. This method takes two arrays, and can set the data for the current and previous tick in one go. The renderer will automatically interpolate the data at each frame.
				This is useful for situations where the order of instances may change from physics tick to tick, such as particle systems.
				When the order of instances is coherent, the simpler alternative of setting `buffer` can still be used with interpolation.
			'''

    assert(not buffer_curr is None)
    assert isinstance(buffer_curr, PackedFloat32Array), 'buffer_curr must be PackedFloat32Array'
    assert(not buffer_prev is None)
    assert isinstance(buffer_prev, PackedFloat32Array), 'buffer_prev must be PackedFloat32Array'







    self._ptr.call_with_return(105,tuple([buffer_curr._ptr, buffer_prev._ptr]))


register_cast_function('MultiMesh', MultiMesh.cast)
register_class('MultiMesh', MultiMesh)
