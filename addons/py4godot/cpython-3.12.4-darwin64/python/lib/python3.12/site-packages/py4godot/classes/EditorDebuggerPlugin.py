# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Script as py4godot_script 
  import py4godot.classes.EditorDebuggerSession as py4godot_editordebuggersession 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPEditorDebuggerPluginWrapper


class EditorDebuggerPlugin(py4godot_refcounted.RefCounted):
  r'''
		`EditorDebuggerPlugin` provides functions related to the editor side of the debugger.
		To interact with the debugger, an instance of this class must be added to the editor via `EditorPlugin.add_debugger_plugin`.
		Once added, the `_setup_session` callback will be called for every `EditorDebuggerSession` available to the plugin, and when new ones are created (the sessions may be inactive during this stage).
		You can retrieve the available `EditorDebuggerSession`s via `get_sessions` or get a specific one via `get_session`.
		
		```gdscript
		@tool
		extends EditorPlugin

		class ExampleEditorDebugger extends EditorDebuggerPlugin:

			func _has_capture(capture):
				# Return true if you wish to handle messages with the prefix "my_plugin:".
				return capture == "my_plugin"

			func _capture(message, data, session_id):
				if message == "my_plugin:ping":
					get_session(session_id).send_message("my_plugin:echo", data)
					return true
				return false

			func _setup_session(session_id):
				# Add a new tab in the debugger session UI containing a label.
				var label = Label.new()
				label.name = "Example plugin" # Will be used as the tab title.
				label.text = "Example plugin"
				var session = get_session(session_id)
				# Listens to the session started and stopped signals.
				session.started.connect(func (): print("Session started"))
				session.stopped.connect(func (): print("Session stopped"))
				session.add_session_tab(label)

		var debugger = ExampleEditorDebugger.new()

		func _enter_tree():
			add_debugger_plugin(debugger)

		func _exit_tree():
			remove_debugger_plugin(debugger)
		```
		
		To connect on the running game side, use the `EngineDebugger` singleton:
		
		```gdscript
		extends Node

		func _ready():
			EngineDebugger.register_message_capture("my_plugin", _capture)
			EngineDebugger.send_message("my_plugin:ping", `"test"`)

		func _capture(message, data):
			# Note that the "my_plugin:" prefix is not used here.
			if message == "echo":
				prints("Echo received:", data)
				return true
			return false
		```
		
		**Note:** While the game is running, `@GlobalScope.print` and similar functions _called in the editor_ do not print anything, the Output Log prints only game messages.
	'''

  @staticmethod
  def constructor():
    class_ = EditorDebuggerPlugin.construct_without_init()
    class_._ptr = constructor(268,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorDebuggerPlugin.construct_without_init()
    class_._ptr = constructor(268,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorDebuggerPluginWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(268,0, ())


  def generate_wrapper(self):
    return CPPEditorDebuggerPluginWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorDebuggerPlugin.__new__(EditorDebuggerPlugin)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorDebuggerPlugin'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorDebuggerPlugin.construct_without_init()
    cls._ptr = CPPEditorDebuggerPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorDebuggerPlugin.construct_without_init()
    cls._ptr = CPPEditorDebuggerPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _setup_session(self, session_id:'int'   ) -> None:
    r'''
				Override this method to be notified whenever a new `EditorDebuggerSession` is created. Note that the session may be inactive during this stage.
			'''

    assert isinstance(session_id, (int, float)), 'session_id must be int or float'






    self._ptr.call_with_return(53,tuple([session_id]))

  @functools.native_method
  def _has_capture(self, capture:'str'   ) -> typing.Union[bool]:
    r'''
				Override this method to enable receiving messages from the debugger. If `capture` is "my_message" then messages starting with "my_message:" will be passed to the `_capture` method.
			'''

    assert(not capture is None)
    assert isinstance(capture, (str, String)), 'capture must be str or String'




    assert(isinstance(capture, (str, String)))
    py_string_capture = capture if isinstance(capture, StringName) else c_utils.py_string_to_string(capture)

    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([py_string_capture._ptr]))
    return _ret


  @functools.native_method
  def _capture(self, message:'str'   , data:'Array'   , session_id:'int'   ) -> typing.Union[bool]:
    r'''
				Override this method to process incoming messages. The `session_id` is the ID of the `EditorDebuggerSession` that received the `message`. Use `get_session` to retrieve the session. This method should return `true` if the message is recognized.
			'''

    assert(not message is None)
    assert isinstance(message, (str, String)), 'message must be str or String'
    assert(not data is None)
    assert isinstance(data, Array), 'data must be Array'
    assert isinstance(session_id, (int, float)), 'session_id must be int or float'




    assert(isinstance(message, (str, String)))
    py_string_message = message if isinstance(message, StringName) else c_utils.py_string_to_string(message)



    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([py_string_message._ptr, data._ptr, session_id]))
    return _ret


  @functools.native_method
  def _goto_script_line(self, script:'py4godot_script.Script'   , line:'int'   ) -> None:
    r'''
				Override this method to be notified when a breakpoint line has been clicked in the debugger breakpoint panel.
			'''

    assert(not script is None)
    assert isinstance(script, get_class('Script')), 'script must be Script'
    assert isinstance(line, (int, float)), 'line must be int or float'







    self._ptr.call_with_return(56,tuple([script._ptr, line]))

  @functools.native_method
  def _breakpoints_cleared_in_tree(self) -> None:
    r'''
				Override this method to be notified when all breakpoints are cleared in the editor.
			'''




    self._ptr.call_with_return(57,tuple([]))

  @functools.native_method
  def _breakpoint_set_in_tree(self, script:'py4godot_script.Script'   , line:'int'   , enabled:'bool'   ) -> None:
    r'''
				Override this method to be notified when a breakpoint is set in the editor.
			'''

    assert(not script is None)
    assert isinstance(script, get_class('Script')), 'script must be Script'
    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(58,tuple([script._ptr, line, enabled]))

  @functools.native_method
  def get_session(self, id:'int'   ) -> typing.Union['py4godot_editordebuggersession.EditorDebuggerSession']:
    r'''
				Returns the `EditorDebuggerSession` with the given `id`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorDebuggerSession
    _ret._ptr = self._ptr.call_with_return(59,tuple([id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_sessions(self) -> typing.Union['Array']:
    r'''
				Returns an array of `EditorDebuggerSession` currently available to this debugger plugin.
				**Note:** Sessions in the array may be inactive, check their state via `EditorDebuggerSession.is_active`.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))
    return _ret



register_cast_function('EditorDebuggerPlugin', EditorDebuggerPlugin.cast)
register_class('EditorDebuggerPlugin', EditorDebuggerPlugin)
