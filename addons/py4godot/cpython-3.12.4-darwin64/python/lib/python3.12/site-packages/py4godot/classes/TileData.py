# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.NavigationPolygon as py4godot_navigationpolygon 
  import py4godot.classes.TileSet as py4godot_tileset 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.OccluderPolygon2D as py4godot_occluderpolygon2d 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPTileDataWrapper


class TileData(py4godot_object.Object):
  r'''
		`TileData` object represents a single tile in a `TileSet`. It is usually edited using the tileset editor, but it can be modified at runtime using `TileMapLayer._tile_data_runtime_update`.
	'''

  @staticmethod
  def constructor():
    class_ = TileData.construct_without_init()
    class_._ptr = constructor(834,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TileData.construct_without_init()
    class_._ptr = constructor(834,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTileDataWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(834,0, ())


  def generate_wrapper(self):
    return CPPTileDataWrapper()
  def init_signals(self):
    super().init_signals()
    changed_name = utils.py_string_to_string_name("changed")
    self.changed = signals.BuiltinSignal(self, changed_name)

  @staticmethod
  def construct_without_init():
    cls = TileData.__new__(TileData)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TileData'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileData.construct_without_init()
    cls._ptr = CPPTileDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileData.construct_without_init()
    cls._ptr = CPPTileDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def flip_h(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flip_h()
    return _ret
  @flip_h.setter
  def flip_h(self,  value:'bool'):
    self.set_flip_h(value)
  @property
  def flip_v(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flip_v()
    return _ret
  @flip_v.setter
  def flip_v(self,  value:'bool'):
    self.set_flip_v(value)
  @property
  def transpose(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_transpose()
    return _ret
  @transpose.setter
  def transpose(self,  value:'bool'):
    self.set_transpose(value)
  @property
  def texture_origin(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_texture_origin()
    return _ret
  @texture_origin.setter
  def texture_origin(self,  value:'Vector2i'):
    self.set_texture_origin(value)
  @property
  def modulate(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_modulate()
    return _ret
  @modulate.setter
  def modulate(self,  value:'Color'):
    self.set_modulate(value)
  @property
  def material(self) -> typing.Union['py4godot_canvasitemmaterial.CanvasItemMaterial']:
    r''''''
    _ret = self. get_material()
    return _ret
  @material.setter
  def material(self,  value:'py4godot_object.Object'):
    self.set_material(value)
  @property
  def z_index(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_z_index()
    return _ret
  @z_index.setter
  def z_index(self,  value:'int'):
    self.set_z_index(value)
  @property
  def y_sort_origin(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_y_sort_origin()
    return _ret
  @y_sort_origin.setter
  def y_sort_origin(self,  value:'int'):
    self.set_y_sort_origin(value)
  @property
  def terrain_set(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_terrain_set()
    return _ret
  @terrain_set.setter
  def terrain_set(self,  value:'int'):
    self.set_terrain_set(value)
  @property
  def terrain(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_terrain()
    return _ret
  @terrain.setter
  def terrain(self,  value:'int'):
    self.set_terrain(value)
  @property
  def probability(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_probability()
    return _ret
  @probability.setter
  def probability(self,  value:'float'):
    self.set_probability(value)
  @functools.native_method
  def set_flip_h(self, flip_h:'bool'   ) -> None:
    r''''''

    assert isinstance(flip_h, bool), 'flip_h must be bool'

    self.py__flip_h = flip_h






    self._ptr.call_with_return(49,tuple([flip_h]))

  @functools.native_method
  def get_flip_h(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([]))

    return _ret


  @functools.native_method
  def set_flip_v(self, flip_v:'bool'   ) -> None:
    r''''''

    assert isinstance(flip_v, bool), 'flip_v must be bool'

    self.py__flip_v = flip_v






    self._ptr.call_with_return(51,tuple([flip_v]))

  @functools.native_method
  def get_flip_v(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(52,tuple([]))

    return _ret


  @functools.native_method
  def set_transpose(self, transpose:'bool'   ) -> None:
    r''''''

    assert isinstance(transpose, bool), 'transpose must be bool'

    self.py__transpose = transpose






    self._ptr.call_with_return(53,tuple([transpose]))

  @functools.native_method
  def get_transpose(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([]))

    return _ret


  @functools.native_method
  def set_material(self, material:'py4godot_material.Material'   ) -> None:
    r''''''

    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'

    self.py__material = material






    self._ptr.call_with_return(55,tuple([material._ptr]))

  @functools.native_method
  def get_material(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_texture_origin(self, texture_origin:'Vector2i'   ) -> None:
    r''''''

    assert(not texture_origin is None)
    assert isinstance(texture_origin, Vector2i), 'texture_origin must be Vector2i'

    self.py__texture_origin = texture_origin






    self._ptr.call_with_return(57,tuple([texture_origin._ptr]))

  @functools.native_method
  def get_texture_origin(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))

    return _ret


  @functools.native_method
  def set_modulate(self, modulate:'Color'   ) -> None:
    r''''''

    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'

    self.py__modulate = modulate






    self._ptr.call_with_return(59,tuple([modulate._ptr]))

  @functools.native_method
  def get_modulate(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))

    return _ret


  @functools.native_method
  def set_z_index(self, z_index:'int'   ) -> None:
    r''''''

    assert isinstance(z_index, (int, float)), 'z_index must be int or float'

    self.py__z_index = z_index






    self._ptr.call_with_return(61,tuple([z_index]))

  @functools.native_method
  def get_z_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([]))

    return _ret


  @functools.native_method
  def set_y_sort_origin(self, y_sort_origin:'int'   ) -> None:
    r''''''

    assert isinstance(y_sort_origin, (int, float)), 'y_sort_origin must be int or float'

    self.py__y_sort_origin = y_sort_origin






    self._ptr.call_with_return(63,tuple([y_sort_origin]))

  @functools.native_method
  def get_y_sort_origin(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([]))

    return _ret


  @functools.native_method
  def set_occluder_polygons_count(self, layer_id:'int'   , polygons_count:'int'   ) -> None:
    r'''
				Sets the occluder polygon count in the TileSet occlusion layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygons_count, (int, float)), 'polygons_count must be int or float'







    self._ptr.call_with_return(65,tuple([layer_id, polygons_count]))

  @functools.native_method
  def get_occluder_polygons_count(self, layer_id:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of occluder polygons of the tile in the TileSet occlusion layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([layer_id]))
    return _ret


  @functools.native_method
  def add_occluder_polygon(self, layer_id:'int'   ) -> None:
    r'''
				Adds an occlusion polygon to the tile on the TileSet occlusion layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'






    self._ptr.call_with_return(67,tuple([layer_id]))

  @functools.native_method
  def remove_occluder_polygon(self, layer_id:'int'   , polygon_index:'int'   ) -> None:
    r'''
				Removes the polygon at index `polygon_index` for TileSet occlusion layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'







    self._ptr.call_with_return(68,tuple([layer_id, polygon_index]))

  @functools.native_method
  def set_occluder_polygon(self, layer_id:'int'   , polygon_index:'int'   , polygon:'py4godot_occluderpolygon2d.OccluderPolygon2D'   ) -> None:
    r'''
				Sets the occluder for polygon with index `polygon_index` in the TileSet occlusion layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'
    assert(not polygon is None)
    assert isinstance(polygon, get_class('OccluderPolygon2D')), 'polygon must be OccluderPolygon2D'








    self._ptr.call_with_return(69,tuple([layer_id, polygon_index, polygon._ptr]))

  @functools.native_method
  def get_occluder_polygon(self, layer_id:'int'   , polygon_index:'int'   , flip_h:'bool' =False  , flip_v:'bool' =False  , transpose:'bool' =False  ) -> typing.Union['py4godot_occluderpolygon2d.OccluderPolygon2D']:
    r'''
				Returns the occluder polygon at index `polygon_index` from the TileSet occlusion layer with index `layer_id`.
				The `flip_h`, `flip_v`, and `transpose` parameters can be `true` to transform the returned polygon.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'
    assert isinstance(flip_h, bool), 'flip_h must be bool'
    assert isinstance(flip_v, bool), 'flip_v must be bool'
    assert isinstance(transpose, bool), 'transpose must be bool'










    _ret = classes.Object.Object.construct_without_init() #Smart casted to: OccluderPolygon2D
    _ret._ptr = self._ptr.call_with_return(70,tuple([layer_id, polygon_index, flip_h, flip_v, transpose]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_occluder(self, layer_id:'int'   , occluder_polygon:'py4godot_occluderpolygon2d.OccluderPolygon2D'   ) -> None:
    r'''
				Sets the occluder for the TileSet occlusion layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert(not occluder_polygon is None)
    assert isinstance(occluder_polygon, get_class('OccluderPolygon2D')), 'occluder_polygon must be OccluderPolygon2D'







    self._ptr.call_with_return(71,tuple([layer_id, occluder_polygon._ptr]))

  @functools.native_method
  def get_occluder(self, layer_id:'int'   , flip_h:'bool' =False  , flip_v:'bool' =False  , transpose:'bool' =False  ) -> typing.Union['py4godot_occluderpolygon2d.OccluderPolygon2D']:
    r'''
				Returns the occluder polygon of the tile for the TileSet occlusion layer with index `layer_id`.
				`flip_h`, `flip_v`, and `transpose` allow transforming the returned polygon.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(flip_h, bool), 'flip_h must be bool'
    assert isinstance(flip_v, bool), 'flip_v must be bool'
    assert isinstance(transpose, bool), 'transpose must be bool'









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: OccluderPolygon2D
    _ret._ptr = self._ptr.call_with_return(72,tuple([layer_id, flip_h, flip_v, transpose]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_constant_linear_velocity(self, layer_id:'int'   , velocity:'Vector2'   ) -> None:
    r'''
				Sets the constant linear velocity. This does not move the tile. This linear velocity is applied to objects colliding with this tile. This is useful to create conveyor belts.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert(not velocity is None)
    assert isinstance(velocity, Vector2), 'velocity must be Vector2'







    self._ptr.call_with_return(73,tuple([layer_id, velocity._ptr]))

  @functools.native_method
  def get_constant_linear_velocity(self, layer_id:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the constant linear velocity applied to objects colliding with this tile.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'






    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([layer_id]))
    return _ret


  @functools.native_method
  def set_constant_angular_velocity(self, layer_id:'int'   , velocity:'float'   ) -> None:
    r'''
				Sets the constant angular velocity. This does not rotate the tile. This angular velocity is applied to objects colliding with this tile.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(velocity, (int, float)), 'velocity must be int or float'







    self._ptr.call_with_return(75,tuple([layer_id, velocity]))

  @functools.native_method
  def get_constant_angular_velocity(self, layer_id:'int'   ) -> typing.Union[float]:
    r'''
				Returns the constant angular velocity applied to objects colliding with this tile.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(76,tuple([layer_id]))
    return _ret


  @functools.native_method
  def set_collision_polygons_count(self, layer_id:'int'   , polygons_count:'int'   ) -> None:
    r'''
				Sets the polygons count for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygons_count, (int, float)), 'polygons_count must be int or float'







    self._ptr.call_with_return(77,tuple([layer_id, polygons_count]))

  @functools.native_method
  def get_collision_polygons_count(self, layer_id:'int'   ) -> typing.Union[int]:
    r'''
				Returns how many polygons the tile has for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([layer_id]))
    return _ret


  @functools.native_method
  def add_collision_polygon(self, layer_id:'int'   ) -> None:
    r'''
				Adds a collision polygon to the tile on the given TileSet physics layer.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'






    self._ptr.call_with_return(79,tuple([layer_id]))

  @functools.native_method
  def remove_collision_polygon(self, layer_id:'int'   , polygon_index:'int'   ) -> None:
    r'''
				Removes the polygon at index `polygon_index` for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'







    self._ptr.call_with_return(80,tuple([layer_id, polygon_index]))

  @functools.native_method
  def set_collision_polygon_points(self, layer_id:'int'   , polygon_index:'int'   , polygon:'PackedVector2Array'   ) -> None:
    r'''
				Sets the points of the polygon at index `polygon_index` for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'
    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'








    self._ptr.call_with_return(81,tuple([layer_id, polygon_index, polygon._ptr]))

  @functools.native_method
  def get_collision_polygon_points(self, layer_id:'int'   , polygon_index:'int'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns the points of the polygon at index `polygon_index` for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'







    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([layer_id, polygon_index]))
    return _ret


  @functools.native_method
  def set_collision_polygon_one_way(self, layer_id:'int'   , polygon_index:'int'   , one_way:'bool'   ) -> None:
    r'''
				Enables/disables one-way collisions on the polygon at index `polygon_index` for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'
    assert isinstance(one_way, bool), 'one_way must be bool'








    self._ptr.call_with_return(83,tuple([layer_id, polygon_index, one_way]))

  @functools.native_method
  def is_collision_polygon_one_way(self, layer_id:'int'   , polygon_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether one-way collisions are enabled for the polygon at index `polygon_index` for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([layer_id, polygon_index]))
    return _ret


  @functools.native_method
  def set_collision_polygon_one_way_margin(self, layer_id:'int'   , polygon_index:'int'   , one_way_margin:'float'   ) -> None:
    r'''
				Sets the one-way margin (for one-way platforms) of the polygon at index `polygon_index` for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'
    assert isinstance(one_way_margin, (int, float)), 'one_way_margin must be int or float'








    self._ptr.call_with_return(85,tuple([layer_id, polygon_index, one_way_margin]))

  @functools.native_method
  def get_collision_polygon_one_way_margin(self, layer_id:'int'   , polygon_index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the one-way margin (for one-way platforms) of the polygon at index `polygon_index` for TileSet physics layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(polygon_index, (int, float)), 'polygon_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([layer_id, polygon_index]))
    return _ret


  @functools.native_method
  def set_terrain_set(self, terrain_set:'int'   ) -> None:
    r''''''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'

    self.py__terrain_set = terrain_set






    self._ptr.call_with_return(87,tuple([terrain_set]))

  @functools.native_method
  def get_terrain_set(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_terrain(self, terrain:'int'   ) -> None:
    r''''''

    assert isinstance(terrain, (int, float)), 'terrain must be int or float'

    self.py__terrain = terrain






    self._ptr.call_with_return(89,tuple([terrain]))

  @functools.native_method
  def get_terrain(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_terrain_peering_bit(self, peering_bit:'int'  , terrain:'int'   ) -> None:
    r'''
				Sets the tile's terrain bit for the given `peering_bit` direction. To check that a direction is valid, use `is_valid_terrain_peering_bit`.
			'''

    assert isinstance(peering_bit, (int, float)), 'peering_bit must be int or float'
    assert isinstance(terrain, (int, float)), 'terrain must be int or float'







    self._ptr.call_with_return(91,tuple([peering_bit, terrain]))

  @functools.native_method
  def get_terrain_peering_bit(self, peering_bit:'int'  ) -> typing.Union[int]:
    r'''
				Returns the tile's terrain bit for the given `peering_bit` direction. To check that a direction is valid, use `is_valid_terrain_peering_bit`.
			'''

    assert isinstance(peering_bit, (int, float)), 'peering_bit must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([peering_bit]))
    return _ret


  @functools.native_method
  def is_valid_terrain_peering_bit(self, peering_bit:'int'  ) -> typing.Union[bool]:
    r'''
				Returns whether the given `peering_bit` direction is valid for this tile.
			'''

    assert isinstance(peering_bit, (int, float)), 'peering_bit must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([peering_bit]))
    return _ret


  @functools.native_method
  def set_navigation_polygon(self, layer_id:'int'   , navigation_polygon:'py4godot_navigationpolygon.NavigationPolygon'   ) -> None:
    r'''
				Sets the navigation polygon for the TileSet navigation layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert(not navigation_polygon is None)
    assert isinstance(navigation_polygon, get_class('NavigationPolygon')), 'navigation_polygon must be NavigationPolygon'







    self._ptr.call_with_return(94,tuple([layer_id, navigation_polygon._ptr]))

  @functools.native_method
  def get_navigation_polygon(self, layer_id:'int'   , flip_h:'bool' =False  , flip_v:'bool' =False  , transpose:'bool' =False  ) -> typing.Union['py4godot_navigationpolygon.NavigationPolygon']:
    r'''
				Returns the navigation polygon of the tile for the TileSet navigation layer with index `layer_id`.
				`flip_h`, `flip_v`, and `transpose` allow transforming the returned polygon.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    assert isinstance(flip_h, bool), 'flip_h must be bool'
    assert isinstance(flip_v, bool), 'flip_v must be bool'
    assert isinstance(transpose, bool), 'transpose must be bool'









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: NavigationPolygon
    _ret._ptr = self._ptr.call_with_return(95,tuple([layer_id, flip_h, flip_v, transpose]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_probability(self, probability:'float'   ) -> None:
    r''''''

    assert isinstance(probability, (int, float)), 'probability must be int or float'

    self.py__probability = probability






    self._ptr.call_with_return(96,tuple([probability]))

  @functools.native_method
  def get_probability(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def set_custom_data(self, layer_name:'str'   , value:'object'   ) -> None:
    r'''
				Sets the tile's custom data value for the TileSet custom data layer with name `layer_name`.
			'''

    assert(not layer_name is None)
    assert isinstance(layer_name, (str, String)), 'layer_name must be str or String'
    




    assert(isinstance(layer_name, (str, String)))
    py_string_layer_name = layer_name if isinstance(layer_name, StringName) else c_utils.py_string_to_string(layer_name)


    self._ptr.call_with_return(98,tuple([py_string_layer_name._ptr, value]))

  @functools.native_method
  def get_custom_data(self, layer_name:'str'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the custom data value for custom data layer named `layer_name`. To check if a custom data layer exists, use `has_custom_data`.
			'''

    assert(not layer_name is None)
    assert isinstance(layer_name, (str, String)), 'layer_name must be str or String'




    assert(isinstance(layer_name, (str, String)))
    py_string_layer_name = layer_name if isinstance(layer_name, StringName) else c_utils.py_string_to_string(layer_name)

    _ret = None
    _ret = self._ptr.call_with_return(99,tuple([py_string_layer_name._ptr]))
    return _ret


  @functools.native_method
  def has_custom_data(self, layer_name:'str'   ) -> typing.Union[bool]:
    r'''
				Returns whether there exists a custom data layer named `layer_name`.
			'''

    assert(not layer_name is None)
    assert isinstance(layer_name, (str, String)), 'layer_name must be str or String'




    assert(isinstance(layer_name, (str, String)))
    py_string_layer_name = layer_name if isinstance(layer_name, StringName) else c_utils.py_string_to_string(layer_name)

    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([py_string_layer_name._ptr]))
    return _ret


  @functools.native_method
  def set_custom_data_by_layer_id(self, layer_id:'int'   , value:'object'   ) -> None:
    r'''
				Sets the tile's custom data value for the TileSet custom data layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'
    







    self._ptr.call_with_return(101,tuple([layer_id, value]))

  @functools.native_method
  def get_custom_data_by_layer_id(self, layer_id:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the custom data value for custom data layer with index `layer_id`.
			'''

    assert isinstance(layer_id, (int, float)), 'layer_id must be int or float'






    _ret = None
    _ret = self._ptr.call_with_return(102,tuple([layer_id]))
    return _ret



register_cast_function('TileData', TileData.cast)
register_class('TileData', TileData)
