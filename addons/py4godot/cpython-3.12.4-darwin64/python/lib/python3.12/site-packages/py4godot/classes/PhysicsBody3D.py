# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.KinematicCollision3D as py4godot_kinematiccollision3d 
  import py4godot.classes.PhysicsServer3D as py4godot_physicsserver3d 
  import py4godot.classes.PhysicsBody3DTypedArray as py4godot_physicsbody3dtypedarray 
  import py4godot.classes.Node as py4godot_node 
import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
import py4godot.classes.PhysicsBody3DTypedArray as py4godot_physicsbody3dtypedarray 
from py4godot.wrappers.wrappers import CPPPhysicsBody3DWrapper


class PhysicsBody3D(py4godot_collisionobject3d.CollisionObject3D):
  r'''
		`PhysicsBody3D` is an abstract base class for 3D game objects affected by physics. All 3D physics bodies inherit from it.
		**Warning:** With a non-uniform scale, this node will likely not behave as expected. It is advised to keep its scale the same on all axes and adjust its collision shape(s) instead.
	'''

  @staticmethod
  def constructor():
    class_ = PhysicsBody3D.construct_without_init()
    class_._ptr = constructor(590,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PhysicsBody3D.construct_without_init()
    class_._ptr = constructor(590,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPhysicsBody3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(590,0, ())


  def generate_wrapper(self):
    return CPPPhysicsBody3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PhysicsBody3D.__new__(PhysicsBody3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PhysicsBody3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsBody3D.construct_without_init()
    cls._ptr = CPPPhysicsBody3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsBody3D.construct_without_init()
    cls._ptr = CPPPhysicsBody3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def axis_lock_linear_x(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_axis_lock(1)
    return _ret
  @axis_lock_linear_x.setter
  def axis_lock_linear_x(self,  value:'bool'):
    self.set_axis_lock(value)
  @property
  def axis_lock_linear_y(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_axis_lock(2)
    return _ret
  @axis_lock_linear_y.setter
  def axis_lock_linear_y(self,  value:'bool'):
    self.set_axis_lock(value)
  @property
  def axis_lock_linear_z(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_axis_lock(4)
    return _ret
  @axis_lock_linear_z.setter
  def axis_lock_linear_z(self,  value:'bool'):
    self.set_axis_lock(value)
  @property
  def axis_lock_angular_x(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_axis_lock(8)
    return _ret
  @axis_lock_angular_x.setter
  def axis_lock_angular_x(self,  value:'bool'):
    self.set_axis_lock(value)
  @property
  def axis_lock_angular_y(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_axis_lock(16)
    return _ret
  @axis_lock_angular_y.setter
  def axis_lock_angular_y(self,  value:'bool'):
    self.set_axis_lock(value)
  @property
  def axis_lock_angular_z(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_axis_lock(32)
    return _ret
  @axis_lock_angular_z.setter
  def axis_lock_angular_z(self,  value:'bool'):
    self.set_axis_lock(value)
  @functools.native_method
  def move_and_collide(self, motion:'Vector3'   , test_only:'bool' =False  , safe_margin:'float' =0.001  , recovery_as_collision:'bool' =False  , max_collisions:'int' =1  ) -> typing.Union['py4godot_kinematiccollision3d.KinematicCollision3D']:
    r'''
				Moves the body along the vector `motion`. In order to be frame rate independent in `Node._physics_process` or `Node._process`, `motion` should be computed using `delta`.
				The body will stop if it collides. Returns a `KinematicCollision3D`, which contains information about the collision when stopped, or when touching another body along the motion.
				If `test_only` is `true`, the body does not move but the would-be collision information is given.
				`safe_margin` is the extra margin used for collision recovery (see `CharacterBody3D.safe_margin` for more details).
				If `recovery_as_collision` is `true`, any depenetration from the recovery phase is also reported as a collision; this is used e.g. by `CharacterBody3D` for improving floor detection during floor snapping.
				`max_collisions` allows to retrieve more than one collision result.
			'''

    assert(not motion is None)
    assert isinstance(motion, Vector3), 'motion must be Vector3'
    assert isinstance(test_only, bool), 'test_only must be bool'
    assert isinstance(safe_margin, (int, float)), 'safe_margin must be int or float'
    assert isinstance(recovery_as_collision, bool), 'recovery_as_collision must be bool'
    assert isinstance(max_collisions, (int, float)), 'max_collisions must be int or float'










    _ret = classes.Object.Object.construct_without_init() #Smart casted to: KinematicCollision3D
    _ret._ptr = self._ptr.call_with_return(286,tuple([motion._ptr, test_only, safe_margin, recovery_as_collision, max_collisions]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def test_move(self, from_:'Transform3D'   , motion:'Vector3'   , collision:'py4godot_kinematiccollision3d.KinematicCollision3D' = None  , safe_margin:'float' =0.001  , recovery_as_collision:'bool' =False  , max_collisions:'int' =1  ) -> typing.Union[bool]:
    r'''
				Checks for collisions without moving the body. In order to be frame rate independent in `Node._physics_process` or `Node._process`, `motion` should be computed using `delta`.
				Virtually sets the node's position, scale and rotation to that of the given `Transform3D`, then tries to move the body along the vector `motion`. Returns `true` if a collision would stop the body from moving along the whole path.
				`collision` is an optional object of type `KinematicCollision3D`, which contains additional information about the collision when stopped, or when touching another body along the motion.
				`safe_margin` is the extra margin used for collision recovery (see `CharacterBody3D.safe_margin` for more details).
				If `recovery_as_collision` is `true`, any depenetration from the recovery phase is also reported as a collision; this is useful for checking whether the body would _touch_ any other bodies.
				`max_collisions` allows to retrieve more than one collision result.
			'''
    if collision is None:
      collision = c_utils.empty_object
    if collision is None:
      collision = c_utils.empty_object

    assert(not from_ is None)
    assert isinstance(from_, Transform3D), 'from_ must be Transform3D'
    assert(not motion is None)
    assert isinstance(motion, Vector3), 'motion must be Vector3'
    assert isinstance(safe_margin, (int, float)), 'safe_margin must be int or float'
    assert isinstance(recovery_as_collision, bool), 'recovery_as_collision must be bool'
    assert isinstance(max_collisions, (int, float)), 'max_collisions must be int or float'











    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([from_._ptr, motion._ptr, collision._ptr, safe_margin, recovery_as_collision, max_collisions]))
    return _ret


  @functools.native_method
  def get_gravity(self) -> typing.Union['Vector3']:
    r'''
				Returns the gravity vector computed from all sources that can affect the body, including all gravity overrides from `Area3D` nodes and the global world gravity.
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(288,tuple([]))
    return _ret


  @functools.native_method
  def set_axis_lock(self, axis:'int'  , lock:'bool'   ) -> None:
    r'''
				Locks or unlocks the specified linear or rotational `axis` depending on the value of `lock`.
			'''

    assert isinstance(axis, (int, float)), 'axis must be int or float'
    assert isinstance(lock, bool), 'lock must be bool'

    self.py__axis_lock_linear_x = axis







    self._ptr.call_with_return(289,tuple([axis, lock]))

  @functools.native_method
  def get_axis_lock(self, axis:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified linear or rotational `axis` is locked.
			'''

    assert isinstance(axis, (int, float)), 'axis must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(290,tuple([axis]))

    return _ret


  @functools.native_method
  def get_collision_exceptions(self) -> typing.Union['py4godot_physicsbody3dtypedarray.PhysicsBody3DTypedArray']:
    r'''
				Returns an array of nodes that were added as collision exceptions for this body.
			'''




    _ret = py4godot_physicsbody3dtypedarray.PhysicsBody3DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(291,tuple([]))
    return _ret


  @functools.native_method
  def add_collision_exception_with(self, body:'py4godot_node.Node'   ) -> None:
    r'''
				Adds a body to the list of bodies that this body can't collide with.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'






    self._ptr.call_with_return(292,tuple([body._ptr]))

  @functools.native_method
  def remove_collision_exception_with(self, body:'py4godot_node.Node'   ) -> None:
    r'''
				Removes a body from the list of bodies that this body can't collide with.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'






    self._ptr.call_with_return(293,tuple([body._ptr]))


register_cast_function('PhysicsBody3D', PhysicsBody3D.cast)
register_class('PhysicsBody3D', PhysicsBody3D)
