# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
import py4godot.classes.GraphElement as py4godot_graphelement 
from py4godot.wrappers.wrappers import CPPGraphNodeWrapper


class GraphNode(py4godot_graphelement.GraphElement):
  r'''
		`GraphNode` allows to create nodes for a `GraphEdit` graph with customizable content based on its child controls. `GraphNode` is derived from `Container` and it is responsible for placing its children on screen. This works similar to `VBoxContainer`. Children, in turn, provide `GraphNode` with so-called slots, each of which can have a connection port on either side.
		Each `GraphNode` slot is defined by its index and can provide the node with up to two ports: one on the left, and one on the right. By convention the left port is also referred to as the **input port** and the right port is referred to as the **output port**. Each port can be enabled and configured individually, using different type and color. The type is an arbitrary value that you can define using your own considerations. The parent `GraphEdit` will receive this information on each connect and disconnect request.
		Slots can be configured in the Inspector dock once you add at least one child `Control`. The properties are grouped by each slot's index in the "Slot" section.
		**Note:** While GraphNode is set up using slots and slot indices, connections are made between the ports which are enabled. Because of that `GraphEdit` uses the port's index and not the slot's index. You can use `get_input_port_slot` and `get_output_port_slot` to get the slot index from the port index.
	'''

  @staticmethod
  def constructor():
    class_ = GraphNode.construct_without_init()
    class_._ptr = constructor(385,0, ())
    return class_
  @staticmethod
  def new():
    class_ = GraphNode.construct_without_init()
    class_._ptr = constructor(385,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGraphNodeWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(385,0, ())


  def generate_wrapper(self):
    return CPPGraphNodeWrapper()
  def init_signals(self):
    super().init_signals()
    slot_updated_name = utils.py_string_to_string_name("slot_updated")
    self.slot_updated = signals.BuiltinSignal(self, slot_updated_name)
    slot_sizes_changed_name = utils.py_string_to_string_name("slot_sizes_changed")
    self.slot_sizes_changed = signals.BuiltinSignal(self, slot_sizes_changed_name)

  @staticmethod
  def construct_without_init():
    cls = GraphNode.__new__(GraphNode)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GraphNode'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = GraphNode.construct_without_init()
    cls._ptr = CPPGraphNodeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = GraphNode.construct_without_init()
    cls._ptr = CPPGraphNodeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def title(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_title()
    return _ret
  @title.setter
  def title(self,  value:'str'):
    self.set_title(value)
  @property
  def ignore_invalid_connection_type(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ignoring_valid_connection_type()
    return _ret
  @ignore_invalid_connection_type.setter
  def ignore_invalid_connection_type(self,  value:'bool'):
    self.set_ignore_invalid_connection_type(value)
  @property
  def slots_focus_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_slots_focus_mode()
    return _ret
  @slots_focus_mode.setter
  def slots_focus_mode(self,  value:'int'):
    self.set_slots_focus_mode(value)
  @functools.native_method
  def _draw_port(self, slot_index:'int'   , position:'Vector2i'   , left:'bool'   , color:'Color'   ) -> None:
    r'''
'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert isinstance(left, bool), 'left must be bool'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'









    self._ptr.call_with_return(447,tuple([slot_index, position._ptr, left, color._ptr]))

  @functools.native_method
  def set_title(self, title:'str'   ) -> None:
    r''''''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'

    self.py__title = title



    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)

    py__string_title = utils.py_string_to_string(title)
    py__string_title.shouldBeDeleted = False


    self._ptr.call_with_return(448,tuple([py__string_title._ptr]))

  @functools.native_method
  def get_title(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(449,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_titlebar_hbox(self) -> typing.Any:
    r'''
				Returns the `HBoxContainer` used for the title bar, only containing a `Label` for displaying the title by default. This can be used to add custom controls to the title bar such as option or close buttons.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: HBoxContainer
    _ret._ptr = self._ptr.call_with_return(450,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_slot(self, slot_index:'int'   , enable_left_port:'bool'   , type_left:'int'   , color_left:'Color'   , enable_right_port:'bool'   , type_right:'int'   , color_right:'Color'   , custom_icon_left:'py4godot_texture2d.Texture2D' = None  , custom_icon_right:'py4godot_texture2d.Texture2D' = None  , draw_stylebox:'bool' =True  ) -> None:
    r'''
				Sets properties of the slot with the given `slot_index`.
				If `enable_left_port`/`enable_right_port` is `true`, a port will appear and the slot will be able to be connected from this side.
				With `type_left`/`type_right` an arbitrary type can be assigned to each port. Two ports can be connected if they share the same type, or if the connection between their types is allowed in the parent `GraphEdit` (see `GraphEdit.add_valid_connection_type`). Keep in mind that the `GraphEdit` has the final say in accepting the connection. Type compatibility simply allows the `signal GraphEdit.connection_request` signal to be emitted.
				Ports can be further customized using `color_left`/`color_right` and `custom_icon_left`/`custom_icon_right`. The color parameter adds a tint to the icon. The custom icon can be used to override the default port dot.
				Additionally, `draw_stylebox` can be used to enable or disable drawing of the background stylebox for each slot. See `theme_item slot`.
				Individual properties can also be set using one of the `set_slot_*` methods.
				**Note:** This method only sets properties of the slot. To create the slot itself, add a `Control`-derived child to the GraphNode.
			'''
    if custom_icon_left is None:
      custom_icon_left = c_utils.empty_object
    if custom_icon_right is None:
      custom_icon_right = c_utils.empty_object
    if custom_icon_left is None:
      custom_icon_left = c_utils.empty_object
    if custom_icon_right is None:
      custom_icon_right = c_utils.empty_object

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert isinstance(enable_left_port, bool), 'enable_left_port must be bool'
    assert isinstance(type_left, (int, float)), 'type_left must be int or float'
    assert(not color_left is None)
    assert isinstance(color_left, Color), 'color_left must be Color'
    assert isinstance(enable_right_port, bool), 'enable_right_port must be bool'
    assert isinstance(type_right, (int, float)), 'type_right must be int or float'
    assert(not color_right is None)
    assert isinstance(color_right, Color), 'color_right must be Color'
    assert isinstance(draw_stylebox, bool), 'draw_stylebox must be bool'















    self._ptr.call_with_return(451,tuple([slot_index, enable_left_port, type_left, color_left._ptr, enable_right_port, type_right, color_right._ptr, custom_icon_left._ptr, custom_icon_right._ptr, draw_stylebox]))

  @functools.native_method
  def clear_slot(self, slot_index:'int'   ) -> None:
    r'''
				Disables the slot with the given `slot_index`. This will remove the corresponding input and output port from the GraphNode.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    self._ptr.call_with_return(452,tuple([slot_index]))

  @functools.native_method
  def clear_all_slots(self) -> None:
    r'''
				Disables all slots of the GraphNode. This will remove all input/output ports from the GraphNode.
			'''




    self._ptr.call_with_return(453,tuple([]))

  @functools.native_method
  def is_slot_enabled_left(self, slot_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if left (input) side of the slot with the given `slot_index` is enabled.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(454,tuple([slot_index]))
    return _ret


  @functools.native_method
  def set_slot_enabled_left(self, slot_index:'int'   , enable:'bool'   ) -> None:
    r'''
				Toggles the left (input) side of the slot with the given `slot_index`. If `enable` is `true`, a port will appear on the left side and the slot will be able to be connected from this side.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(455,tuple([slot_index, enable]))

  @functools.native_method
  def set_slot_type_left(self, slot_index:'int'   , type:'int'   ) -> None:
    r'''
				Sets the left (input) type of the slot with the given `slot_index` to `type`. If the value is negative, all connections will be disallowed to be created via user inputs.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'







    self._ptr.call_with_return(456,tuple([slot_index, type]))

  @functools.native_method
  def get_slot_type_left(self, slot_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the left (input) type of the slot with the given `slot_index`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([slot_index]))
    return _ret


  @functools.native_method
  def set_slot_color_left(self, slot_index:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the `Color` of the left (input) side of the slot with the given `slot_index` to `color`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(458,tuple([slot_index, color._ptr]))

  @functools.native_method
  def get_slot_color_left(self, slot_index:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the left (input) `Color` of the slot with the given `slot_index`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(459,tuple([slot_index]))
    return _ret


  @functools.native_method
  def set_slot_custom_icon_left(self, slot_index:'int'   , custom_icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the custom `Texture2D` of the left (input) side of the slot with the given `slot_index` to `custom_icon`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert(not custom_icon is None)
    assert isinstance(custom_icon, get_class('Texture2D')), 'custom_icon must be Texture2D'







    self._ptr.call_with_return(460,tuple([slot_index, custom_icon._ptr]))

  @functools.native_method
  def get_slot_custom_icon_left(self, slot_index:'int'   ) -> typing.Any:
    r'''
				Returns the left (input) custom `Texture2D` of the slot with the given `slot_index`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(461,tuple([slot_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_slot_enabled_right(self, slot_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if right (output) side of the slot with the given `slot_index` is enabled.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(462,tuple([slot_index]))
    return _ret


  @functools.native_method
  def set_slot_enabled_right(self, slot_index:'int'   , enable:'bool'   ) -> None:
    r'''
				Toggles the right (output) side of the slot with the given `slot_index`. If `enable` is `true`, a port will appear on the right side and the slot will be able to be connected from this side.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(463,tuple([slot_index, enable]))

  @functools.native_method
  def set_slot_type_right(self, slot_index:'int'   , type:'int'   ) -> None:
    r'''
				Sets the right (output) type of the slot with the given `slot_index` to `type`. If the value is negative, all connections will be disallowed to be created via user inputs.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'







    self._ptr.call_with_return(464,tuple([slot_index, type]))

  @functools.native_method
  def get_slot_type_right(self, slot_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the right (output) type of the slot with the given `slot_index`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(465,tuple([slot_index]))
    return _ret


  @functools.native_method
  def set_slot_color_right(self, slot_index:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the `Color` of the right (output) side of the slot with the given `slot_index` to `color`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(466,tuple([slot_index, color._ptr]))

  @functools.native_method
  def get_slot_color_right(self, slot_index:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the right (output) `Color` of the slot with the given `slot_index`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(467,tuple([slot_index]))
    return _ret


  @functools.native_method
  def set_slot_custom_icon_right(self, slot_index:'int'   , custom_icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the custom `Texture2D` of the right (output) side of the slot with the given `slot_index` to `custom_icon`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert(not custom_icon is None)
    assert isinstance(custom_icon, get_class('Texture2D')), 'custom_icon must be Texture2D'







    self._ptr.call_with_return(468,tuple([slot_index, custom_icon._ptr]))

  @functools.native_method
  def get_slot_custom_icon_right(self, slot_index:'int'   ) -> typing.Any:
    r'''
				Returns the right (output) custom `Texture2D` of the slot with the given `slot_index`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(469,tuple([slot_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_slot_draw_stylebox(self, slot_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the background `StyleBox` of the slot with the given `slot_index` is drawn.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(470,tuple([slot_index]))
    return _ret


  @functools.native_method
  def set_slot_draw_stylebox(self, slot_index:'int'   , enable:'bool'   ) -> None:
    r'''
				Toggles the background `StyleBox` of the slot with the given `slot_index`.
			'''

    assert isinstance(slot_index, (int, float)), 'slot_index must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(471,tuple([slot_index, enable]))

  @functools.native_method
  def set_ignore_invalid_connection_type(self, ignore:'bool'   ) -> None:
    r''''''

    assert isinstance(ignore, bool), 'ignore must be bool'

    self.py__ignore_invalid_connection_type = ignore






    self._ptr.call_with_return(472,tuple([ignore]))

  @functools.native_method
  def is_ignoring_valid_connection_type(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(473,tuple([]))

    return _ret


  @functools.native_method
  def set_slots_focus_mode(self, focus_mode:'int'  ) -> None:
    r''''''

    assert isinstance(focus_mode, (int, float)), 'focus_mode must be int or float'

    self.py__slots_focus_mode = focus_mode






    self._ptr.call_with_return(474,tuple([focus_mode]))

  @functools.native_method
  def get_slots_focus_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(475,tuple([]))

    return _ret


  @functools.native_method
  def get_input_port_count(self) -> typing.Union[int]:
    r'''
				Returns the number of slots with an enabled input port.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(476,tuple([]))
    return _ret


  @functools.native_method
  def get_input_port_position(self, port_idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the input port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(477,tuple([port_idx]))
    return _ret


  @functools.native_method
  def get_input_port_type(self, port_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the type of the input port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(478,tuple([port_idx]))
    return _ret


  @functools.native_method
  def get_input_port_color(self, port_idx:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the `Color` of the input port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(479,tuple([port_idx]))
    return _ret


  @functools.native_method
  def get_input_port_slot(self, port_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the corresponding slot index of the input port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(480,tuple([port_idx]))
    return _ret


  @functools.native_method
  def get_output_port_count(self) -> typing.Union[int]:
    r'''
				Returns the number of slots with an enabled output port.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(481,tuple([]))
    return _ret


  @functools.native_method
  def get_output_port_position(self, port_idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the output port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(482,tuple([port_idx]))
    return _ret


  @functools.native_method
  def get_output_port_type(self, port_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the type of the output port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(483,tuple([port_idx]))
    return _ret


  @functools.native_method
  def get_output_port_color(self, port_idx:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the `Color` of the output port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(484,tuple([port_idx]))
    return _ret


  @functools.native_method
  def get_output_port_slot(self, port_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the corresponding slot index of the output port with the given `port_idx`.
			'''

    assert isinstance(port_idx, (int, float)), 'port_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(485,tuple([port_idx]))
    return _ret



register_cast_function('GraphNode', GraphNode.cast)
register_class('GraphNode', GraphNode)
