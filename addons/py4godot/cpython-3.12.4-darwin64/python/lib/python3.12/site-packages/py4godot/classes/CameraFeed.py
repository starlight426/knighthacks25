# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.CameraServer as py4godot_cameraserver 
  import py4godot.classes.Image as py4godot_image 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPCameraFeedWrapper

class FeedDataType:
  FEED_NOIMAGE = 0
  FEED_RGB = 1
  FEED_YCBCR = 2
  FEED_YCBCR_SEP = 3
  FEED_EXTERNAL = 4
class FeedPosition:
  FEED_UNSPECIFIED = 0
  FEED_FRONT = 1
  FEED_BACK = 2


class CameraFeed(py4godot_refcounted.RefCounted):
  r'''
		A camera feed gives you access to a single physical camera attached to your device. When enabled, Godot will start capturing frames from the camera which can then be used. See also `CameraServer`.
		**Note:** Many cameras will return YCbCr images which are split into two textures and need to be combined in a shader. Godot does this automatically for you if you set the environment to show the camera image in the background.
		**Note:** This class is currently only implemented on Linux, Android, macOS, and iOS. On other platforms no `CameraFeed`s will be available. To get a `CameraFeed` on iOS, the camera plugin from `url=https://github.com/godotengine/godot-ios-plugins`godot-ios-plugins`/url` is required.
	'''

  @staticmethod
  def constructor():
    class_ = CameraFeed.construct_without_init()
    class_._ptr = constructor(193,0, ())
    return class_
  @staticmethod
  def new():
    class_ = CameraFeed.construct_without_init()
    class_._ptr = constructor(193,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCameraFeedWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(193,0, ())


  def generate_wrapper(self):
    return CPPCameraFeedWrapper()
  def init_signals(self):
    super().init_signals()
    frame_changed_name = utils.py_string_to_string_name("frame_changed")
    self.frame_changed = signals.BuiltinSignal(self, frame_changed_name)
    format_changed_name = utils.py_string_to_string_name("format_changed")
    self.format_changed = signals.BuiltinSignal(self, format_changed_name)

  @staticmethod
  def construct_without_init():
    cls = CameraFeed.__new__(CameraFeed)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'CameraFeed'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = CameraFeed.construct_without_init()
    cls._ptr = CPPCameraFeedWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = CameraFeed.construct_without_init()
    cls._ptr = CPPCameraFeedWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def feed_is_active(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_active()
    return _ret
  @feed_is_active.setter
  def feed_is_active(self,  value:'bool'):
    self.set_active(value)
  @property
  def feed_transform(self) -> typing.Union['Transform2D']:
    r''''''
    _ret = self. get_transform()
    return _ret
  @feed_transform.setter
  def feed_transform(self,  value:'Transform2D'):
    self.set_transform(value)
  @property
  def formats(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_formats()
    return _ret
  @functools.native_method
  def _activate_feed(self) -> typing.Union[bool]:
    r'''
				Called when the camera feed is activated.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def _deactivate_feed(self) -> None:
    r'''
				Called when the camera feed is deactivated.
			'''




    self._ptr.call_with_return(54,tuple([]))

  @functools.native_method
  def get_id(self) -> typing.Union[int]:
    r'''
				Returns the unique ID for this feed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def is_active(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))

    return _ret


  @functools.native_method
  def set_active(self, active:'bool'   ) -> None:
    r''''''

    assert isinstance(active, bool), 'active must be bool'

    self.py__feed_is_active = active






    self._ptr.call_with_return(57,tuple([active]))

  @functools.native_method
  def get_name(self) -> typing.Union[str]:
    r'''
				Returns the camera's name.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_name(self, name:'str'   ) -> None:
    r'''
				Sets the camera's name.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(59,tuple([py_string_name._ptr]))

  @functools.native_method
  def get_position(self) -> typing.Union[int]:
    r'''
				Returns the position of camera on the device.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(60,tuple([]))
    return _ret


  @functools.native_method
  def set_position(self, position:'int'  ) -> None:
    r'''
				Sets the position of this camera.
			'''

    assert isinstance(position, (int, float)), 'position must be int or float'






    self._ptr.call_with_return(61,tuple([position]))

  @functools.native_method
  def get_transform(self) -> typing.Union['Transform2D']:
    r''''''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))

    return _ret


  @functools.native_method
  def set_transform(self, transform:'Transform2D'   ) -> None:
    r''''''

    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'

    self.py__feed_transform = transform






    self._ptr.call_with_return(63,tuple([transform._ptr]))

  @functools.native_method
  def set_rgb_image(self, rgb_image:'py4godot_image.Image'   ) -> None:
    r'''
				Sets RGB image for this feed.
			'''

    assert(not rgb_image is None)
    assert isinstance(rgb_image, get_class('Image')), 'rgb_image must be Image'






    self._ptr.call_with_return(64,tuple([rgb_image._ptr]))

  @functools.native_method
  def set_ycbcr_image(self, ycbcr_image:'py4godot_image.Image'   ) -> None:
    r'''
				Sets YCbCr image for this feed.
			'''

    assert(not ycbcr_image is None)
    assert isinstance(ycbcr_image, get_class('Image')), 'ycbcr_image must be Image'






    self._ptr.call_with_return(65,tuple([ycbcr_image._ptr]))

  @functools.native_method
  def set_external(self, width:'int'   , height:'int'   ) -> None:
    r'''
				Sets the feed as external feed provided by another library.
			'''

    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'







    self._ptr.call_with_return(66,tuple([width, height]))

  @functools.native_method
  def get_texture_tex_id(self, feed_image_type:'int'  ) -> typing.Union[int]:
    r'''
				Returns the texture backend ID (usable by some external libraries that need a handle to a texture to write data).
			'''

    assert isinstance(feed_image_type, (int, float)), 'feed_image_type must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([feed_image_type]))
    return _ret


  @functools.native_method
  def get_datatype(self) -> typing.Union[int]:
    r'''
				Returns feed image data type.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(68,tuple([]))
    return _ret


  @functools.native_method
  def get_formats(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(69,tuple([]))

    return _ret


  @functools.native_method
  def set_format(self, index:'int'   , parameters:'Dictionary'   ) -> typing.Union[bool]:
    r'''
				Sets the feed format parameters for the given `index` in the `formats` array. Returns `true` on success. By default, the YUYV encoded stream is transformed to `constant FEED_RGB`. The YUYV encoded stream output format can be changed by setting `parameters`'s `output` entry to one of the following:
				- `"separate"` will result in `constant FEED_YCBCR_SEP`;
				- `"grayscale"` will result in desaturated `constant FEED_RGB`;
				- `"copy"` will result in `constant FEED_YCBCR`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not parameters is None)
    assert isinstance(parameters, Dictionary), 'parameters must be Dictionary'







    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([index, parameters._ptr]))
    return _ret



register_cast_function('CameraFeed', CameraFeed.cast)
register_class('CameraFeed', CameraFeed)
