# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.World3D as py4godot_world3d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.EditorCommandPalette as py4godot_editorcommandpalette 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.EditorFileDialog as py4godot_editorfiledialog 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.Popup as py4godot_popup 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.FileDialog as py4godot_filedialog 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.InputEvent as py4godot_inputevent 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.Camera2D as py4godot_camera2d 
  import py4godot.classes.SubViewport as py4godot_subviewport 
  import py4godot.classes.World2D as py4godot_world2d 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.Window as py4godot_window 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.ScriptCreateDialog as py4godot_scriptcreatedialog 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.WindowTypedArray as py4godot_windowtypedarray 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AudioListener2D as py4godot_audiolistener2d 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.AcceptDialog as py4godot_acceptdialog 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.PopupPanel as py4godot_popuppanel 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
import py4godot.classes.WindowTypedArray as py4godot_windowtypedarray 
import py4godot.classes.Node as py4godot_node 
from py4godot.wrappers.wrappers import CPPViewportWrapper

class PositionalShadowAtlasQuadrantSubdiv:
  SHADOW_ATLAS_QUADRANT_SUBDIV_DISABLED = 0
  SHADOW_ATLAS_QUADRANT_SUBDIV_1 = 1
  SHADOW_ATLAS_QUADRANT_SUBDIV_4 = 2
  SHADOW_ATLAS_QUADRANT_SUBDIV_16 = 3
  SHADOW_ATLAS_QUADRANT_SUBDIV_64 = 4
  SHADOW_ATLAS_QUADRANT_SUBDIV_256 = 5
  SHADOW_ATLAS_QUADRANT_SUBDIV_1024 = 6
  SHADOW_ATLAS_QUADRANT_SUBDIV_MAX = 7
class Scaling3DMode:
  SCALING_3D_MODE_BILINEAR = 0
  SCALING_3D_MODE_FSR = 1
  SCALING_3D_MODE_FSR2 = 2
  SCALING_3D_MODE_METALFX_SPATIAL = 3
  SCALING_3D_MODE_METALFX_TEMPORAL = 4
  SCALING_3D_MODE_MAX = 5
class MSAA:
  MSAA_DISABLED = 0
  MSAA_2X = 1
  MSAA_4X = 2
  MSAA_8X = 3
  MSAA_MAX = 4
class AnisotropicFiltering:
  ANISOTROPY_DISABLED = 0
  ANISOTROPY_2X = 1
  ANISOTROPY_4X = 2
  ANISOTROPY_8X = 3
  ANISOTROPY_16X = 4
  ANISOTROPY_MAX = 5
class ScreenSpaceAA:
  SCREEN_SPACE_AA_DISABLED = 0
  SCREEN_SPACE_AA_FXAA = 1
  SCREEN_SPACE_AA_SMAA = 2
  SCREEN_SPACE_AA_MAX = 3
class RenderInfo:
  RENDER_INFO_OBJECTS_IN_FRAME = 0
  RENDER_INFO_PRIMITIVES_IN_FRAME = 1
  RENDER_INFO_DRAW_CALLS_IN_FRAME = 2
  RENDER_INFO_MAX = 3
class RenderInfoType:
  RENDER_INFO_TYPE_VISIBLE = 0
  RENDER_INFO_TYPE_SHADOW = 1
  RENDER_INFO_TYPE_CANVAS = 2
  RENDER_INFO_TYPE_MAX = 3
class DebugDraw:
  DEBUG_DRAW_DISABLED = 0
  DEBUG_DRAW_UNSHADED = 1
  DEBUG_DRAW_LIGHTING = 2
  DEBUG_DRAW_OVERDRAW = 3
  DEBUG_DRAW_WIREFRAME = 4
  DEBUG_DRAW_NORMAL_BUFFER = 5
  DEBUG_DRAW_VOXEL_GI_ALBEDO = 6
  DEBUG_DRAW_VOXEL_GI_LIGHTING = 7
  DEBUG_DRAW_VOXEL_GI_EMISSION = 8
  DEBUG_DRAW_SHADOW_ATLAS = 9
  DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS = 10
  DEBUG_DRAW_SCENE_LUMINANCE = 11
  DEBUG_DRAW_SSAO = 12
  DEBUG_DRAW_SSIL = 13
  DEBUG_DRAW_PSSM_SPLITS = 14
  DEBUG_DRAW_DECAL_ATLAS = 15
  DEBUG_DRAW_SDFGI = 16
  DEBUG_DRAW_SDFGI_PROBES = 17
  DEBUG_DRAW_GI_BUFFER = 18
  DEBUG_DRAW_DISABLE_LOD = 19
  DEBUG_DRAW_CLUSTER_OMNI_LIGHTS = 20
  DEBUG_DRAW_CLUSTER_SPOT_LIGHTS = 21
  DEBUG_DRAW_CLUSTER_DECALS = 22
  DEBUG_DRAW_CLUSTER_REFLECTION_PROBES = 23
  DEBUG_DRAW_OCCLUDERS = 24
  DEBUG_DRAW_MOTION_VECTORS = 25
  DEBUG_DRAW_INTERNAL_BUFFER = 26
class DefaultCanvasItemTextureFilter:
  DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST = 0
  DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR = 1
  DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 2
  DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 3
  DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_MAX = 4
class DefaultCanvasItemTextureRepeat:
  DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_DISABLED = 0
  DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_ENABLED = 1
  DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MIRROR = 2
  DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MAX = 3
class SDFOversize:
  SDF_OVERSIZE_100_PERCENT = 0
  SDF_OVERSIZE_120_PERCENT = 1
  SDF_OVERSIZE_150_PERCENT = 2
  SDF_OVERSIZE_200_PERCENT = 3
  SDF_OVERSIZE_MAX = 4
class SDFScale:
  SDF_SCALE_100_PERCENT = 0
  SDF_SCALE_50_PERCENT = 1
  SDF_SCALE_25_PERCENT = 2
  SDF_SCALE_MAX = 3
class VRSMode:
  VRS_DISABLED = 0
  VRS_TEXTURE = 1
  VRS_XR = 2
  VRS_MAX = 3
class VRSUpdateMode:
  VRS_UPDATE_DISABLED = 0
  VRS_UPDATE_ONCE = 1
  VRS_UPDATE_ALWAYS = 2
  VRS_UPDATE_MAX = 3


class Viewport(py4godot_node.Node):
  r'''
		A `Viewport` creates a different view into the screen, or a sub-view inside another viewport. Child 2D nodes will display on it, and child Camera3D 3D nodes will render on it too.
		Optionally, a viewport can have its own 2D or 3D world, so it doesn't share what it draws with other viewports.
		Viewports can also choose to be audio listeners, so they generate positional audio depending on a 2D or 3D camera child of it.
		Also, viewports can be assigned to different screens in case the devices have multiple screens.
		Finally, viewports can also behave as render targets, in which case they will not be visible unless the associated texture is used to draw.
	'''

  @staticmethod
  def constructor():
    class_ = Viewport.construct_without_init()
    class_._ptr = constructor(872,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Viewport.construct_without_init()
    class_._ptr = constructor(872,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPViewportWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(872,0, ())


  def generate_wrapper(self):
    return CPPViewportWrapper()
  def init_signals(self):
    super().init_signals()
    size_changed_name = utils.py_string_to_string_name("size_changed")
    self.size_changed = signals.BuiltinSignal(self, size_changed_name)
    gui_focus_changed_name = utils.py_string_to_string_name("gui_focus_changed")
    self.gui_focus_changed = signals.BuiltinSignal(self, gui_focus_changed_name)

  @staticmethod
  def construct_without_init():
    cls = Viewport.__new__(Viewport)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Viewport'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Viewport.construct_without_init()
    cls._ptr = CPPViewportWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Viewport.construct_without_init()
    cls._ptr = CPPViewportWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def disable_3d(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_3d_disabled()
    return _ret
  @disable_3d.setter
  def disable_3d(self,  value:'bool'):
    self.set_disable_3d(value)
  @property
  def use_xr(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_xr()
    return _ret
  @use_xr.setter
  def use_xr(self,  value:'bool'):
    self.set_use_xr(value)
  @property
  def own_world_3d(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_own_world_3d()
    return _ret
  @own_world_3d.setter
  def own_world_3d(self,  value:'bool'):
    self.set_use_own_world_3d(value)
  @property
  def world_3d(self) -> typing.Union['py4godot_world3d.World3D']:
    r''''''
    _ret = self. get_world_3d()
    return _ret
  @world_3d.setter
  def world_3d(self,  value:'py4godot_object.Object'):
    self.set_world_3d(value)
  @property
  def world_2d(self) -> typing.Union['py4godot_world2d.World2D']:
    r''''''
    _ret = self. get_world_2d()
    return _ret
  @world_2d.setter
  def world_2d(self,  value:'py4godot_object.Object'):
    self.set_world_2d(value)
  @property
  def transparent_bg(self) -> typing.Union[bool]:
    r''''''
    _ret = self. has_transparent_background()
    return _ret
  @transparent_bg.setter
  def transparent_bg(self,  value:'bool'):
    self.set_transparent_background(value)
  @property
  def handle_input_locally(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_handling_input_locally()
    return _ret
  @handle_input_locally.setter
  def handle_input_locally(self,  value:'bool'):
    self.set_handle_input_locally(value)
  @property
  def snap_2d_transforms_to_pixel(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_snap_2d_transforms_to_pixel_enabled()
    return _ret
  @snap_2d_transforms_to_pixel.setter
  def snap_2d_transforms_to_pixel(self,  value:'bool'):
    self.set_snap_2d_transforms_to_pixel(value)
  @property
  def snap_2d_vertices_to_pixel(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_snap_2d_vertices_to_pixel_enabled()
    return _ret
  @snap_2d_vertices_to_pixel.setter
  def snap_2d_vertices_to_pixel(self,  value:'bool'):
    self.set_snap_2d_vertices_to_pixel(value)
  @property
  def msaa_2d(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_msaa_2d()
    return _ret
  @msaa_2d.setter
  def msaa_2d(self,  value:'int'):
    self.set_msaa_2d(value)
  @property
  def msaa_3d(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_msaa_3d()
    return _ret
  @msaa_3d.setter
  def msaa_3d(self,  value:'int'):
    self.set_msaa_3d(value)
  @property
  def screen_space_aa(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_screen_space_aa()
    return _ret
  @screen_space_aa.setter
  def screen_space_aa(self,  value:'int'):
    self.set_screen_space_aa(value)
  @property
  def use_taa(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_taa()
    return _ret
  @use_taa.setter
  def use_taa(self,  value:'bool'):
    self.set_use_taa(value)
  @property
  def use_debanding(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_debanding()
    return _ret
  @use_debanding.setter
  def use_debanding(self,  value:'bool'):
    self.set_use_debanding(value)
  @property
  def use_occlusion_culling(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_occlusion_culling()
    return _ret
  @use_occlusion_culling.setter
  def use_occlusion_culling(self,  value:'bool'):
    self.set_use_occlusion_culling(value)
  @property
  def mesh_lod_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_mesh_lod_threshold()
    return _ret
  @mesh_lod_threshold.setter
  def mesh_lod_threshold(self,  value:'float'):
    self.set_mesh_lod_threshold(value)
  @property
  def debug_draw(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_debug_draw()
    return _ret
  @debug_draw.setter
  def debug_draw(self,  value:'int'):
    self.set_debug_draw(value)
  @property
  def use_hdr_2d(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_hdr_2d()
    return _ret
  @use_hdr_2d.setter
  def use_hdr_2d(self,  value:'bool'):
    self.set_use_hdr_2d(value)
  @property
  def scaling_3d_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_scaling_3d_mode()
    return _ret
  @scaling_3d_mode.setter
  def scaling_3d_mode(self,  value:'int'):
    self.set_scaling_3d_mode(value)
  @property
  def scaling_3d_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_scaling_3d_scale()
    return _ret
  @scaling_3d_scale.setter
  def scaling_3d_scale(self,  value:'float'):
    self.set_scaling_3d_scale(value)
  @property
  def texture_mipmap_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_texture_mipmap_bias()
    return _ret
  @texture_mipmap_bias.setter
  def texture_mipmap_bias(self,  value:'float'):
    self.set_texture_mipmap_bias(value)
  @property
  def anisotropic_filtering_level(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_anisotropic_filtering_level()
    return _ret
  @anisotropic_filtering_level.setter
  def anisotropic_filtering_level(self,  value:'int'):
    self.set_anisotropic_filtering_level(value)
  @property
  def fsr_sharpness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fsr_sharpness()
    return _ret
  @fsr_sharpness.setter
  def fsr_sharpness(self,  value:'float'):
    self.set_fsr_sharpness(value)
  @property
  def vrs_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_vrs_mode()
    return _ret
  @vrs_mode.setter
  def vrs_mode(self,  value:'int'):
    self.set_vrs_mode(value)
  @property
  def vrs_update_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_vrs_update_mode()
    return _ret
  @vrs_update_mode.setter
  def vrs_update_mode(self,  value:'int'):
    self.set_vrs_update_mode(value)
  @property
  def vrs_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_vrs_texture()
    return _ret
  @vrs_texture.setter
  def vrs_texture(self,  value:'py4godot_object.Object'):
    self.set_vrs_texture(value)
  @property
  def canvas_item_default_texture_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_default_canvas_item_texture_filter()
    return _ret
  @canvas_item_default_texture_filter.setter
  def canvas_item_default_texture_filter(self,  value:'int'):
    self.set_default_canvas_item_texture_filter(value)
  @property
  def canvas_item_default_texture_repeat(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_default_canvas_item_texture_repeat()
    return _ret
  @canvas_item_default_texture_repeat.setter
  def canvas_item_default_texture_repeat(self,  value:'int'):
    self.set_default_canvas_item_texture_repeat(value)
  @property
  def audio_listener_enable_2d(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_audio_listener_2d()
    return _ret
  @audio_listener_enable_2d.setter
  def audio_listener_enable_2d(self,  value:'bool'):
    self.set_as_audio_listener_2d(value)
  @property
  def audio_listener_enable_3d(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_audio_listener_3d()
    return _ret
  @audio_listener_enable_3d.setter
  def audio_listener_enable_3d(self,  value:'bool'):
    self.set_as_audio_listener_3d(value)
  @property
  def physics_object_picking(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_physics_object_picking()
    return _ret
  @physics_object_picking.setter
  def physics_object_picking(self,  value:'bool'):
    self.set_physics_object_picking(value)
  @property
  def physics_object_picking_sort(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_physics_object_picking_sort()
    return _ret
  @physics_object_picking_sort.setter
  def physics_object_picking_sort(self,  value:'bool'):
    self.set_physics_object_picking_sort(value)
  @property
  def physics_object_picking_first_only(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_physics_object_picking_first_only()
    return _ret
  @physics_object_picking_first_only.setter
  def physics_object_picking_first_only(self,  value:'bool'):
    self.set_physics_object_picking_first_only(value)
  @property
  def gui_disable_input(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_input_disabled()
    return _ret
  @gui_disable_input.setter
  def gui_disable_input(self,  value:'bool'):
    self.set_disable_input(value)
  @property
  def gui_snap_controls_to_pixels(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_snap_controls_to_pixels_enabled()
    return _ret
  @gui_snap_controls_to_pixels.setter
  def gui_snap_controls_to_pixels(self,  value:'bool'):
    self.set_snap_controls_to_pixels(value)
  @property
  def gui_embed_subwindows(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_embedding_subwindows()
    return _ret
  @gui_embed_subwindows.setter
  def gui_embed_subwindows(self,  value:'bool'):
    self.set_embedding_subwindows(value)
  @property
  def sdf_oversize(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sdf_oversize()
    return _ret
  @sdf_oversize.setter
  def sdf_oversize(self,  value:'int'):
    self.set_sdf_oversize(value)
  @property
  def sdf_scale(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sdf_scale()
    return _ret
  @sdf_scale.setter
  def sdf_scale(self,  value:'int'):
    self.set_sdf_scale(value)
  @property
  def positional_shadow_atlas_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_positional_shadow_atlas_size()
    return _ret
  @positional_shadow_atlas_size.setter
  def positional_shadow_atlas_size(self,  value:'int'):
    self.set_positional_shadow_atlas_size(value)
  @property
  def positional_shadow_atlas_16_bits(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_positional_shadow_atlas_16_bits()
    return _ret
  @positional_shadow_atlas_16_bits.setter
  def positional_shadow_atlas_16_bits(self,  value:'bool'):
    self.set_positional_shadow_atlas_16_bits(value)
  @property
  def positional_shadow_atlas_quad_0(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_positional_shadow_atlas_quadrant_subdiv(0)
    return _ret
  @positional_shadow_atlas_quad_0.setter
  def positional_shadow_atlas_quad_0(self,  value:'int'):
    self.set_positional_shadow_atlas_quadrant_subdiv(value)
  @property
  def positional_shadow_atlas_quad_1(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_positional_shadow_atlas_quadrant_subdiv(1)
    return _ret
  @positional_shadow_atlas_quad_1.setter
  def positional_shadow_atlas_quad_1(self,  value:'int'):
    self.set_positional_shadow_atlas_quadrant_subdiv(value)
  @property
  def positional_shadow_atlas_quad_2(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_positional_shadow_atlas_quadrant_subdiv(2)
    return _ret
  @positional_shadow_atlas_quad_2.setter
  def positional_shadow_atlas_quad_2(self,  value:'int'):
    self.set_positional_shadow_atlas_quadrant_subdiv(value)
  @property
  def positional_shadow_atlas_quad_3(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_positional_shadow_atlas_quadrant_subdiv(3)
    return _ret
  @positional_shadow_atlas_quad_3.setter
  def positional_shadow_atlas_quad_3(self,  value:'int'):
    self.set_positional_shadow_atlas_quadrant_subdiv(value)
  @property
  def canvas_transform(self) -> typing.Union['Transform2D']:
    r''''''
    _ret = self. get_canvas_transform()
    return _ret
  @canvas_transform.setter
  def canvas_transform(self,  value:'Transform2D'):
    self.set_canvas_transform(value)
  @property
  def global_canvas_transform(self) -> typing.Union['Transform2D']:
    r''''''
    _ret = self. get_global_canvas_transform()
    return _ret
  @global_canvas_transform.setter
  def global_canvas_transform(self,  value:'Transform2D'):
    self.set_global_canvas_transform(value)
  @property
  def canvas_cull_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_canvas_cull_mask()
    return _ret
  @canvas_cull_mask.setter
  def canvas_cull_mask(self,  value:'int'):
    self.set_canvas_cull_mask(value)
  @property
  def oversampling(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_oversampling()
    return _ret
  @oversampling.setter
  def oversampling(self,  value:'bool'):
    self.set_use_oversampling(value)
  @property
  def oversampling_override(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_oversampling_override()
    return _ret
  @oversampling_override.setter
  def oversampling_override(self,  value:'float'):
    self.set_oversampling_override(value)
  @functools.native_method
  def set_world_2d(self, world_2d:'py4godot_world2d.World2D'   ) -> None:
    r''''''

    assert(not world_2d is None)
    assert isinstance(world_2d, get_class('World2D')), 'world_2d must be World2D'

    self.py__world_2d = world_2d






    self._ptr.call_with_return(180,tuple([world_2d._ptr]))

  @functools.native_method
  def get_world_2d(self) -> typing.Union['py4godot_world2d.World2D']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: World2D
    _ret._ptr = self._ptr.call_with_return(181,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def find_world_2d(self) -> typing.Union['py4godot_world2d.World2D']:
    r'''
				Returns the first valid `World2D` for this viewport, searching the `world_2d` property of itself and any Viewport ancestor.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: World2D
    _ret._ptr = self._ptr.call_with_return(182,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_canvas_transform(self, xform:'Transform2D'   ) -> None:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'

    self.py__canvas_transform = xform






    self._ptr.call_with_return(183,tuple([xform._ptr]))

  @functools.native_method
  def get_canvas_transform(self) -> typing.Union['Transform2D']:
    r''''''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(184,tuple([]))

    return _ret


  @functools.native_method
  def set_global_canvas_transform(self, xform:'Transform2D'   ) -> None:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'

    self.py__global_canvas_transform = xform






    self._ptr.call_with_return(185,tuple([xform._ptr]))

  @functools.native_method
  def get_global_canvas_transform(self) -> typing.Union['Transform2D']:
    r''''''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(186,tuple([]))

    return _ret


  @functools.native_method
  def get_stretch_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the automatically computed 2D stretch transform, taking the `Viewport`'s stretch settings into account. The final value is multiplied by `Window.content_scale_factor`, but only for the root viewport. If this method is called on a `SubViewport` (e.g., in a scene tree with `SubViewportContainer` and `SubViewport`), the scale factor of the root window will not be applied. Using `Transform2D.get_scale` on the returned value, this can be used to compensate for scaling when zooming a `Camera2D` node, or to scale down a `TextureRect` to be pixel-perfect regardless of the automatically computed scale factor.
				**Note:** Due to how pixel scaling works, the returned transform's X and Y scale may differ slightly, even when `Window.content_scale_aspect` is set to a mode that preserves the pixels' aspect ratio. If `Window.content_scale_aspect` is `constant Window.CONTENT_SCALE_ASPECT_IGNORE`, the X and Y scale may differ _significantly_.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(187,tuple([]))
    return _ret


  @functools.native_method
  def get_final_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the transform from the viewport's coordinate system to the embedder's coordinate system.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(188,tuple([]))
    return _ret


  @functools.native_method
  def get_screen_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the transform from the Viewport's coordinates to the screen coordinates of the containing window manager window.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(189,tuple([]))
    return _ret


  @functools.native_method
  def get_visible_rect(self) -> typing.Union['Rect2']:
    r'''
				Returns the visible rectangle in global screen coordinates.
			'''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(190,tuple([]))
    return _ret


  @functools.native_method
  def set_transparent_background(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__transparent_bg = enable






    self._ptr.call_with_return(191,tuple([enable]))

  @functools.native_method
  def has_transparent_background(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))

    return _ret


  @functools.native_method
  def set_use_hdr_2d(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__use_hdr_2d = enable






    self._ptr.call_with_return(193,tuple([enable]))

  @functools.native_method
  def is_using_hdr_2d(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(194,tuple([]))

    return _ret


  @functools.native_method
  def set_msaa_2d(self, msaa:'int'  ) -> None:
    r''''''

    assert isinstance(msaa, (int, float)), 'msaa must be int or float'

    self.py__msaa_2d = msaa






    self._ptr.call_with_return(195,tuple([msaa]))

  @functools.native_method
  def get_msaa_2d(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(196,tuple([]))

    return _ret


  @functools.native_method
  def set_msaa_3d(self, msaa:'int'  ) -> None:
    r''''''

    assert isinstance(msaa, (int, float)), 'msaa must be int or float'

    self.py__msaa_3d = msaa






    self._ptr.call_with_return(197,tuple([msaa]))

  @functools.native_method
  def get_msaa_3d(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(198,tuple([]))

    return _ret


  @functools.native_method
  def set_screen_space_aa(self, screen_space_aa:'int'  ) -> None:
    r''''''

    assert isinstance(screen_space_aa, (int, float)), 'screen_space_aa must be int or float'

    self.py__screen_space_aa = screen_space_aa






    self._ptr.call_with_return(199,tuple([screen_space_aa]))

  @functools.native_method
  def get_screen_space_aa(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(200,tuple([]))

    return _ret


  @functools.native_method
  def set_use_taa(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__use_taa = enable






    self._ptr.call_with_return(201,tuple([enable]))

  @functools.native_method
  def is_using_taa(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(202,tuple([]))

    return _ret


  @functools.native_method
  def set_use_debanding(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__use_debanding = enable






    self._ptr.call_with_return(203,tuple([enable]))

  @functools.native_method
  def is_using_debanding(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(204,tuple([]))

    return _ret


  @functools.native_method
  def set_use_occlusion_culling(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__use_occlusion_culling = enable






    self._ptr.call_with_return(205,tuple([enable]))

  @functools.native_method
  def is_using_occlusion_culling(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(206,tuple([]))

    return _ret


  @functools.native_method
  def set_debug_draw(self, debug_draw:'int'  ) -> None:
    r''''''

    assert isinstance(debug_draw, (int, float)), 'debug_draw must be int or float'

    self.py__debug_draw = debug_draw






    self._ptr.call_with_return(207,tuple([debug_draw]))

  @functools.native_method
  def get_debug_draw(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(208,tuple([]))

    return _ret


  @functools.native_method
  def set_use_oversampling(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__oversampling = enable






    self._ptr.call_with_return(209,tuple([enable]))

  @functools.native_method
  def is_using_oversampling(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(210,tuple([]))

    return _ret


  @functools.native_method
  def set_oversampling_override(self, oversampling:'float'   ) -> None:
    r''''''

    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'

    self.py__oversampling_override = oversampling






    self._ptr.call_with_return(211,tuple([oversampling]))

  @functools.native_method
  def get_oversampling_override(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(212,tuple([]))

    return _ret


  @functools.native_method
  def get_oversampling(self) -> typing.Union[float]:
    r'''
				Returns viewport oversampling factor.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(213,tuple([]))
    return _ret


  @functools.native_method
  def get_render_info(self, type:'int'  , info:'int'  ) -> typing.Union[int]:
    r'''
				Returns rendering statistics of the given type.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(info, (int, float)), 'info must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(214,tuple([type, info]))
    return _ret


  @functools.native_method
  def get_texture(self) -> typing.Union['py4godot_viewporttexture.ViewportTexture']:
    r'''
				Returns the viewport's texture.
				**Note:** When trying to store the current texture (e.g. in a file), it might be completely black or outdated if used too early, especially when used in e.g. `Node._ready`. To make sure the texture you get is correct, you can await `signal RenderingServer.frame_post_draw` signal.
				
				```gdscript
				func _ready():
				    await RenderingServer.frame_post_draw
				    $Viewport.get_texture().get_image().save_png("user://Screenshot.png")
				```
				
				
				**Note:** When `use_hdr_2d` is `true` the returned texture will be an HDR image using linear encoding.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ViewportTexture
    _ret._ptr = self._ptr.call_with_return(215,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_physics_object_picking(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__physics_object_picking = enable






    self._ptr.call_with_return(216,tuple([enable]))

  @functools.native_method
  def get_physics_object_picking(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(217,tuple([]))

    return _ret


  @functools.native_method
  def set_physics_object_picking_sort(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__physics_object_picking_sort = enable






    self._ptr.call_with_return(218,tuple([enable]))

  @functools.native_method
  def get_physics_object_picking_sort(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(219,tuple([]))

    return _ret


  @functools.native_method
  def set_physics_object_picking_first_only(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__physics_object_picking_first_only = enable






    self._ptr.call_with_return(220,tuple([enable]))

  @functools.native_method
  def get_physics_object_picking_first_only(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(221,tuple([]))

    return _ret


  @functools.native_method
  def get_viewport_rid(self) -> typing.Union['RID']:
    r'''
				Returns the viewport's RID from the `RenderingServer`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(222,tuple([]))
    return _ret


  @functools.native_method
  def push_text_input(self, text:'str'   ) -> None:
    r'''
				Helper method which calls the `set_text()` method on the currently focused `Control`, provided that it is defined (e.g. if the focused Control is `Button` or `LineEdit`).
			'''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'




    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(223,tuple([py_string_text._ptr]))

  @functools.native_method
  def push_input(self, event:'py4godot_inputevent.InputEvent'   , in_local_coords:'bool' =False  ) -> None:
    r'''
				Triggers the given `event` in this `Viewport`. This can be used to pass an `InputEvent` between viewports, or to locally apply inputs that were sent over the network or saved to a file.
				If `in_local_coords` is `false`, the event's position is in the embedder's coordinates and will be converted to viewport coordinates. If `in_local_coords` is `true`, the event's position is in viewport coordinates.
				While this method serves a similar purpose as `Input.parse_input_event`, it does not remap the specified `event` based on project settings like `ProjectSettings.input_devices/pointing/emulate_touch_from_mouse`.
				Calling this method will propagate calls to child nodes for following methods in the given order:
				- `Node._input`
				- `Control._gui_input` for `Control` nodes
				- `Node._shortcut_input`
				- `Node._unhandled_key_input`
				- `Node._unhandled_input`
				If an earlier method marks the input as handled via `set_input_as_handled`, any later method in this list will not be called.
				If none of the methods handle the event and `physics_object_picking` is `true`, the event is used for physics object picking.
			'''

    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'
    assert isinstance(in_local_coords, bool), 'in_local_coords must be bool'







    self._ptr.call_with_return(224,tuple([event._ptr, in_local_coords]))

  @functools.native_method
  def push_unhandled_input(self, event:'py4godot_inputevent.InputEvent'   , in_local_coords:'bool' =False  ) -> None:
    r'''
				Triggers the given `event` in this `Viewport`. This can be used to pass an `InputEvent` between viewports, or to locally apply inputs that were sent over the network or saved to a file.
				If `in_local_coords` is `false`, the event's position is in the embedder's coordinates and will be converted to viewport coordinates. If `in_local_coords` is `true`, the event's position is in viewport coordinates.
				Calling this method will propagate calls to child nodes for following methods in the given order:
				- `Node._shortcut_input`
				- `Node._unhandled_key_input`
				- `Node._unhandled_input`
				If an earlier method marks the input as handled via `set_input_as_handled`, any later method in this list will not be called.
				If none of the methods handle the event and `physics_object_picking` is `true`, the event is used for physics object picking.
				**Note:** This method doesn't propagate input events to embedded `Window`s or `SubViewport`s.
			'''

    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'
    assert isinstance(in_local_coords, bool), 'in_local_coords must be bool'







    self._ptr.call_with_return(225,tuple([event._ptr, in_local_coords]))

  @functools.native_method
  def notify_mouse_entered(self) -> None:
    r'''
				Inform the Viewport that the mouse has entered its area. Use this function before sending an `InputEventMouseButton` or `InputEventMouseMotion` to the `Viewport` with `Viewport.push_input`. See also `notify_mouse_exited`.
				**Note:** In most cases, it is not necessary to call this function because `SubViewport` nodes that are children of `SubViewportContainer` are notified automatically. This is only necessary when interacting with viewports in non-default ways, for example as textures in `TextureRect` or with an `Area3D` that forwards input events.
			'''




    self._ptr.call_with_return(226,tuple([]))

  @functools.native_method
  def notify_mouse_exited(self) -> None:
    r'''
				Inform the Viewport that the mouse has left its area. Use this function when the node that displays the viewport notices the mouse has left the area of the displayed viewport. See also `notify_mouse_entered`.
				**Note:** In most cases, it is not necessary to call this function because `SubViewport` nodes that are children of `SubViewportContainer` are notified automatically. This is only necessary when interacting with viewports in non-default ways, for example as textures in `TextureRect` or with an `Area3D` that forwards input events.
			'''




    self._ptr.call_with_return(227,tuple([]))

  @functools.native_method
  def get_mouse_position(self) -> typing.Union['Vector2']:
    r'''
				Returns the mouse's position in this `Viewport` using the coordinate system of this `Viewport`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(228,tuple([]))
    return _ret


  @functools.native_method
  def warp_mouse(self, position:'Vector2'   ) -> None:
    r'''
				Moves the mouse pointer to the specified position in this `Viewport` using the coordinate system of this `Viewport`.
				**Note:** `warp_mouse` is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'






    self._ptr.call_with_return(229,tuple([position._ptr]))

  @functools.native_method
  def update_mouse_cursor_state(self) -> None:
    r'''
				Force instantly updating the display based on the current mouse cursor position. This includes updating the mouse cursor shape and sending necessary `signal Control.mouse_entered`, `signal CollisionObject2D.mouse_entered`, `signal CollisionObject3D.mouse_entered` and `signal Window.mouse_entered` signals and their respective `mouse_exited` counterparts.
			'''




    self._ptr.call_with_return(230,tuple([]))

  @functools.native_method
  def gui_cancel_drag(self) -> None:
    r'''
				Cancels the drag operation that was previously started through `Control._get_drag_data` or forced with `Control.force_drag`.
			'''




    self._ptr.call_with_return(231,tuple([]))

  @functools.native_method
  def gui_get_drag_data(self) -> typing.Union[typing.Any]:
    r'''
				Returns the drag data from the GUI, that was previously returned by `Control._get_drag_data`.
			'''




    _ret = None
    _ret = self._ptr.call_with_return(232,tuple([]))
    return _ret


  @functools.native_method
  def gui_get_drag_description(self) -> typing.Union[str]:
    r'''
				Returns the drag data human-readable description.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(233,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def gui_set_drag_description(self, description:'str'   ) -> None:
    r'''
				Sets the drag data human-readable description.
			'''

    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'




    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(234,tuple([py_string_description._ptr]))

  @functools.native_method
  def gui_is_dragging(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a drag operation is currently ongoing and where the drop action could happen in this viewport.
				Alternative to `constant Node.NOTIFICATION_DRAG_BEGIN` and `constant Node.NOTIFICATION_DRAG_END` when you prefer polling the value.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(235,tuple([]))
    return _ret


  @functools.native_method
  def gui_is_drag_successful(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the drag operation is successful.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(236,tuple([]))
    return _ret


  @functools.native_method
  def gui_release_focus(self) -> None:
    r'''
				Removes the focus from the currently focused `Control` within this viewport. If no `Control` has the focus, does nothing.
			'''




    self._ptr.call_with_return(237,tuple([]))

  @functools.native_method
  def gui_get_focus_owner(self) -> typing.Any:
    r'''
				Returns the currently focused `Control` within this viewport. If no `Control` is focused, returns `null`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Control
    _ret._ptr = self._ptr.call_with_return(238,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def gui_get_hovered_control(self) -> typing.Any:
    r'''
				Returns the `Control` that the mouse is currently hovering over in this viewport. If no `Control` has the cursor, returns `null`.
				Typically the leaf `Control` node or deepest level of the subtree which claims hover. This is very useful when used together with `Node.is_ancestor_of` to find if the mouse is within a control tree.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Control
    _ret._ptr = self._ptr.call_with_return(239,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_disable_input(self, disable:'bool'   ) -> None:
    r''''''

    assert isinstance(disable, bool), 'disable must be bool'

    self.py__gui_disable_input = disable






    self._ptr.call_with_return(240,tuple([disable]))

  @functools.native_method
  def is_input_disabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(241,tuple([]))

    return _ret


  @functools.native_method
  def set_positional_shadow_atlas_size(self, size:'int'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'

    self.py__positional_shadow_atlas_size = size






    self._ptr.call_with_return(242,tuple([size]))

  @functools.native_method
  def get_positional_shadow_atlas_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(243,tuple([]))

    return _ret


  @functools.native_method
  def set_positional_shadow_atlas_16_bits(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__positional_shadow_atlas_16_bits = enable






    self._ptr.call_with_return(244,tuple([enable]))

  @functools.native_method
  def get_positional_shadow_atlas_16_bits(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(245,tuple([]))

    return _ret


  @functools.native_method
  def set_snap_controls_to_pixels(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__gui_snap_controls_to_pixels = enabled






    self._ptr.call_with_return(246,tuple([enabled]))

  @functools.native_method
  def is_snap_controls_to_pixels_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(247,tuple([]))

    return _ret


  @functools.native_method
  def set_snap_2d_transforms_to_pixel(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__snap_2d_transforms_to_pixel = enabled






    self._ptr.call_with_return(248,tuple([enabled]))

  @functools.native_method
  def is_snap_2d_transforms_to_pixel_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(249,tuple([]))

    return _ret


  @functools.native_method
  def set_snap_2d_vertices_to_pixel(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__snap_2d_vertices_to_pixel = enabled






    self._ptr.call_with_return(250,tuple([enabled]))

  @functools.native_method
  def is_snap_2d_vertices_to_pixel_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(251,tuple([]))

    return _ret


  @functools.native_method
  def set_positional_shadow_atlas_quadrant_subdiv(self, quadrant:'int'   , subdiv:'int'  ) -> None:
    r'''
				Sets the number of subdivisions to use in the specified quadrant. A higher number of subdivisions allows you to have more shadows in the scene at once, but reduces the quality of the shadows. A good practice is to have quadrants with a varying number of subdivisions and to have as few subdivisions as possible.
			'''

    assert isinstance(quadrant, (int, float)), 'quadrant must be int or float'
    assert isinstance(subdiv, (int, float)), 'subdiv must be int or float'

    self.py__positional_shadow_atlas_quad_0 = quadrant







    self._ptr.call_with_return(252,tuple([quadrant, subdiv]))

  @functools.native_method
  def get_positional_shadow_atlas_quadrant_subdiv(self, quadrant:'int'   ) -> typing.Union[int]:
    r'''
				Returns the positional shadow atlas quadrant subdivision of the specified quadrant.
			'''

    assert isinstance(quadrant, (int, float)), 'quadrant must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(253,tuple([quadrant]))

    return _ret


  @functools.native_method
  def set_input_as_handled(self) -> None:
    r'''
				Stops the input from propagating further down the `SceneTree`.
				**Note:** This does not affect the methods in `Input`, only the way events are propagated.
			'''




    self._ptr.call_with_return(254,tuple([]))

  @functools.native_method
  def is_input_handled(self) -> typing.Union[bool]:
    r'''
				Returns whether the current `InputEvent` has been handled. Input events are not handled until `set_input_as_handled` has been called during the lifetime of an `InputEvent`.
				This is usually done as part of input handling methods like `Node._input`, `Control._gui_input` or others, as well as in corresponding signal handlers.
				If `handle_input_locally` is set to `false`, this method will try finding the first parent viewport that is set to handle input locally, and return its value for `is_input_handled` instead.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(255,tuple([]))
    return _ret


  @functools.native_method
  def set_handle_input_locally(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__handle_input_locally = enable






    self._ptr.call_with_return(256,tuple([enable]))

  @functools.native_method
  def is_handling_input_locally(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(257,tuple([]))

    return _ret


  @functools.native_method
  def set_default_canvas_item_texture_filter(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__canvas_item_default_texture_filter = mode






    self._ptr.call_with_return(258,tuple([mode]))

  @functools.native_method
  def get_default_canvas_item_texture_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(259,tuple([]))

    return _ret


  @functools.native_method
  def set_embedding_subwindows(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__gui_embed_subwindows = enable






    self._ptr.call_with_return(260,tuple([enable]))

  @functools.native_method
  def is_embedding_subwindows(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(261,tuple([]))

    return _ret


  @functools.native_method
  def get_embedded_subwindows(self) -> typing.Union['py4godot_windowtypedarray.WindowTypedArray']:
    r'''
				Returns a list of the visible embedded `Window`s inside the viewport.
				**Note:** `Window`s inside other viewports will not be listed.
			'''




    _ret = py4godot_windowtypedarray.WindowTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(262,tuple([]))
    return _ret


  @functools.native_method
  def set_canvas_cull_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'

    self.py__canvas_cull_mask = mask






    self._ptr.call_with_return(263,tuple([mask]))

  @functools.native_method
  def get_canvas_cull_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(264,tuple([]))

    return _ret


  @functools.native_method
  def set_canvas_cull_mask_bit(self, layer:'int'   , enable:'bool'   ) -> None:
    r'''
				Set/clear individual bits on the rendering layer mask. This simplifies editing this `Viewport`'s layers.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(265,tuple([layer, enable]))

  @functools.native_method
  def get_canvas_cull_mask_bit(self, layer:'int'   ) -> typing.Union[bool]:
    r'''
				Returns an individual bit on the rendering layer mask.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(266,tuple([layer]))
    return _ret


  @functools.native_method
  def set_default_canvas_item_texture_repeat(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__canvas_item_default_texture_repeat = mode






    self._ptr.call_with_return(267,tuple([mode]))

  @functools.native_method
  def get_default_canvas_item_texture_repeat(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(268,tuple([]))

    return _ret


  @functools.native_method
  def set_sdf_oversize(self, oversize:'int'  ) -> None:
    r''''''

    assert isinstance(oversize, (int, float)), 'oversize must be int or float'

    self.py__sdf_oversize = oversize






    self._ptr.call_with_return(269,tuple([oversize]))

  @functools.native_method
  def get_sdf_oversize(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(270,tuple([]))

    return _ret


  @functools.native_method
  def set_sdf_scale(self, scale:'int'  ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'

    self.py__sdf_scale = scale






    self._ptr.call_with_return(271,tuple([scale]))

  @functools.native_method
  def get_sdf_scale(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(272,tuple([]))

    return _ret


  @functools.native_method
  def set_mesh_lod_threshold(self, pixels:'float'   ) -> None:
    r''''''

    assert isinstance(pixels, (int, float)), 'pixels must be int or float'

    self.py__mesh_lod_threshold = pixels






    self._ptr.call_with_return(273,tuple([pixels]))

  @functools.native_method
  def get_mesh_lod_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(274,tuple([]))

    return _ret


  @functools.native_method
  def set_as_audio_listener_2d(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__audio_listener_enable_2d = enable






    self._ptr.call_with_return(275,tuple([enable]))

  @functools.native_method
  def is_audio_listener_2d(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(276,tuple([]))

    return _ret


  @functools.native_method
  def get_audio_listener_2d(self) -> typing.Union['py4godot_audiolistener2d.AudioListener2D']:
    r'''
				Returns the currently active 2D audio listener. Returns `null` if there are no active 2D audio listeners, in which case the active 2D camera will be treated as listener.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioListener2D
    _ret._ptr = self._ptr.call_with_return(277,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_camera_2d(self) -> typing.Union['py4godot_camera2d.Camera2D']:
    r'''
				Returns the currently active 2D camera. Returns `null` if there are no active cameras.
				**Note:** If called while the _Camera Override_ system is active in editor, this will return the internally managed override camera. It is therefore advised to avoid caching the return value, or to check that the cached value is still a valid instance and is the current camera before use. See `@GlobalScope.is_instance_valid` and `Camera2D.is_current`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Camera2D
    _ret._ptr = self._ptr.call_with_return(278,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_world_3d(self, world_3d:'py4godot_world3d.World3D'   ) -> None:
    r''''''

    assert(not world_3d is None)
    assert isinstance(world_3d, get_class('World3D')), 'world_3d must be World3D'

    self.py__world_3d = world_3d






    self._ptr.call_with_return(279,tuple([world_3d._ptr]))

  @functools.native_method
  def get_world_3d(self) -> typing.Union['py4godot_world3d.World3D']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: World3D
    _ret._ptr = self._ptr.call_with_return(280,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def find_world_3d(self) -> typing.Union['py4godot_world3d.World3D']:
    r'''
				Returns the first valid `World3D` for this viewport, searching the `world_3d` property of itself and any Viewport ancestor.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: World3D
    _ret._ptr = self._ptr.call_with_return(281,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_use_own_world_3d(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__own_world_3d = enable






    self._ptr.call_with_return(282,tuple([enable]))

  @functools.native_method
  def is_using_own_world_3d(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def get_audio_listener_3d(self) -> typing.Union['py4godot_audiolistener3d.AudioListener3D']:
    r'''
				Returns the currently active 3D audio listener. Returns `null` if there are no active 3D audio listeners, in which case the active 3D camera will be treated as listener.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioListener3D
    _ret._ptr = self._ptr.call_with_return(284,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_camera_3d(self) -> typing.Union['py4godot_xrcamera3d.XRCamera3D','py4godot_camera3d.Camera3D']:
    r'''
				Returns the currently active 3D camera. Returns `null` if there are no active cameras.
				**Note:** If called while the _Camera Override_ system is active in editor, this will return the internally managed override camera. It is therefore advised to avoid caching the return value, or to check that the cached value is a valid instance and is the current camera before use. See `@GlobalScope.is_instance_valid` and `Camera3D.current`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Camera3D
    _ret._ptr = self._ptr.call_with_return(285,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_as_audio_listener_3d(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__audio_listener_enable_3d = enable






    self._ptr.call_with_return(286,tuple([enable]))

  @functools.native_method
  def is_audio_listener_3d(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_disable_3d(self, disable:'bool'   ) -> None:
    r''''''

    assert isinstance(disable, bool), 'disable must be bool'

    self.py__disable_3d = disable






    self._ptr.call_with_return(288,tuple([disable]))

  @functools.native_method
  def is_3d_disabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def set_use_xr(self, use:'bool'   ) -> None:
    r''''''

    assert isinstance(use, bool), 'use must be bool'

    self.py__use_xr = use






    self._ptr.call_with_return(290,tuple([use]))

  @functools.native_method
  def is_using_xr(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_scaling_3d_mode(self, scaling_3d_mode:'int'  ) -> None:
    r''''''

    assert isinstance(scaling_3d_mode, (int, float)), 'scaling_3d_mode must be int or float'

    self.py__scaling_3d_mode = scaling_3d_mode






    self._ptr.call_with_return(292,tuple([scaling_3d_mode]))

  @functools.native_method
  def get_scaling_3d_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def set_scaling_3d_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'

    self.py__scaling_3d_scale = scale






    self._ptr.call_with_return(294,tuple([scale]))

  @functools.native_method
  def get_scaling_3d_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(295,tuple([]))

    return _ret


  @functools.native_method
  def set_fsr_sharpness(self, fsr_sharpness:'float'   ) -> None:
    r''''''

    assert isinstance(fsr_sharpness, (int, float)), 'fsr_sharpness must be int or float'

    self.py__fsr_sharpness = fsr_sharpness






    self._ptr.call_with_return(296,tuple([fsr_sharpness]))

  @functools.native_method
  def get_fsr_sharpness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_mipmap_bias(self, texture_mipmap_bias:'float'   ) -> None:
    r''''''

    assert isinstance(texture_mipmap_bias, (int, float)), 'texture_mipmap_bias must be int or float'

    self.py__texture_mipmap_bias = texture_mipmap_bias






    self._ptr.call_with_return(298,tuple([texture_mipmap_bias]))

  @functools.native_method
  def get_texture_mipmap_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([]))

    return _ret


  @functools.native_method
  def set_anisotropic_filtering_level(self, anisotropic_filtering_level:'int'  ) -> None:
    r''''''

    assert isinstance(anisotropic_filtering_level, (int, float)), 'anisotropic_filtering_level must be int or float'

    self.py__anisotropic_filtering_level = anisotropic_filtering_level






    self._ptr.call_with_return(300,tuple([anisotropic_filtering_level]))

  @functools.native_method
  def get_anisotropic_filtering_level(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(301,tuple([]))

    return _ret


  @functools.native_method
  def set_vrs_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__vrs_mode = mode






    self._ptr.call_with_return(302,tuple([mode]))

  @functools.native_method
  def get_vrs_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(303,tuple([]))

    return _ret


  @functools.native_method
  def set_vrs_update_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__vrs_update_mode = mode






    self._ptr.call_with_return(304,tuple([mode]))

  @functools.native_method
  def get_vrs_update_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def set_vrs_texture(self, texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'

    self.py__vrs_texture = texture






    self._ptr.call_with_return(306,tuple([texture._ptr]))

  @functools.native_method
  def get_vrs_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(307,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('Viewport', Viewport.cast)
register_class('Viewport', Viewport)
