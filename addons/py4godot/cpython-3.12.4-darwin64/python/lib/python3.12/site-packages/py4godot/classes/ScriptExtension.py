# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.GDScript as py4godot_gdscript 
  import py4godot.classes.Object as py4godot_object 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.ScriptLanguage as py4godot_scriptlanguage 
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
  import py4godot.classes.ScriptLanguageExtension as py4godot_scriptlanguageextension 
import py4godot.classes.Script as py4godot_script 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
from py4godot.wrappers.wrappers import CPPScriptExtensionWrapper


class ScriptExtension(py4godot_script.Script):
  r'''
'''

  @staticmethod
  def constructor():
    class_ = ScriptExtension.construct_without_init()
    class_._ptr = constructor(726,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ScriptExtension.construct_without_init()
    class_._ptr = constructor(726,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPScriptExtensionWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(726,0, ())


  def generate_wrapper(self):
    return CPPScriptExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ScriptExtension.__new__(ScriptExtension)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ScriptExtension'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ScriptExtension.construct_without_init()
    cls._ptr = CPPScriptExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ScriptExtension.construct_without_init()
    cls._ptr = CPPScriptExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _editor_can_reload_from_file(self) -> typing.Union[bool]:
    r'''
'''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def _can_instantiate(self) -> typing.Union[bool]:
    r'''
'''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def _get_base_script(self) -> typing.Union['py4godot_script.Script','py4godot_gdscript.GDScript','typing.Self']:
    r'''
'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Script
    _ret._ptr = self._ptr.call_with_return(97,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _get_global_name(self) -> typing.Union['StringName']:
    r'''
'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([]))
    return _ret


  @functools.native_method
  def _inherits_script(self, script:'py4godot_script.Script'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not script is None)
    assert isinstance(script, get_class('Script')), 'script must be Script'






    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([script._ptr]))
    return _ret


  @functools.native_method
  def _get_instance_base_type(self) -> typing.Union['StringName']:
    r'''
'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(100,tuple([]))
    return _ret


  @functools.native_method
  def _instance_has(self, object_:'py4godot_object.Object'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'






    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([object_._ptr]))
    return _ret


  @functools.native_method
  def _has_source_code(self) -> typing.Union[bool]:
    r'''
'''




    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([]))
    return _ret


  @functools.native_method
  def _get_source_code(self) -> typing.Union[str]:
    r'''
'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _set_source_code(self, code:'str'   ) -> None:
    r'''
'''

    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'




    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)

    self._ptr.call_with_return(106,tuple([py_string_code._ptr]))

  @functools.native_method
  def _reload(self, keep_state:'bool'   ) -> typing.Union[int]:
    r'''
'''

    assert isinstance(keep_state, bool), 'keep_state must be bool'






    _ret:int
    _ret = self._ptr.call_with_return(107,tuple([keep_state]))
    return _ret


  @functools.native_method
  def _get_doc_class_name(self) -> typing.Union['StringName']:
    r'''
'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))
    return _ret


  @functools.native_method
  def _get_documentation(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(109,tuple([]))
    return _ret


  @functools.native_method
  def _get_class_icon_path(self) -> typing.Union[str]:
    r'''
'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(110,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _has_method(self, method:'object'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'




    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    _ret = 0
    _ret = self._ptr.call_with_return(111,tuple([py_stringname_method._ptr]))
    return _ret


  @functools.native_method
  def _has_static_method(self, method:'object'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'




    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([py_stringname_method._ptr]))
    return _ret


  @functools.native_method
  def _get_script_method_argument_count(self, method:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Return the expected argument count for the given `method`, or `null` if it can't be determined (which will then fall back to the default behavior).
			'''

    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'




    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    _ret = None
    _ret = self._ptr.call_with_return(113,tuple([py_stringname_method._ptr]))
    return _ret


  @functools.native_method
  def _get_method_info(self, method:'object'   ) -> typing.Union['Dictionary']:
    r'''
'''

    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'




    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(114,tuple([py_stringname_method._ptr]))
    return _ret


  @functools.native_method
  def _is_tool(self) -> typing.Union[bool]:
    r'''
'''




    _ret = 0
    _ret = self._ptr.call_with_return(115,tuple([]))
    return _ret


  @functools.native_method
  def _is_valid(self) -> typing.Union[bool]:
    r'''
'''




    _ret = 0
    _ret = self._ptr.call_with_return(116,tuple([]))
    return _ret


  @functools.native_method
  def _is_abstract(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the script is an abstract script. Abstract scripts cannot be instantiated directly, instead other scripts should inherit them. Abstract scripts will be either unselectable or hidden in the Create New Node dialog (unselectable if there are non-abstract classes inheriting it, otherwise hidden).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(117,tuple([]))
    return _ret


  @functools.native_method
  def _get_language(self) -> typing.Union['py4godot_scriptlanguage.ScriptLanguage','py4godot_scriptlanguageextension.ScriptLanguageExtension']:
    r'''
'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ScriptLanguage
    _ret._ptr = self._ptr.call_with_return(118,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _has_script_signal(self, signal:'object'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not signal is None)
    assert isinstance(signal, (str, StringName)), 'signal must be str or StringName'




    assert(isinstance(signal, (str, StringName)))
    py_stringname_signal = signal if isinstance(signal, StringName) else c_utils.py_string_to_string_name(signal)

    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([py_stringname_signal._ptr]))
    return _ret


  @functools.native_method
  def _get_script_signal_list(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(120,tuple([]))
    return _ret


  @functools.native_method
  def _has_property_default_value(self, property:'object'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'




    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)

    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([py_stringname_property._ptr]))
    return _ret


  @functools.native_method
  def _get_property_default_value(self, property:'object'   ) -> typing.Union[typing.Any]:
    r'''
'''

    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'




    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)

    _ret = None
    _ret = self._ptr.call_with_return(122,tuple([py_stringname_property._ptr]))
    return _ret


  @functools.native_method
  def _update_exports(self) -> None:
    r'''
'''




    self._ptr.call_with_return(123,tuple([]))

  @functools.native_method
  def _get_script_method_list(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([]))
    return _ret


  @functools.native_method
  def _get_script_property_list(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(125,tuple([]))
    return _ret


  @functools.native_method
  def _get_member_line(self, member:'object'   ) -> typing.Union[int]:
    r'''
'''

    assert(not member is None)
    assert isinstance(member, (str, StringName)), 'member must be str or StringName'




    assert(isinstance(member, (str, StringName)))
    py_stringname_member = member if isinstance(member, StringName) else c_utils.py_string_to_string_name(member)

    _ret = 0
    _ret = self._ptr.call_with_return(126,tuple([py_stringname_member._ptr]))
    return _ret


  @functools.native_method
  def _get_constants(self) -> typing.Union['Dictionary']:
    r'''
'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(127,tuple([]))
    return _ret


  @functools.native_method
  def _get_members(self) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
'''




    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(128,tuple([]))
    return _ret


  @functools.native_method
  def _is_placeholder_fallback_enabled(self) -> typing.Union[bool]:
    r'''
'''




    _ret = 0
    _ret = self._ptr.call_with_return(129,tuple([]))
    return _ret


  @functools.native_method
  def _get_rpc_config(self) -> typing.Union[typing.Any]:
    r'''
'''




    _ret = None
    _ret = self._ptr.call_with_return(130,tuple([]))
    return _ret



register_cast_function('ScriptExtension', ScriptExtension.cast)
register_cast_function('PyScriptExtension', ScriptExtension.cast)
register_class('ScriptExtension', ScriptExtension)
