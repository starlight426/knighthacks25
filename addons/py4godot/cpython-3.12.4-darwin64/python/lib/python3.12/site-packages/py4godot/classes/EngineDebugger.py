# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ScriptLanguage as py4godot_scriptlanguage 
  import py4godot.classes.EngineProfiler as py4godot_engineprofiler 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPEngineDebuggerWrapper

_EngineDebugger_singleton_instance = None

class EngineDebugger(py4godot_object.Object):
  r'''
		`EngineDebugger` handles the communication between the editor and the running game. It is active in the running game. Messages can be sent/received through it. It also manages the profilers.
	'''


  def generate_wrapper(self):
    return CPPEngineDebuggerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EngineDebugger.__new__(EngineDebugger)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EngineDebugger'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EngineDebugger.construct_without_init()
    cls._ptr = CPPEngineDebuggerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EngineDebugger.construct_without_init()
    cls._ptr = CPPEngineDebuggerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _EngineDebugger_singleton_instance
    if _EngineDebugger_singleton_instance is None:
      singleton = EngineDebugger()
      singleton._ptr = constructor(321,0, ())
      _EngineDebugger_singleton_instance = singleton
    return _EngineDebugger_singleton_instance

  @functools.native_method
  def is_active(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the debugger is active otherwise `false`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([]))
    return _ret


  @functools.native_method
  def register_profiler(self, name:'object'   , profiler:'py4godot_engineprofiler.EngineProfiler'   ) -> None:
    r'''
				Registers a profiler with the given `name`. See `EngineProfiler` for more information.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not profiler is None)
    assert isinstance(profiler, get_class('EngineProfiler')), 'profiler must be EngineProfiler'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(50,tuple([py_stringname_name._ptr, profiler._ptr]))

  @functools.native_method
  def unregister_profiler(self, name:'object'   ) -> None:
    r'''
				Unregisters a profiler with given `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(51,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def is_profiling(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a profiler with the given name is present and active otherwise `false`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(52,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_profiler(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a profiler with the given name is present otherwise `false`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def profiler_add_frame_data(self, name:'object'   , data:'Array'   ) -> None:
    r'''
				Calls the `add` callable of the profiler with given `name` and `data`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not data is None)
    assert isinstance(data, Array), 'data must be Array'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(54,tuple([py_stringname_name._ptr, data._ptr]))

  @functools.native_method
  def profiler_enable(self, name:'object'   , enable:'bool'   , arguments:'Array' = None  ) -> None:
    r'''
				Calls the `toggle` callable of the profiler with given `name` and `arguments`. Enables/Disables the same profiler depending on `enable` argument.
			'''
    if arguments is None:
      arguments = Array.new0()
    if arguments is None:
      arguments = Array.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(enable, bool), 'enable must be bool'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)



    self._ptr.call_with_return(55,tuple([py_stringname_name._ptr, enable, arguments._ptr]))

  @functools.native_method
  def register_message_capture(self, name:'object'   , callable:'Callable'   ) -> None:
    r'''
				Registers a message capture with given `name`. If `name` is "my_message" then messages starting with "my_message:" will be called with the given callable.
				The callable must accept a message string and a data array as argument. The callable should return `true` if the message is recognized.
				**Note:** The callable will receive the message with the prefix stripped, unlike `EditorDebuggerPlugin._capture`. See the `EditorDebuggerPlugin` description for an example.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(56,tuple([py_stringname_name._ptr, callable._ptr]))

  @functools.native_method
  def unregister_message_capture(self, name:'object'   ) -> None:
    r'''
				Unregisters the message capture with given `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(57,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def has_capture(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a capture with the given name is present otherwise `false`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def line_poll(self) -> None:
    r'''
				Forces a processing loop of debugger events. The purpose of this method is just processing events every now and then when the script might get too busy, so that bugs like infinite loops can be caught.
			'''




    self._ptr.call_with_return(59,tuple([]))

  @functools.native_method
  def send_message(self, message:'str'   , data:'Array'   ) -> None:
    r'''
				Sends a message with given `message` and `data` array.
			'''

    assert(not message is None)
    assert isinstance(message, (str, String)), 'message must be str or String'
    assert(not data is None)
    assert isinstance(data, Array), 'data must be Array'




    assert(isinstance(message, (str, String)))
    py_string_message = message if isinstance(message, StringName) else c_utils.py_string_to_string(message)


    self._ptr.call_with_return(60,tuple([py_string_message._ptr, data._ptr]))

  @functools.native_method
  def debug(self, can_continue:'bool' =True  , is_error_breakpoint:'bool' =False  ) -> None:
    r'''
				Starts a debug break in script execution, optionally specifying whether the program can continue based on `can_continue` and whether the break was due to a breakpoint.
			'''

    assert isinstance(can_continue, bool), 'can_continue must be bool'
    assert isinstance(is_error_breakpoint, bool), 'is_error_breakpoint must be bool'







    self._ptr.call_with_return(61,tuple([can_continue, is_error_breakpoint]))

  @functools.native_method
  def script_debug(self, language:'py4godot_scriptlanguage.ScriptLanguage'   , can_continue:'bool' =True  , is_error_breakpoint:'bool' =False  ) -> None:
    r'''
				Starts a debug break in script execution, optionally specifying whether the program can continue based on `can_continue` and whether the break was due to a breakpoint.
			'''

    assert(not language is None)
    assert isinstance(language, get_class('ScriptLanguage')), 'language must be ScriptLanguage'
    assert isinstance(can_continue, bool), 'can_continue must be bool'
    assert isinstance(is_error_breakpoint, bool), 'is_error_breakpoint must be bool'








    self._ptr.call_with_return(62,tuple([language._ptr, can_continue, is_error_breakpoint]))

  @functools.native_method
  def set_lines_left(self, lines:'int'   ) -> None:
    r'''
				Sets the current debugging lines that remain.
			'''

    assert isinstance(lines, (int, float)), 'lines must be int or float'






    self._ptr.call_with_return(63,tuple([lines]))

  @functools.native_method
  def get_lines_left(self) -> typing.Union[int]:
    r'''
				Returns the number of lines that remain.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([]))
    return _ret


  @functools.native_method
  def set_depth(self, depth:'int'   ) -> None:
    r'''
				Sets the current debugging depth.
			'''

    assert isinstance(depth, (int, float)), 'depth must be int or float'






    self._ptr.call_with_return(65,tuple([depth]))

  @functools.native_method
  def get_depth(self) -> typing.Union[int]:
    r'''
				Returns the current debug depth.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([]))
    return _ret


  @functools.native_method
  def is_breakpoint(self, line:'int'   , source:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `source` and `line` represent an existing breakpoint.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert(not source is None)
    assert isinstance(source, (str, StringName)), 'source must be str or StringName'





    assert(isinstance(source, (str, StringName)))
    py_stringname_source = source if isinstance(source, StringName) else c_utils.py_string_to_string_name(source)

    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([line, py_stringname_source._ptr]))
    return _ret


  @functools.native_method
  def is_skipping_breakpoints(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the debugger is skipping breakpoints otherwise `false`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([]))
    return _ret


  @functools.native_method
  def insert_breakpoint(self, line:'int'   , source:'object'   ) -> None:
    r'''
				Inserts a new breakpoint with the given `source` and `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert(not source is None)
    assert isinstance(source, (str, StringName)), 'source must be str or StringName'





    assert(isinstance(source, (str, StringName)))
    py_stringname_source = source if isinstance(source, StringName) else c_utils.py_string_to_string_name(source)

    self._ptr.call_with_return(69,tuple([line, py_stringname_source._ptr]))

  @functools.native_method
  def remove_breakpoint(self, line:'int'   , source:'object'   ) -> None:
    r'''
				Removes a breakpoint with the given `source` and `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert(not source is None)
    assert isinstance(source, (str, StringName)), 'source must be str or StringName'





    assert(isinstance(source, (str, StringName)))
    py_stringname_source = source if isinstance(source, StringName) else c_utils.py_string_to_string_name(source)

    self._ptr.call_with_return(70,tuple([line, py_stringname_source._ptr]))

  @functools.native_method
  def clear_breakpoints(self) -> None:
    r'''
				Clears all breakpoints.
			'''




    self._ptr.call_with_return(71,tuple([]))


register_cast_function('EngineDebugger', EngineDebugger.cast)
register_class('EngineDebugger', EngineDebugger)
