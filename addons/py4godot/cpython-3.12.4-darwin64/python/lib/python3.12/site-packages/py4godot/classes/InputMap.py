# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.InputEventTypedArray as py4godot_inputeventtypedarray 
  import py4godot.classes.InputEvent as py4godot_inputevent 
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.InputEventTypedArray as py4godot_inputeventtypedarray 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
from py4godot.wrappers.wrappers import CPPInputMapWrapper

_InputMap_singleton_instance = None

class InputMap(py4godot_object.Object):
  r'''
		Manages all `InputEventAction` which can be created/modified from the project settings menu **Project > Project Settings > Input Map** or in code with `add_action` and `action_add_event`. See `Node._input`.
	'''


  def generate_wrapper(self):
    return CPPInputMapWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = InputMap.__new__(InputMap)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'InputMap'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputMap.construct_without_init()
    cls._ptr = CPPInputMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputMap.construct_without_init()
    cls._ptr = CPPInputMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _InputMap_singleton_instance
    if _InputMap_singleton_instance is None:
      singleton = InputMap()
      singleton._ptr = constructor(430,0, ())
      _InputMap_singleton_instance = singleton
    return _InputMap_singleton_instance

  @functools.native_method
  def has_action(self, action:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `InputMap` has a registered action with the given name.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)

    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([py_stringname_action._ptr]))
    return _ret


  @functools.native_method
  def get_actions(self) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
				Returns an array of all actions in the `InputMap`.
			'''




    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return _ret


  @functools.native_method
  def add_action(self, action:'object'   , deadzone:'float' =0.2  ) -> None:
    r'''
				Adds an empty action to the `InputMap` with a configurable `deadzone`.
				An `InputEvent` can then be added to this action with `action_add_event`.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert isinstance(deadzone, (int, float)), 'deadzone must be int or float'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    self._ptr.call_with_return(51,tuple([py_stringname_action._ptr, deadzone]))

  @functools.native_method
  def erase_action(self, action:'object'   ) -> None:
    r'''
				Removes an action from the `InputMap`.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)

    self._ptr.call_with_return(52,tuple([py_stringname_action._ptr]))

  @functools.native_method
  def get_action_description(self, action:'object'   ) -> typing.Union[str]:
    r'''
				Returns the human-readable description of the given action.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([py_stringname_action._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def action_set_deadzone(self, action:'object'   , deadzone:'float'   ) -> None:
    r'''
				Sets a deadzone value for the action.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert isinstance(deadzone, (int, float)), 'deadzone must be int or float'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    self._ptr.call_with_return(54,tuple([py_stringname_action._ptr, deadzone]))

  @functools.native_method
  def action_get_deadzone(self, action:'object'   ) -> typing.Union[float]:
    r'''
				Returns a deadzone value for the action.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)

    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([py_stringname_action._ptr]))
    return _ret


  @functools.native_method
  def action_add_event(self, action:'object'   , event:'py4godot_inputevent.InputEvent'   ) -> None:
    r'''
				Adds an `InputEvent` to an action. This `InputEvent` will trigger the action.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    self._ptr.call_with_return(56,tuple([py_stringname_action._ptr, event._ptr]))

  @functools.native_method
  def action_has_event(self, action:'object'   , event:'py4godot_inputevent.InputEvent'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the action has the given `InputEvent` associated with it.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([py_stringname_action._ptr, event._ptr]))
    return _ret


  @functools.native_method
  def action_erase_event(self, action:'object'   , event:'py4godot_inputevent.InputEvent'   ) -> None:
    r'''
				Removes an `InputEvent` from an action.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    self._ptr.call_with_return(58,tuple([py_stringname_action._ptr, event._ptr]))

  @functools.native_method
  def action_erase_events(self, action:'object'   ) -> None:
    r'''
				Removes all events from an action.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)

    self._ptr.call_with_return(59,tuple([py_stringname_action._ptr]))

  @functools.native_method
  def action_get_events(self, action:'object'   ) -> typing.Union['py4godot_inputeventtypedarray.InputEventTypedArray']:
    r'''
				Returns an array of `InputEvent`s associated with a given action.
				**Note:** When used in the editor (e.g. a tool script or `EditorPlugin`), this method will return events for the editor action. If you want to access your project's input binds from the editor, read the `input/*` settings from `ProjectSettings`.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'




    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)

    _ret = py4godot_inputeventtypedarray.InputEventTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([py_stringname_action._ptr]))
    return _ret


  @functools.native_method
  def event_is_action(self, event:'py4godot_inputevent.InputEvent'   , action:'object'   , exact_match:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given event is part of an existing action. This method ignores keyboard modifiers if the given `InputEvent` is not pressed (for proper release detection). See `action_has_event` if you don't want this behavior.
				If `exact_match` is `false`, it ignores additional input modifiers for `InputEventKey` and `InputEventMouseButton` events, and the direction for `InputEventJoypadMotion` events.
			'''

    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'
    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert isinstance(exact_match, bool), 'exact_match must be bool'





    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([event._ptr, py_stringname_action._ptr, exact_match]))
    return _ret


  @functools.native_method
  def load_from_project_settings(self) -> None:
    r'''
				Clears all `InputEventAction` in the `InputMap` and load it anew from `ProjectSettings`.
			'''




    self._ptr.call_with_return(62,tuple([]))


register_cast_function('InputMap', InputMap.cast)
register_class('InputMap', InputMap)
