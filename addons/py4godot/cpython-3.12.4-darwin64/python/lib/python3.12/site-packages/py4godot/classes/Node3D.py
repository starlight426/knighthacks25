# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.VisibleOnScreenEnabler3D as py4godot_visibleonscreenenabler3d 
  import py4godot.classes.XRAnchor3D as py4godot_xranchor3d 
  import py4godot.classes.Area3D as py4godot_area3d 
  import py4godot.classes.CollisionShape3D as py4godot_collisionshape3d 
  import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.PathFollow3D as py4godot_pathfollow3d 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.SpringBoneCollision3D as py4godot_springbonecollision3d 
  import py4godot.classes.ImporterMeshInstance3D as py4godot_importermeshinstance3d 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
  import py4godot.classes.Node3DGizmoTypedArray as py4godot_node3dgizmotypedarray 
  import py4godot.classes.GPUParticlesCollisionSDF3D as py4godot_gpuparticlescollisionsdf3d 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.GPUParticlesCollision3D as py4godot_gpuparticlescollision3d 
  import py4godot.classes.World3D as py4godot_world3d 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.SpringArm3D as py4godot_springarm3d 
  import py4godot.classes.SpringBoneCollisionPlane3D as py4godot_springbonecollisionplane3d 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.SpringBoneCollisionCapsule3D as py4godot_springbonecollisioncapsule3d 
  import py4godot.classes.GPUParticlesCollisionHeightField3D as py4godot_gpuparticlescollisionheightfield3d 
  import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.Node3DGizmo as py4godot_node3dgizmo 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.RayCast3D as py4godot_raycast3d 
  import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.CollisionPolygon3D as py4godot_collisionpolygon3d 
  import py4godot.classes.PinJoint3D as py4godot_pinjoint3d 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.GridMap as py4godot_gridmap 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.GPUParticlesCollisionSphere3D as py4godot_gpuparticlescollisionsphere3d 
  import py4godot.classes.StaticBody3D as py4godot_staticbody3d 
  import py4godot.classes.HingeJoint3D as py4godot_hingejoint3d 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.SpringBoneCollisionSphere3D as py4godot_springbonecollisionsphere3d 
  import py4godot.classes.SliderJoint3D as py4godot_sliderjoint3d 
  import py4godot.classes.AnimatableBody3D as py4godot_animatablebody3d 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
  import py4godot.classes.ReflectionProbe as py4godot_reflectionprobe 
  import py4godot.classes.NavigationLink3D as py4godot_navigationlink3d 
  import py4godot.classes.GPUParticlesAttractorBox3D as py4godot_gpuparticlesattractorbox3d 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.RootMotionView as py4godot_rootmotionview 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.OccluderInstance3D as py4godot_occluderinstance3d 
  import py4godot.classes.FogVolume as py4godot_fogvolume 
  import py4godot.classes.AudioStreamPlayer3D as py4godot_audiostreamplayer3d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.GPUParticlesCollisionBox3D as py4godot_gpuparticlescollisionbox3d 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.LightmapProbe as py4godot_lightmapprobe 
  import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.XRNode3D as py4godot_xrnode3d 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.XRController3D as py4godot_xrcontroller3d 
  import py4godot.classes.OpenXRVisibilityMask as py4godot_openxrvisibilitymask 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.VehicleWheel3D as py4godot_vehiclewheel3d 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
  import py4godot.classes.GPUParticlesAttractorVectorField3D as py4godot_gpuparticlesattractorvectorfield3d 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
  import py4godot.classes.CharacterBody3D as py4godot_characterbody3d 
  import py4godot.classes.ShapeCast3D as py4godot_shapecast3d 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.LightmapGI as py4godot_lightmapgi 
  import py4godot.classes.VoxelGI as py4godot_voxelgi 
  import py4godot.classes.XRFaceModifier3D as py4godot_xrfacemodifier3d 
  import py4godot.classes.PhysicalBone3D as py4godot_physicalbone3d 
  import py4godot.classes.ConeTwistJoint3D as py4godot_conetwistjoint3d 
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
  import py4godot.classes.VisibleOnScreenNotifier3D as py4godot_visibleonscreennotifier3d 
  import py4godot.classes.Marker3D as py4godot_marker3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.OpenXRHand as py4godot_openxrhand 
  import py4godot.classes.Generic6DOFJoint3D as py4godot_generic6dofjoint3d 
  import py4godot.classes.Joint3D as py4godot_joint3d 
  import py4godot.classes.RigidBody3D as py4godot_rigidbody3d 
  import py4godot.classes.Light3D as py4godot_light3d 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.OpenXRRenderModel as py4godot_openxrrendermodel 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.OpenXRCompositionLayer as py4godot_openxrcompositionlayer 
  import py4godot.classes.LookAtModifier3D as py4godot_lookatmodifier3d 
  import py4godot.classes.NavigationRegion3D as py4godot_navigationregion3d 
  import py4godot.classes.NavigationObstacle3D as py4godot_navigationobstacle3d 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.OpenXRRenderModelManager as py4godot_openxrrendermodelmanager 
  import py4godot.classes.Decal as py4godot_decal 
  import py4godot.classes.Path3D as py4godot_path3d 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.XROrigin3D as py4godot_xrorigin3d 
  import py4godot.classes.BoneAttachment3D as py4godot_boneattachment3d 
  import py4godot.classes.RemoteTransform3D as py4godot_remotetransform3d 
  import py4godot.classes.GPUParticlesAttractorSphere3D as py4godot_gpuparticlesattractorsphere3d 
import py4godot.classes.Node3DGizmoTypedArray as py4godot_node3dgizmotypedarray 
import py4godot.classes.Node as py4godot_node 
from py4godot.wrappers.wrappers import CPPNode3DWrapper

class RotationEditMode:
  ROTATION_EDIT_MODE_EULER = 0
  ROTATION_EDIT_MODE_QUATERNION = 1
  ROTATION_EDIT_MODE_BASIS = 2


class Node3D(py4godot_node.Node):
  r'''
		The `Node3D` node is the base representation of a node in 3D space. All other 3D nodes inherit from this class.
		Affine operations (translation, rotation, scale) are calculated in the coordinate system relative to the parent, unless the `Node3D`'s `top_level` is `true`. In this coordinate system, affine operations correspond to direct affine operations on the `Node3D`'s `transform`. The term _parent space_ refers to this coordinate system. The coordinate system that is attached to the `Node3D` itself is referred to as object-local coordinate system, or _local space_.
		**Note:** Unless otherwise specified, all methods that need angle parameters must receive angles in _radians_. To convert degrees to radians, use `@GlobalScope.deg_to_rad`.
		**Note:** In Godot 3 and older, `Node3D` was named _Spatial_.
	'''
  NOTIFICATION_TRANSFORM_CHANGED:typing.ClassVar[int]

  NOTIFICATION_ENTER_WORLD:typing.ClassVar[int]

  NOTIFICATION_EXIT_WORLD:typing.ClassVar[int]

  NOTIFICATION_VISIBILITY_CHANGED:typing.ClassVar[int]

  NOTIFICATION_LOCAL_TRANSFORM_CHANGED:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = Node3D.construct_without_init()
    class_._ptr = constructor(516,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Node3D.construct_without_init()
    class_._ptr = constructor(516,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNode3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(516,0, ())


  def generate_wrapper(self):
    return CPPNode3DWrapper()
  def init_signals(self):
    super().init_signals()
    visibility_changed_name = utils.py_string_to_string_name("visibility_changed")
    self.visibility_changed = signals.BuiltinSignal(self, visibility_changed_name)

  @staticmethod
  def construct_without_init():
    cls = Node3D.__new__(Node3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Node3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Node3D.construct_without_init()
    cls._ptr = CPPNode3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Node3D.construct_without_init()
    cls._ptr = CPPNode3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def transform(self) -> typing.Union['Transform3D']:
    r''''''
    _ret = self. get_transform()
    return _ret
  @transform.setter
  def transform(self,  value:'Transform3D'):
    self.set_transform(value)
  @property
  def global_transform(self) -> typing.Union['Transform3D']:
    r''''''
    _ret = self. get_global_transform()
    return _ret
  @global_transform.setter
  def global_transform(self,  value:'Transform3D'):
    self.set_global_transform(value)
  @property
  def position(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_position()
    return _ret
  @position.setter
  def position(self,  value:'Vector3'):
    self.set_position(value)
  @property
  def rotation(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_rotation()
    return _ret
  @rotation.setter
  def rotation(self,  value:'Vector3'):
    self.set_rotation(value)
  @property
  def rotation_degrees(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_rotation_degrees()
    return _ret
  @rotation_degrees.setter
  def rotation_degrees(self,  value:'Vector3'):
    self.set_rotation_degrees(value)
  @property
  def quaternion(self) -> typing.Union['Quaternion']:
    r''''''
    _ret = self. get_quaternion()
    return _ret
  @quaternion.setter
  def quaternion(self,  value:'Quaternion'):
    self.set_quaternion(value)
  @property
  def basis(self) -> typing.Union['Basis']:
    r''''''
    _ret = self. get_basis()
    return _ret
  @basis.setter
  def basis(self,  value:'Basis'):
    self.set_basis(value)
  @property
  def scale(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_scale()
    return _ret
  @scale.setter
  def scale(self,  value:'Vector3'):
    self.set_scale(value)
  @property
  def rotation_edit_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_rotation_edit_mode()
    return _ret
  @rotation_edit_mode.setter
  def rotation_edit_mode(self,  value:'int'):
    self.set_rotation_edit_mode(value)
  @property
  def rotation_order(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_rotation_order()
    return _ret
  @rotation_order.setter
  def rotation_order(self,  value:'int'):
    self.set_rotation_order(value)
  @property
  def top_level(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_set_as_top_level()
    return _ret
  @top_level.setter
  def top_level(self,  value:'bool'):
    self.set_as_top_level(value)
  @property
  def global_position(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_global_position()
    return _ret
  @global_position.setter
  def global_position(self,  value:'Vector3'):
    self.set_global_position(value)
  @property
  def global_basis(self) -> typing.Union['Basis']:
    r''''''
    _ret = self. get_global_basis()
    return _ret
  @global_basis.setter
  def global_basis(self,  value:'Basis'):
    self.set_global_basis(value)
  @property
  def global_rotation(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_global_rotation()
    return _ret
  @global_rotation.setter
  def global_rotation(self,  value:'Vector3'):
    self.set_global_rotation(value)
  @property
  def global_rotation_degrees(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_global_rotation_degrees()
    return _ret
  @global_rotation_degrees.setter
  def global_rotation_degrees(self,  value:'Vector3'):
    self.set_global_rotation_degrees(value)
  @property
  def visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_visible()
    return _ret
  @visible.setter
  def visible(self,  value:'bool'):
    self.set_visible(value)
  @property
  def visibility_parent(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_visibility_parent()
    return _ret
  @visibility_parent.setter
  def visibility_parent(self,  value:'object'):
    self.set_visibility_parent(value)
  @functools.native_method
  def set_transform(self, local:'Transform3D'   ) -> None:
    r''''''

    assert(not local is None)
    assert isinstance(local, Transform3D), 'local must be Transform3D'

    self.py__transform = local






    self._ptr.call_with_return(180,tuple([local._ptr]))

  @functools.native_method
  def get_transform(self) -> typing.Union['Transform3D']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(181,tuple([]))

    return _ret


  @functools.native_method
  def set_position(self, position:'Vector3'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'

    self.py__position = position






    self._ptr.call_with_return(182,tuple([position._ptr]))

  @functools.native_method
  def get_position(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(183,tuple([]))

    return _ret


  @functools.native_method
  def set_rotation(self, euler_radians:'Vector3'   ) -> None:
    r''''''

    assert(not euler_radians is None)
    assert isinstance(euler_radians, Vector3), 'euler_radians must be Vector3'

    self.py__rotation = euler_radians






    self._ptr.call_with_return(184,tuple([euler_radians._ptr]))

  @functools.native_method
  def get_rotation(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(185,tuple([]))

    return _ret


  @functools.native_method
  def set_rotation_degrees(self, euler_degrees:'Vector3'   ) -> None:
    r''''''

    assert(not euler_degrees is None)
    assert isinstance(euler_degrees, Vector3), 'euler_degrees must be Vector3'

    self.py__rotation_degrees = euler_degrees






    self._ptr.call_with_return(186,tuple([euler_degrees._ptr]))

  @functools.native_method
  def get_rotation_degrees(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(187,tuple([]))

    return _ret


  @functools.native_method
  def set_rotation_order(self, order:'int'  ) -> None:
    r''''''

    assert isinstance(order, (int, float)), 'order must be int or float'

    self.py__rotation_order = order






    self._ptr.call_with_return(188,tuple([order]))

  @functools.native_method
  def get_rotation_order(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(189,tuple([]))

    return _ret


  @functools.native_method
  def set_rotation_edit_mode(self, edit_mode:'int'  ) -> None:
    r''''''

    assert isinstance(edit_mode, (int, float)), 'edit_mode must be int or float'

    self.py__rotation_edit_mode = edit_mode






    self._ptr.call_with_return(190,tuple([edit_mode]))

  @functools.native_method
  def get_rotation_edit_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(191,tuple([]))

    return _ret


  @functools.native_method
  def set_scale(self, scale:'Vector3'   ) -> None:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'

    self.py__scale = scale






    self._ptr.call_with_return(192,tuple([scale._ptr]))

  @functools.native_method
  def get_scale(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(193,tuple([]))

    return _ret


  @functools.native_method
  def set_quaternion(self, quaternion:'Quaternion'   ) -> None:
    r''''''

    assert(not quaternion is None)
    assert isinstance(quaternion, Quaternion), 'quaternion must be Quaternion'

    self.py__quaternion = quaternion






    self._ptr.call_with_return(194,tuple([quaternion._ptr]))

  @functools.native_method
  def get_quaternion(self) -> typing.Union['Quaternion']:
    r''''''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(195,tuple([]))

    return _ret


  @functools.native_method
  def set_basis(self, basis:'Basis'   ) -> None:
    r''''''

    assert(not basis is None)
    assert isinstance(basis, Basis), 'basis must be Basis'

    self.py__basis = basis






    self._ptr.call_with_return(196,tuple([basis._ptr]))

  @functools.native_method
  def get_basis(self) -> typing.Union['Basis']:
    r''''''




    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(197,tuple([]))

    return _ret


  @functools.native_method
  def set_global_transform(self, global_:'Transform3D'   ) -> None:
    r''''''

    assert(not global_ is None)
    assert isinstance(global_, Transform3D), 'global_ must be Transform3D'

    self.py__global_transform = global_






    self._ptr.call_with_return(198,tuple([global_._ptr]))

  @functools.native_method
  def get_global_transform(self) -> typing.Union['Transform3D']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(199,tuple([]))

    return _ret


  @functools.native_method
  def get_global_transform_interpolated(self) -> typing.Union['Transform3D']:
    r'''
				When using physics interpolation, there will be circumstances in which you want to know the interpolated (displayed) transform of a node rather than the standard transform (which may only be accurate to the most recent physics tick).
				This is particularly important for frame-based operations that take place in `Node._process`, rather than `Node._physics_process`. Examples include `Camera3D`s focusing on a node, or finding where to fire lasers from on a frame rather than physics tick.
				**Note:** This function creates an interpolation pump on the `Node3D` the first time it is called, which can respond to physics interpolation resets. If you get problems with "streaking" when initially following a `Node3D`, be sure to call `get_global_transform_interpolated` at least once _before_ resetting the `Node3D` physics interpolation.
			'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(200,tuple([]))
    return _ret


  @functools.native_method
  def set_global_position(self, position:'Vector3'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'

    self.py__global_position = position






    self._ptr.call_with_return(201,tuple([position._ptr]))

  @functools.native_method
  def get_global_position(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(202,tuple([]))

    return _ret


  @functools.native_method
  def set_global_basis(self, basis:'Basis'   ) -> None:
    r''''''

    assert(not basis is None)
    assert isinstance(basis, Basis), 'basis must be Basis'

    self.py__global_basis = basis






    self._ptr.call_with_return(203,tuple([basis._ptr]))

  @functools.native_method
  def get_global_basis(self) -> typing.Union['Basis']:
    r''''''




    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(204,tuple([]))

    return _ret


  @functools.native_method
  def set_global_rotation(self, euler_radians:'Vector3'   ) -> None:
    r''''''

    assert(not euler_radians is None)
    assert isinstance(euler_radians, Vector3), 'euler_radians must be Vector3'

    self.py__global_rotation = euler_radians






    self._ptr.call_with_return(205,tuple([euler_radians._ptr]))

  @functools.native_method
  def get_global_rotation(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(206,tuple([]))

    return _ret


  @functools.native_method
  def set_global_rotation_degrees(self, euler_degrees:'Vector3'   ) -> None:
    r''''''

    assert(not euler_degrees is None)
    assert isinstance(euler_degrees, Vector3), 'euler_degrees must be Vector3'

    self.py__global_rotation_degrees = euler_degrees






    self._ptr.call_with_return(207,tuple([euler_degrees._ptr]))

  @functools.native_method
  def get_global_rotation_degrees(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(208,tuple([]))

    return _ret


  @functools.native_method
  def get_parent_node_3d(self) -> typing.Any:
    r'''
				Returns the parent `Node3D` that directly affects this node's `global_transform`. Returns `null` if no parent exists, the parent is not a `Node3D`, or `top_level` is `true`.
				**Note:** This method is not always equivalent to `Node.get_parent`, which does not take `top_level` into account.
			'''




    _ret = Node3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(209,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_ignore_transform_notification(self, enabled:'bool'   ) -> None:
    r'''
				If `true`, the node will not receive `constant NOTIFICATION_TRANSFORM_CHANGED` or `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED`.
				It may useful to call this method when handling these notifications to prevent infinite recursion.
			'''

    assert isinstance(enabled, bool), 'enabled must be bool'






    self._ptr.call_with_return(210,tuple([enabled]))

  @functools.native_method
  def set_as_top_level(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__top_level = enable






    self._ptr.call_with_return(211,tuple([enable]))

  @functools.native_method
  def is_set_as_top_level(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(212,tuple([]))

    return _ret


  @functools.native_method
  def set_disable_scale(self, disable:'bool'   ) -> None:
    r'''
				If `true`, this node's `global_transform` is automatically orthonormalized. This results in this node not appearing distorted, as if its global scale were set to `constant Vector3.ONE` (or its negative counterpart). See also `is_scale_disabled` and `orthonormalize`.
				**Note:** `transform` is not affected by this setting.
			'''

    assert isinstance(disable, bool), 'disable must be bool'






    self._ptr.call_with_return(213,tuple([disable]))

  @functools.native_method
  def is_scale_disabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this node's `global_transform` is automatically orthonormalized. This results in this node not appearing distorted, as if its global scale were set to `constant Vector3.ONE` (or its negative counterpart). See also `set_disable_scale` and `orthonormalize`.
				**Note:** `transform` is not affected by this setting.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(214,tuple([]))
    return _ret


  @functools.native_method
  def get_world_3d(self) -> typing.Union['py4godot_world3d.World3D']:
    r'''
				Returns the `World3D` this node is registered to.
				Usually, this is the same as the world used by this node's viewport (see `Node.get_viewport` and `Viewport.find_world_3d`).
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: World3D
    _ret._ptr = self._ptr.call_with_return(215,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def force_update_transform(self) -> None:
    r'''
				Forces the node's `global_transform` to update, by sending `constant NOTIFICATION_TRANSFORM_CHANGED`. Fails if the node is not inside the tree.
				**Note:** For performance reasons, transform changes are usually accumulated and applied _once_ at the end of the frame. The update propagates through `Node3D` children, as well. Therefore, use this method only when you need an up-to-date transform (such as during physics operations).
			'''




    self._ptr.call_with_return(216,tuple([]))

  @functools.native_method
  def set_visibility_parent(self, path:'object'   ) -> None:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'

    self.py__visibility_parent = path



    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)


    self._ptr.call_with_return(217,tuple([py_nodepath_path._ptr]))

  @functools.native_method
  def get_visibility_parent(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(218,tuple([]))

    return _ret


  @functools.native_method
  def update_gizmos(self) -> None:
    r'''
				Updates all the `EditorNode3DGizmo` objects attached to this node. Only works in the editor.
			'''




    self._ptr.call_with_return(219,tuple([]))

  @functools.native_method
  def add_gizmo(self, gizmo:'py4godot_node3dgizmo.Node3DGizmo'   ) -> None:
    r'''
				Attaches the given `gizmo` to this node. Only works in the editor.
				**Note:** `gizmo` should be an `EditorNode3DGizmo`. The argument type is `Node3DGizmo` to avoid depending on editor classes in `Node3D`.
			'''

    assert(not gizmo is None)
    assert isinstance(gizmo, get_class('Node3DGizmo')), 'gizmo must be Node3DGizmo'






    self._ptr.call_with_return(220,tuple([gizmo._ptr]))

  @functools.native_method
  def get_gizmos(self) -> typing.Union['py4godot_node3dgizmotypedarray.Node3DGizmoTypedArray']:
    r'''
				Returns all the `EditorNode3DGizmo` objects attached to this node. Only works in the editor.
			'''




    _ret = py4godot_node3dgizmotypedarray.Node3DGizmoTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(221,tuple([]))
    return _ret


  @functools.native_method
  def clear_gizmos(self) -> None:
    r'''
				Clears all `EditorNode3DGizmo` objects attached to this node. Only works in the editor.
			'''




    self._ptr.call_with_return(222,tuple([]))

  @functools.native_method
  def set_subgizmo_selection(self, gizmo:'py4godot_node3dgizmo.Node3DGizmo'   , id:'int'   , transform:'Transform3D'   ) -> None:
    r'''
				Selects the `gizmo`'s subgizmo with the given `id` and sets its transform. Only works in the editor.
				**Note:** The gizmo object would typically be an instance of `EditorNode3DGizmo`, but the argument type is kept generic to avoid creating a dependency on editor classes in `Node3D`.
			'''

    assert(not gizmo is None)
    assert isinstance(gizmo, get_class('Node3DGizmo')), 'gizmo must be Node3DGizmo'
    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'








    self._ptr.call_with_return(223,tuple([gizmo._ptr, id, transform._ptr]))

  @functools.native_method
  def clear_subgizmo_selection(self) -> None:
    r'''
				Deselects all subgizmos for this node. Useful to call when the selected subgizmo may no longer exist after a property change. Only works in the editor.
			'''




    self._ptr.call_with_return(224,tuple([]))

  @functools.native_method
  def set_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'

    self.py__visible = visible






    self._ptr.call_with_return(225,tuple([visible]))

  @functools.native_method
  def is_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(226,tuple([]))

    return _ret


  @functools.native_method
  def is_visible_in_tree(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this node is inside the scene tree and the `visible` property is `true` for this node and all of its `Node3D` ancestors _in sequence_. An ancestor of any other type (such as `Node` or `Node2D`) breaks the sequence. See also `Node.get_parent`.
				**Note:** This method cannot take `VisualInstance3D.layers` into account, so even if this method returns `true`, the node may not be rendered.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(227,tuple([]))
    return _ret


  @functools.native_method
  def show(self) -> None:
    r'''
				Allows this node to be rendered. Equivalent to setting `visible` to `true`. This is the opposite of `hide`.
			'''




    self._ptr.call_with_return(228,tuple([]))

  @functools.native_method
  def hide(self) -> None:
    r'''
				Prevents this node from being rendered. Equivalent to setting `visible` to `false`. This is the opposite of `show`.
			'''




    self._ptr.call_with_return(229,tuple([]))

  @functools.native_method
  def set_notify_local_transform(self, enable:'bool'   ) -> None:
    r'''
				If `true`, the node will receive `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever `transform` changes.
				**Note:** Some 3D nodes such as `CSGShape3D` or `CollisionShape3D` automatically enable this to function correctly.
			'''

    assert isinstance(enable, bool), 'enable must be bool'






    self._ptr.call_with_return(230,tuple([enable]))

  @functools.native_method
  def is_local_transform_notification_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the node receives `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever `transform` changes. This is enabled with `set_notify_local_transform`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(231,tuple([]))
    return _ret


  @functools.native_method
  def set_notify_transform(self, enable:'bool'   ) -> None:
    r'''
				If `true`, the node will receive `constant NOTIFICATION_TRANSFORM_CHANGED` whenever `global_transform` changes.
				**Note:** Most 3D nodes such as `VisualInstance3D` or `CollisionObject3D` automatically enable this to function correctly.
				**Note:** In the editor, nodes will propagate this notification to their children if a gizmo is attached (see `add_gizmo`).
			'''

    assert isinstance(enable, bool), 'enable must be bool'






    self._ptr.call_with_return(232,tuple([enable]))

  @functools.native_method
  def is_transform_notification_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the node receives `constant NOTIFICATION_TRANSFORM_CHANGED` whenever `global_transform` changes. This is enabled with `set_notify_transform`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(233,tuple([]))
    return _ret


  @functools.native_method
  def rotate(self, axis:'Vector3'   , angle:'float'   ) -> None:
    r'''
				Rotates this node's `basis` around the `axis` by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			'''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'







    self._ptr.call_with_return(234,tuple([axis._ptr, angle]))

  @functools.native_method
  def global_rotate(self, axis:'Vector3'   , angle:'float'   ) -> None:
    r'''
				Rotates this node's `global_basis` around the global `axis` by the given `angle`, in radians. This operation is calculated in global space (relative to the world) and preserves the `global_position`.
			'''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'







    self._ptr.call_with_return(235,tuple([axis._ptr, angle]))

  @functools.native_method
  def global_scale(self, scale:'Vector3'   ) -> None:
    r'''
				Scales this node's `global_basis` by the given `scale` factor. This operation is calculated in global space (relative to the world) and preserves the `global_position`.
				**Note:** This method is not to be confused with the `scale` property.
			'''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'






    self._ptr.call_with_return(236,tuple([scale._ptr]))

  @functools.native_method
  def global_translate(self, offset:'Vector3'   ) -> None:
    r'''
				Adds the given translation `offset` to the node's `global_position` in global space (relative to the world).
			'''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'






    self._ptr.call_with_return(237,tuple([offset._ptr]))

  @functools.native_method
  def rotate_object_local(self, axis:'Vector3'   , angle:'float'   ) -> None:
    r'''
				Rotates this node's `basis` around the `axis` by the given `angle`, in radians. This operation is calculated in local space (relative to this node) and preserves the `position`.
			'''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'







    self._ptr.call_with_return(238,tuple([axis._ptr, angle]))

  @functools.native_method
  def scale_object_local(self, scale:'Vector3'   ) -> None:
    r'''
				Scales this node's `basis` by the given `scale` factor. This operation is calculated in local space (relative to this node) and preserves the `position`.
			'''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'






    self._ptr.call_with_return(239,tuple([scale._ptr]))

  @functools.native_method
  def translate_object_local(self, offset:'Vector3'   ) -> None:
    r'''
				Adds the given translation `offset` to the node's position, in local space (relative to this node).
			'''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'






    self._ptr.call_with_return(240,tuple([offset._ptr]))

  @functools.native_method
  def rotate_x(self, angle:'float'   ) -> None:
    r'''
				Rotates this node's `basis` around the X axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			'''

    assert isinstance(angle, (int, float)), 'angle must be int or float'






    self._ptr.call_with_return(241,tuple([angle]))

  @functools.native_method
  def rotate_y(self, angle:'float'   ) -> None:
    r'''
				Rotates this node's `basis` around the Y axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			'''

    assert isinstance(angle, (int, float)), 'angle must be int or float'






    self._ptr.call_with_return(242,tuple([angle]))

  @functools.native_method
  def rotate_z(self, angle:'float'   ) -> None:
    r'''
				Rotates this node's `basis` around the Z axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			'''

    assert isinstance(angle, (int, float)), 'angle must be int or float'






    self._ptr.call_with_return(243,tuple([angle]))

  @functools.native_method
  def translate(self, offset:'Vector3'   ) -> None:
    r'''
				Adds the given translation `offset` to the node's position, in local space (relative to this node).
				**Note:** Prefer using `translate_object_local`, instead, as this method may be changed in a future release.
				**Note:** Despite the naming convention, this operation is **not** calculated in parent space for compatibility reasons. To translate in parent space, add `offset` to the `position` (`node_3d.position += offset`).
			'''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'






    self._ptr.call_with_return(244,tuple([offset._ptr]))

  @functools.native_method
  def orthonormalize(self) -> None:
    r'''
				Orthonormalizes this node's `basis`. This method sets this node's `scale` to `constant Vector3.ONE` (or its negative counterpart), but preserves the `position` and `rotation`. See also `Transform3D.orthonormalized`.
			'''




    self._ptr.call_with_return(245,tuple([]))

  @functools.native_method
  def set_identity(self) -> None:
    r'''
				Sets this node's `transform` to `constant Transform3D.IDENTITY`, which resets all transformations in parent space (`position`, `rotation`, and `scale`).
			'''




    self._ptr.call_with_return(246,tuple([]))

  @functools.native_method
  def look_at(self, target:'Vector3'   , up:'Vector3' = None  , use_model_front:'bool' =False  ) -> None:
    r'''
				Rotates the node so that the local forward axis (-Z, `constant Vector3.FORWARD`) points toward the `target` position. This operation is calculated in global space (relative to the world).
				The local up axis (+Y) points as close to the `up` vector as possible while staying perpendicular to the local forward axis. The resulting transform is orthogonal, and the scale is preserved. Non-uniform scaling may not work correctly.
				The `target` position cannot be the same as the node's position, the `up` vector cannot be `constant Vector3.ZERO`. Furthermore, the direction from the node's position to the `target` position cannot be parallel to the `up` vector, to avoid an unintended rotation around the local Z axis.
				If `use_model_front` is `true`, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the `target` position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).
				**Note:** This method fails if the node is not in the scene tree. If necessary, use `look_at_from_position` instead.
			'''
    if up is None:
      up = Vector3.new0()
    if up is None:
      up = Vector3.new0()

    assert(not target is None)
    assert isinstance(target, Vector3), 'target must be Vector3'
    assert isinstance(use_model_front, bool), 'use_model_front must be bool'








    self._ptr.call_with_return(247,tuple([target._ptr, up._ptr, use_model_front]))

  @functools.native_method
  def look_at_from_position(self, position:'Vector3'   , target:'Vector3'   , up:'Vector3' = None  , use_model_front:'bool' =False  ) -> None:
    r'''
				Moves the node to the specified `position`, then rotates the node to point toward the `target` position, similar to `look_at`. This operation is calculated in global space (relative to the world).
			'''
    if up is None:
      up = Vector3.new0()
    if up is None:
      up = Vector3.new0()

    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'
    assert(not target is None)
    assert isinstance(target, Vector3), 'target must be Vector3'
    assert isinstance(use_model_front, bool), 'use_model_front must be bool'









    self._ptr.call_with_return(248,tuple([position._ptr, target._ptr, up._ptr, use_model_front]))

  @functools.native_method
  def to_local(self, global_point:'Vector3'   ) -> typing.Union['Vector3']:
    r'''
				Returns the `global_point` converted from global space to this node's local space. This is the opposite of `to_global`.
			'''

    assert(not global_point is None)
    assert isinstance(global_point, Vector3), 'global_point must be Vector3'






    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(249,tuple([global_point._ptr]))
    return _ret


  @functools.native_method
  def to_global(self, local_point:'Vector3'   ) -> typing.Union['Vector3']:
    r'''
				Returns the `local_point` converted from this node's local space to global space. This is the opposite of `to_local`.
			'''

    assert(not local_point is None)
    assert isinstance(local_point, Vector3), 'local_point must be Vector3'






    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(250,tuple([local_point._ptr]))
    return _ret



register_cast_function('Node3D', Node3D.cast)
register_class('Node3D', Node3D)
