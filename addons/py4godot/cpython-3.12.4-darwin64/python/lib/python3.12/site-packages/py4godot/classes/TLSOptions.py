# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.CryptoKey as py4godot_cryptokey 
  import py4godot.classes.X509Certificate as py4godot_x509certificate 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPTLSOptionsWrapper


class TLSOptions(py4godot_refcounted.RefCounted):
  r'''
		TLSOptions abstracts the configuration options for the `StreamPeerTLS` and `PacketPeerDTLS` classes.
		Objects of this class cannot be instantiated directly, and one of the static methods `client`, `client_unsafe`, or `server` should be used instead.
		
		```gdscript
		# Create a TLS client configuration which uses our custom trusted CA chain.
		var client_trusted_cas = load("res://my_trusted_cas.crt")
		var client_tls_options = TLSOptions.client(client_trusted_cas)

		# Create a TLS server configuration.
		var server_certs = load("res://my_server_cas.crt")
		var server_key = load("res://my_server_key.key")
		var server_tls_options = TLSOptions.server(server_key, server_certs)
		```
		
	'''

  @staticmethod
  def constructor():
    class_ = TLSOptions.construct_without_init()
    class_._ptr = constructor(805,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TLSOptions.construct_without_init()
    class_._ptr = constructor(805,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTLSOptionsWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(805,0, ())


  def generate_wrapper(self):
    return CPPTLSOptionsWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TLSOptions.__new__(TLSOptions)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TLSOptions'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TLSOptions.construct_without_init()
    cls._ptr = CPPTLSOptionsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TLSOptions.construct_without_init()
    cls._ptr = CPPTLSOptionsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @staticmethod
  def client(trusted_chain:'py4godot_x509certificate.X509Certificate' = None  , common_name_override:'str' =""  ) -> typing.Union['typing.Self']:
    r'''
				Creates a TLS client configuration which validates certificates and their common names (fully qualified domain names).
				You can specify a custom `trusted_chain` of certification authorities (the default CA list will be used if `null`), and optionally provide a `common_name_override` if you expect the certificate to have a common name other than the server FQDN.
				**Note:** On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
			'''
    if trusted_chain is None:
      trusted_chain = c_utils.empty_object
    if common_name_override is None:
      common_name_override = String.new0()
    if trusted_chain is None:
      trusted_chain = c_utils.empty_object
    if common_name_override is None:
      common_name_override = String.new0()






    assert(isinstance(common_name_override, (str, String)))
    py_string_common_name_override = common_name_override if isinstance(common_name_override, StringName) else c_utils.py_string_to_string(common_name_override)

    _ret = TLSOptions.construct_without_init()
    _ret._ptr = static_method(805,0,tuple([trusted_chain._ptr, py_string_common_name_override._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @staticmethod
  def client_unsafe(trusted_chain:'py4godot_x509certificate.X509Certificate' = None  ) -> typing.Union['typing.Self']:
    r'''
				Creates an **unsafe** TLS client configuration where certificate validation is optional. You can optionally provide a valid `trusted_chain`, but the common name of the certificates will never be checked. Using this configuration for purposes other than testing **is not recommended**.
				**Note:** On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
			'''
    if trusted_chain is None:
      trusted_chain = c_utils.empty_object
    if trusted_chain is None:
      trusted_chain = c_utils.empty_object







    _ret = TLSOptions.construct_without_init()
    _ret._ptr = static_method(805,1,tuple([trusted_chain._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @staticmethod
  def server(key:'py4godot_cryptokey.CryptoKey'   , certificate:'py4godot_x509certificate.X509Certificate'   ) -> typing.Union['typing.Self']:
    r'''
				Creates a TLS server configuration using the provided `key` and `certificate`.
				**Note:** The `certificate` should include the full certificate chain up to the signing CA (certificates file can be concatenated using a general purpose text editor).
			'''

    assert(not key is None)
    assert isinstance(key, get_class('CryptoKey')), 'key must be CryptoKey'
    assert(not certificate is None)
    assert isinstance(certificate, get_class('X509Certificate')), 'certificate must be X509Certificate'







    _ret = TLSOptions.construct_without_init()
    _ret._ptr = static_method(805,2,tuple([key._ptr, certificate._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_server(self) -> typing.Union[bool]:
    r'''
				Returns `true` if created with `TLSOptions.server`, `false` otherwise.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def is_unsafe_client(self) -> typing.Union[bool]:
    r'''
				Returns `true` if created with `TLSOptions.client_unsafe`, `false` otherwise.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([]))
    return _ret


  @functools.native_method
  def get_common_name_override(self) -> typing.Union[str]:
    r'''
				Returns the common name (domain name) override specified when creating with `TLSOptions.client`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_trusted_ca_chain(self) -> typing.Union['py4godot_x509certificate.X509Certificate']:
    r'''
				Returns the CA `X509Certificate` chain specified when creating with `TLSOptions.client` or `TLSOptions.client_unsafe`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: X509Certificate
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_private_key(self) -> typing.Union['py4godot_cryptokey.CryptoKey']:
    r'''
				Returns the `CryptoKey` specified when creating with `TLSOptions.server`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: CryptoKey
    _ret._ptr = self._ptr.call_with_return(57,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_own_certificate(self) -> typing.Union['py4godot_x509certificate.X509Certificate']:
    r'''
				Returns the `X509Certificate` specified when creating with `TLSOptions.server`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: X509Certificate
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('TLSOptions', TLSOptions.cast)
register_class('TLSOptions', TLSOptions)
