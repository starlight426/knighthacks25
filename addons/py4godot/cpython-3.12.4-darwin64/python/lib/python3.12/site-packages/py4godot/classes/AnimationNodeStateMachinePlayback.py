# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
from py4godot.wrappers.wrappers import CPPAnimationNodeStateMachinePlaybackWrapper


class AnimationNodeStateMachinePlayback(py4godot_resource.Resource):
  r'''
		Allows control of `AnimationTree` state machines created with `AnimationNodeStateMachine`. Retrieve with `$AnimationTree.get("parameters/playback")`.
		
		```gdscript
		var state_machine = $AnimationTree.get("parameters/playback")
		state_machine.travel("some_state")
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = AnimationNodeStateMachinePlayback.construct_without_init()
    class_._ptr = constructor(88,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimationNodeStateMachinePlayback.construct_without_init()
    class_._ptr = constructor(88,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimationNodeStateMachinePlaybackWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(88,0, ())


  def generate_wrapper(self):
    return CPPAnimationNodeStateMachinePlaybackWrapper()
  def init_signals(self):
    super().init_signals()
    state_started_name = utils.py_string_to_string_name("state_started")
    self.state_started = signals.BuiltinSignal(self, state_started_name)
    state_finished_name = utils.py_string_to_string_name("state_finished")
    self.state_finished = signals.BuiltinSignal(self, state_finished_name)

  @staticmethod
  def construct_without_init():
    cls = AnimationNodeStateMachinePlayback.__new__(AnimationNodeStateMachinePlayback)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimationNodeStateMachinePlayback'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNodeStateMachinePlayback.construct_without_init()
    cls._ptr = CPPAnimationNodeStateMachinePlaybackWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNodeStateMachinePlayback.construct_without_init()
    cls._ptr = CPPAnimationNodeStateMachinePlaybackWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def travel(self, to_node:'object'   , reset_on_teleport:'bool' =True  ) -> None:
    r'''
				Transitions from the current state to another one, following the shortest path.
				If the path does not connect from the current state, the animation will play after the state teleports.
				If `reset_on_teleport` is `true`, the animation is played from the beginning when the travel cause a teleportation.
			'''

    assert(not to_node is None)
    assert isinstance(to_node, (str, StringName)), 'to_node must be str or StringName'
    assert isinstance(reset_on_teleport, bool), 'reset_on_teleport must be bool'




    assert(isinstance(to_node, (str, StringName)))
    py_stringname_to_node = to_node if isinstance(to_node, StringName) else c_utils.py_string_to_string_name(to_node)


    self._ptr.call_with_return(77,tuple([py_stringname_to_node._ptr, reset_on_teleport]))

  @functools.native_method
  def start(self, node:'object'   , reset:'bool' =True  ) -> None:
    r'''
				Starts playing the given animation.
				If `reset` is `true`, the animation is played from the beginning.
			'''

    assert(not node is None)
    assert isinstance(node, (str, StringName)), 'node must be str or StringName'
    assert isinstance(reset, bool), 'reset must be bool'




    assert(isinstance(node, (str, StringName)))
    py_stringname_node = node if isinstance(node, StringName) else c_utils.py_string_to_string_name(node)


    self._ptr.call_with_return(78,tuple([py_stringname_node._ptr, reset]))

  @functools.native_method
  def next(self) -> None:
    r'''
				If there is a next path by travel or auto advance, immediately transitions from the current state to the next state.
			'''




    self._ptr.call_with_return(79,tuple([]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the currently playing animation.
			'''




    self._ptr.call_with_return(80,tuple([]))

  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r'''
				Returns `true` if an animation is playing.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def get_current_node(self) -> typing.Union['StringName']:
    r'''
				Returns the currently playing animation state.
				**Note:** When using a cross-fade, the current state changes to the next state immediately after the cross-fade begins.
			'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def get_current_play_position(self) -> typing.Union[float]:
    r'''
				Returns the playback position within the current animation state.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def get_current_length(self) -> typing.Union[float]:
    r'''
				Returns the current state length.
				**Note:** It is possible that any `AnimationRootNode` can be nodes as well as animations. This means that there can be multiple animations within a single state. Which animation length has priority depends on the nodes connected inside it. Also, if a transition does not reset, the remaining length at that point will be returned.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def get_fading_from_node(self) -> typing.Union['StringName']:
    r'''
				Returns the starting state of currently fading animation.
			'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def get_travel_path(self) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
				Returns the current travel path as computed internally by the A* algorithm.
			'''




    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return _ret



register_cast_function('AnimationNodeStateMachinePlayback', AnimationNodeStateMachinePlayback.cast)
register_class('AnimationNodeStateMachinePlayback', AnimationNodeStateMachinePlayback)
