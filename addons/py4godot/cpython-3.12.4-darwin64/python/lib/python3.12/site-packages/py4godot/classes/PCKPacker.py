# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPPCKPackerWrapper


class PCKPacker(py4godot_refcounted.RefCounted):
  r'''
		The `PCKPacker` is used to create packages that can be loaded into a running project using `ProjectSettings.load_resource_pack`.
		
		```gdscript
		var packer = PCKPacker.new()
		packer.pck_start("test.pck")
		packer.add_file("res://text.txt", "text.txt")
		packer.flush()
		```
		
		
		The above `PCKPacker` creates package `test.pck`, then adds a file named `text.txt` at the root of the package.
		**Note:** PCK is Godot's own pack file format. To create ZIP archives that can be read by any program, use `ZIPPacker` instead.
	'''

  @staticmethod
  def constructor():
    class_ = PCKPacker.construct_without_init()
    class_._ptr = constructor(564,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PCKPacker.construct_without_init()
    class_._ptr = constructor(564,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPCKPackerWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(564,0, ())


  def generate_wrapper(self):
    return CPPPCKPackerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PCKPacker.__new__(PCKPacker)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PCKPacker'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PCKPacker.construct_without_init()
    cls._ptr = CPPPCKPackerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PCKPacker.construct_without_init()
    cls._ptr = CPPPCKPackerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def pck_start(self, pck_path:'str'   , alignment:'int' =32  , key:'str' ="0000000000000000000000000000000000000000000000000000000000000000"  , encrypt_directory:'bool' =False  ) -> typing.Union[int]:
    r'''
				Creates a new PCK file at the file path `pck_path`. The `.pck` file extension isn't added automatically, so it should be part of `pck_path` (even though it's not required).
			'''
    if key is None:
      key = String.new0()
    if key is None:
      key = String.new0()

    assert(not pck_path is None)
    assert isinstance(pck_path, (str, String)), 'pck_path must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(encrypt_directory, bool), 'encrypt_directory must be bool'




    assert(isinstance(pck_path, (str, String)))
    py_string_pck_path = pck_path if isinstance(pck_path, StringName) else c_utils.py_string_to_string(pck_path)

    assert(isinstance(key, (str, String)))
    py_string_key = key if isinstance(key, StringName) else c_utils.py_string_to_string(key)


    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([py_string_pck_path._ptr, alignment, py_string_key._ptr, encrypt_directory]))
    return _ret


  @functools.native_method
  def add_file(self, target_path:'str'   , source_path:'str'   , encrypt:'bool' =False  ) -> typing.Union[int]:
    r'''
				Adds the `source_path` file to the current PCK package at the `target_path` internal path. The `res://` prefix for `target_path` is optional and stripped internally. File content is immediately written to the PCK.
			'''

    assert(not target_path is None)
    assert isinstance(target_path, (str, String)), 'target_path must be str or String'
    assert(not source_path is None)
    assert isinstance(source_path, (str, String)), 'source_path must be str or String'
    assert isinstance(encrypt, bool), 'encrypt must be bool'




    assert(isinstance(target_path, (str, String)))
    py_string_target_path = target_path if isinstance(target_path, StringName) else c_utils.py_string_to_string(target_path)
    assert(isinstance(source_path, (str, String)))
    py_string_source_path = source_path if isinstance(source_path, StringName) else c_utils.py_string_to_string(source_path)


    _ret:int
    _ret = self._ptr.call_with_return(54,tuple([py_string_target_path._ptr, py_string_source_path._ptr, encrypt]))
    return _ret


  @functools.native_method
  def add_file_removal(self, target_path:'str'   ) -> typing.Union[int]:
    r'''
				Registers a file removal of the `target_path` internal path to the PCK. This is mainly used for patches. If the file at this path has been loaded from a previous PCK, it will be removed. The `res://` prefix for `target_path` is optional and stripped internally.
			'''

    assert(not target_path is None)
    assert isinstance(target_path, (str, String)), 'target_path must be str or String'




    assert(isinstance(target_path, (str, String)))
    py_string_target_path = target_path if isinstance(target_path, StringName) else c_utils.py_string_to_string(target_path)

    _ret:int
    _ret = self._ptr.call_with_return(55,tuple([py_string_target_path._ptr]))
    return _ret


  @functools.native_method
  def flush(self, verbose:'bool' =False  ) -> typing.Union[int]:
    r'''
				Writes the file directory and closes the PCK. If `verbose` is `true`, a list of files added will be printed to the console for easier debugging.
				**Note:** `PCKPacker` will automatically flush when it's freed, which happens when it goes out of scope or when it gets assigned with `null`. In C# the reference must be disposed after use, either with the `using` statement or by calling the `Dispose` method directly.
			'''

    assert isinstance(verbose, bool), 'verbose must be bool'






    _ret:int
    _ret = self._ptr.call_with_return(56,tuple([verbose]))
    return _ret



register_cast_function('PCKPacker', PCKPacker.cast)
register_class('PCKPacker', PCKPacker)
