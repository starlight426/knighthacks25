# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.Gradient as py4godot_gradient 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.Curve as py4godot_curve 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.Node2D as py4godot_node2d 
from py4godot.wrappers.wrappers import CPPCPUParticles2DWrapper

class DrawOrder:
  DRAW_ORDER_INDEX = 0
  DRAW_ORDER_LIFETIME = 1
class Parameter:
  PARAM_INITIAL_LINEAR_VELOCITY = 0
  PARAM_ANGULAR_VELOCITY = 1
  PARAM_ORBIT_VELOCITY = 2
  PARAM_LINEAR_ACCEL = 3
  PARAM_RADIAL_ACCEL = 4
  PARAM_TANGENTIAL_ACCEL = 5
  PARAM_DAMPING = 6
  PARAM_ANGLE = 7
  PARAM_SCALE = 8
  PARAM_HUE_VARIATION = 9
  PARAM_ANIM_SPEED = 10
  PARAM_ANIM_OFFSET = 11
  PARAM_MAX = 12
class ParticleFlags:
  PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY = 0
  PARTICLE_FLAG_ROTATE_Y = 1
  PARTICLE_FLAG_DISABLE_Z = 2
  PARTICLE_FLAG_MAX = 3
class EmissionShape:
  EMISSION_SHAPE_POINT = 0
  EMISSION_SHAPE_SPHERE = 1
  EMISSION_SHAPE_SPHERE_SURFACE = 2
  EMISSION_SHAPE_RECTANGLE = 3
  EMISSION_SHAPE_POINTS = 4
  EMISSION_SHAPE_DIRECTED_POINTS = 5
  EMISSION_SHAPE_MAX = 6


class CPUParticles2D(py4godot_node2d.Node2D):
  r'''
		CPU-based 2D particle node used to create a variety of particle systems and effects.
		See also `GPUParticles2D`, which provides the same functionality with hardware acceleration, but may not run on older devices.
	'''

  @staticmethod
  def constructor():
    class_ = CPUParticles2D.construct_without_init()
    class_._ptr = constructor(176,0, ())
    return class_
  @staticmethod
  def new():
    class_ = CPUParticles2D.construct_without_init()
    class_._ptr = constructor(176,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCPUParticles2DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(176,0, ())


  def generate_wrapper(self):
    return CPPCPUParticles2DWrapper()
  def init_signals(self):
    super().init_signals()
    finished_name = utils.py_string_to_string_name("finished")
    self.finished = signals.BuiltinSignal(self, finished_name)

  @staticmethod
  def construct_without_init():
    cls = CPUParticles2D.__new__(CPUParticles2D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'CPUParticles2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = CPUParticles2D.construct_without_init()
    cls._ptr = CPPCPUParticles2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = CPUParticles2D.construct_without_init()
    cls._ptr = CPPCPUParticles2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def emitting(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_emitting()
    return _ret
  @emitting.setter
  def emitting(self,  value:'bool'):
    self.set_emitting(value)
  @property
  def amount(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_amount()
    return _ret
  @amount.setter
  def amount(self,  value:'int'):
    self.set_amount(value)
  @property
  def texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture()
    return _ret
  @texture.setter
  def texture(self,  value:'py4godot_object.Object'):
    self.set_texture(value)
  @property
  def lifetime(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_lifetime()
    return _ret
  @lifetime.setter
  def lifetime(self,  value:'float'):
    self.set_lifetime(value)
  @property
  def one_shot(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_one_shot()
    return _ret
  @one_shot.setter
  def one_shot(self,  value:'bool'):
    self.set_one_shot(value)
  @property
  def preprocess(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pre_process_time()
    return _ret
  @preprocess.setter
  def preprocess(self,  value:'float'):
    self.set_pre_process_time(value)
  @property
  def speed_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_speed_scale()
    return _ret
  @speed_scale.setter
  def speed_scale(self,  value:'float'):
    self.set_speed_scale(value)
  @property
  def explosiveness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_explosiveness_ratio()
    return _ret
  @explosiveness.setter
  def explosiveness(self,  value:'float'):
    self.set_explosiveness_ratio(value)
  @property
  def randomness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_randomness_ratio()
    return _ret
  @randomness.setter
  def randomness(self,  value:'float'):
    self.set_randomness_ratio(value)
  @property
  def use_fixed_seed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_fixed_seed()
    return _ret
  @use_fixed_seed.setter
  def use_fixed_seed(self,  value:'bool'):
    self.set_use_fixed_seed(value)
  @property
  def seed(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_seed()
    return _ret
  @seed.setter
  def seed(self,  value:'int'):
    self.set_seed(value)
  @property
  def lifetime_randomness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_lifetime_randomness()
    return _ret
  @lifetime_randomness.setter
  def lifetime_randomness(self,  value:'float'):
    self.set_lifetime_randomness(value)
  @property
  def fixed_fps(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_fixed_fps()
    return _ret
  @fixed_fps.setter
  def fixed_fps(self,  value:'int'):
    self.set_fixed_fps(value)
  @property
  def fract_delta(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_fractional_delta()
    return _ret
  @fract_delta.setter
  def fract_delta(self,  value:'bool'):
    self.set_fractional_delta(value)
  @property
  def local_coords(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_local_coordinates()
    return _ret
  @local_coords.setter
  def local_coords(self,  value:'bool'):
    self.set_use_local_coordinates(value)
  @property
  def draw_order(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_draw_order()
    return _ret
  @draw_order.setter
  def draw_order(self,  value:'int'):
    self.set_draw_order(value)
  @property
  def emission_shape(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_emission_shape()
    return _ret
  @emission_shape.setter
  def emission_shape(self,  value:'int'):
    self.set_emission_shape(value)
  @property
  def emission_sphere_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_sphere_radius()
    return _ret
  @emission_sphere_radius.setter
  def emission_sphere_radius(self,  value:'float'):
    self.set_emission_sphere_radius(value)
  @property
  def emission_rect_extents(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_emission_rect_extents()
    return _ret
  @emission_rect_extents.setter
  def emission_rect_extents(self,  value:'Vector2'):
    self.set_emission_rect_extents(value)
  @property
  def emission_points(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_emission_points()
    return _ret
  @emission_points.setter
  def emission_points(self,  value:'PackedVector2Array'):
    self.set_emission_points(value)
  @property
  def emission_normals(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_emission_normals()
    return _ret
  @emission_normals.setter
  def emission_normals(self,  value:'PackedVector2Array'):
    self.set_emission_normals(value)
  @property
  def emission_colors(self) -> typing.Union['PackedColorArray']:
    r''''''
    _ret = self. get_emission_colors()
    return _ret
  @emission_colors.setter
  def emission_colors(self,  value:'PackedColorArray'):
    self.set_emission_colors(value)
  @property
  def particle_flag_align_y(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_particle_flag(0)
    return _ret
  @particle_flag_align_y.setter
  def particle_flag_align_y(self,  value:'bool'):
    self.set_particle_flag(value)
  @property
  def direction(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_direction()
    return _ret
  @direction.setter
  def direction(self,  value:'Vector2'):
    self.set_direction(value)
  @property
  def spread(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_spread()
    return _ret
  @spread.setter
  def spread(self,  value:'float'):
    self.set_spread(value)
  @property
  def gravity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_gravity()
    return _ret
  @gravity.setter
  def gravity(self,  value:'Vector2'):
    self.set_gravity(value)
  @property
  def initial_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(0)
    return _ret
  @initial_velocity_min.setter
  def initial_velocity_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def initial_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(0)
    return _ret
  @initial_velocity_max.setter
  def initial_velocity_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def angular_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(1)
    return _ret
  @angular_velocity_min.setter
  def angular_velocity_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def angular_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(1)
    return _ret
  @angular_velocity_max.setter
  def angular_velocity_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def angular_velocity_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(1)
    return _ret
  @angular_velocity_curve.setter
  def angular_velocity_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def orbit_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(2)
    return _ret
  @orbit_velocity_min.setter
  def orbit_velocity_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def orbit_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(2)
    return _ret
  @orbit_velocity_max.setter
  def orbit_velocity_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def orbit_velocity_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(2)
    return _ret
  @orbit_velocity_curve.setter
  def orbit_velocity_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def linear_accel_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(3)
    return _ret
  @linear_accel_min.setter
  def linear_accel_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def linear_accel_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(3)
    return _ret
  @linear_accel_max.setter
  def linear_accel_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def linear_accel_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(3)
    return _ret
  @linear_accel_curve.setter
  def linear_accel_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def radial_accel_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(4)
    return _ret
  @radial_accel_min.setter
  def radial_accel_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def radial_accel_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(4)
    return _ret
  @radial_accel_max.setter
  def radial_accel_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def radial_accel_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(4)
    return _ret
  @radial_accel_curve.setter
  def radial_accel_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def tangential_accel_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(5)
    return _ret
  @tangential_accel_min.setter
  def tangential_accel_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def tangential_accel_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(5)
    return _ret
  @tangential_accel_max.setter
  def tangential_accel_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def tangential_accel_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(5)
    return _ret
  @tangential_accel_curve.setter
  def tangential_accel_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def damping_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(6)
    return _ret
  @damping_min.setter
  def damping_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def damping_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(6)
    return _ret
  @damping_max.setter
  def damping_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def damping_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(6)
    return _ret
  @damping_curve.setter
  def damping_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def angle_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(7)
    return _ret
  @angle_min.setter
  def angle_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def angle_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(7)
    return _ret
  @angle_max.setter
  def angle_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def angle_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(7)
    return _ret
  @angle_curve.setter
  def angle_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def scale_amount_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(8)
    return _ret
  @scale_amount_min.setter
  def scale_amount_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def scale_amount_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(8)
    return _ret
  @scale_amount_max.setter
  def scale_amount_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def scale_amount_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(8)
    return _ret
  @scale_amount_curve.setter
  def scale_amount_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def split_scale(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_split_scale()
    return _ret
  @split_scale.setter
  def split_scale(self,  value:'bool'):
    self.set_split_scale(value)
  @property
  def scale_curve_x(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_scale_curve_x()
    return _ret
  @scale_curve_x.setter
  def scale_curve_x(self,  value:'py4godot_object.Object'):
    self.set_scale_curve_x(value)
  @property
  def scale_curve_y(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_scale_curve_y()
    return _ret
  @scale_curve_y.setter
  def scale_curve_y(self,  value:'py4godot_object.Object'):
    self.set_scale_curve_y(value)
  @property
  def color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_color()
    return _ret
  @color.setter
  def color(self,  value:'Color'):
    self.set_color(value)
  @property
  def color_ramp(self) -> typing.Union['py4godot_gradient.Gradient']:
    r''''''
    _ret = self. get_color_ramp()
    return _ret
  @color_ramp.setter
  def color_ramp(self,  value:'py4godot_object.Object'):
    self.set_color_ramp(value)
  @property
  def color_initial_ramp(self) -> typing.Union['py4godot_gradient.Gradient']:
    r''''''
    _ret = self. get_color_initial_ramp()
    return _ret
  @color_initial_ramp.setter
  def color_initial_ramp(self,  value:'py4godot_object.Object'):
    self.set_color_initial_ramp(value)
  @property
  def hue_variation_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(9)
    return _ret
  @hue_variation_min.setter
  def hue_variation_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def hue_variation_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(9)
    return _ret
  @hue_variation_max.setter
  def hue_variation_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def hue_variation_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(9)
    return _ret
  @hue_variation_curve.setter
  def hue_variation_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def anim_speed_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(10)
    return _ret
  @anim_speed_min.setter
  def anim_speed_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def anim_speed_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(10)
    return _ret
  @anim_speed_max.setter
  def anim_speed_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def anim_speed_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(10)
    return _ret
  @anim_speed_curve.setter
  def anim_speed_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @property
  def anim_offset_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(11)
    return _ret
  @anim_offset_min.setter
  def anim_offset_min(self,  value:'float'):
    self.set_param_min(value)
  @property
  def anim_offset_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(11)
    return _ret
  @anim_offset_max.setter
  def anim_offset_max(self,  value:'float'):
    self.set_param_max(value)
  @property
  def anim_offset_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_param_curve(11)
    return _ret
  @anim_offset_curve.setter
  def anim_offset_curve(self,  value:'py4godot_object.Object'):
    self.set_param_curve(value)
  @functools.native_method
  def set_emitting(self, emitting:'bool'   ) -> None:
    r''''''

    assert isinstance(emitting, bool), 'emitting must be bool'

    self.py__emitting = emitting






    self._ptr.call_with_return(303,tuple([emitting]))

  @functools.native_method
  def set_amount(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'

    self.py__amount = amount






    self._ptr.call_with_return(304,tuple([amount]))

  @functools.native_method
  def set_lifetime(self, secs:'float'   ) -> None:
    r''''''

    assert isinstance(secs, (int, float)), 'secs must be int or float'

    self.py__lifetime = secs






    self._ptr.call_with_return(305,tuple([secs]))

  @functools.native_method
  def set_one_shot(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__one_shot = enable






    self._ptr.call_with_return(306,tuple([enable]))

  @functools.native_method
  def set_pre_process_time(self, secs:'float'   ) -> None:
    r''''''

    assert isinstance(secs, (int, float)), 'secs must be int or float'

    self.py__preprocess = secs






    self._ptr.call_with_return(307,tuple([secs]))

  @functools.native_method
  def set_explosiveness_ratio(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'

    self.py__explosiveness = ratio






    self._ptr.call_with_return(308,tuple([ratio]))

  @functools.native_method
  def set_randomness_ratio(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'

    self.py__randomness = ratio






    self._ptr.call_with_return(309,tuple([ratio]))

  @functools.native_method
  def set_lifetime_randomness(self, random:'float'   ) -> None:
    r''''''

    assert isinstance(random, (int, float)), 'random must be int or float'

    self.py__lifetime_randomness = random






    self._ptr.call_with_return(310,tuple([random]))

  @functools.native_method
  def set_use_local_coordinates(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__local_coords = enable






    self._ptr.call_with_return(311,tuple([enable]))

  @functools.native_method
  def set_fixed_fps(self, fps:'int'   ) -> None:
    r''''''

    assert isinstance(fps, (int, float)), 'fps must be int or float'

    self.py__fixed_fps = fps






    self._ptr.call_with_return(312,tuple([fps]))

  @functools.native_method
  def set_fractional_delta(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__fract_delta = enable






    self._ptr.call_with_return(313,tuple([enable]))

  @functools.native_method
  def set_speed_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'

    self.py__speed_scale = scale






    self._ptr.call_with_return(314,tuple([scale]))

  @functools.native_method
  def request_particles_process(self, process_time:'float'   ) -> None:
    r'''
				Requests the particles to process for extra process time during a single frame.
				Useful for particle playback, if used in combination with `use_fixed_seed` or by calling `restart` with parameter `keep_seed` set to `true`.
			'''

    assert isinstance(process_time, (int, float)), 'process_time must be int or float'






    self._ptr.call_with_return(315,tuple([process_time]))

  @functools.native_method
  def is_emitting(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(316,tuple([]))

    return _ret


  @functools.native_method
  def get_amount(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def get_lifetime(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(318,tuple([]))

    return _ret


  @functools.native_method
  def get_one_shot(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def get_pre_process_time(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(320,tuple([]))

    return _ret


  @functools.native_method
  def get_explosiveness_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def get_randomness_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([]))

    return _ret


  @functools.native_method
  def get_lifetime_randomness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(323,tuple([]))

    return _ret


  @functools.native_method
  def get_use_local_coordinates(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(324,tuple([]))

    return _ret


  @functools.native_method
  def get_fixed_fps(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([]))

    return _ret


  @functools.native_method
  def get_fractional_delta(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(326,tuple([]))

    return _ret


  @functools.native_method
  def get_speed_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(327,tuple([]))

    return _ret


  @functools.native_method
  def set_use_fixed_seed(self, use_fixed_seed:'bool'   ) -> None:
    r''''''

    assert isinstance(use_fixed_seed, bool), 'use_fixed_seed must be bool'

    self.py__use_fixed_seed = use_fixed_seed






    self._ptr.call_with_return(328,tuple([use_fixed_seed]))

  @functools.native_method
  def get_use_fixed_seed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([]))

    return _ret


  @functools.native_method
  def set_seed(self, seed:'int'   ) -> None:
    r''''''

    assert isinstance(seed, (int, float)), 'seed must be int or float'

    self.py__seed = seed






    self._ptr.call_with_return(330,tuple([seed]))

  @functools.native_method
  def get_seed(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(331,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_order(self, order:'int'  ) -> None:
    r''''''

    assert isinstance(order, (int, float)), 'order must be int or float'

    self.py__draw_order = order






    self._ptr.call_with_return(332,tuple([order]))

  @functools.native_method
  def get_draw_order(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(333,tuple([]))

    return _ret


  @functools.native_method
  def set_texture(self, texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'

    self.py__texture = texture






    self._ptr.call_with_return(334,tuple([texture._ptr]))

  @functools.native_method
  def get_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(335,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def restart(self, keep_seed:'bool' =False  ) -> None:
    r'''
				Restarts the particle emitter.
				If `keep_seed` is `true`, the current random seed will be preserved. Useful for seeking and playback.
			'''

    assert isinstance(keep_seed, bool), 'keep_seed must be bool'






    self._ptr.call_with_return(336,tuple([keep_seed]))

  @functools.native_method
  def set_direction(self, direction:'Vector2'   ) -> None:
    r''''''

    assert(not direction is None)
    assert isinstance(direction, Vector2), 'direction must be Vector2'

    self.py__direction = direction






    self._ptr.call_with_return(337,tuple([direction._ptr]))

  @functools.native_method
  def get_direction(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(338,tuple([]))

    return _ret


  @functools.native_method
  def set_spread(self, spread:'float'   ) -> None:
    r''''''

    assert isinstance(spread, (int, float)), 'spread must be int or float'

    self.py__spread = spread






    self._ptr.call_with_return(339,tuple([spread]))

  @functools.native_method
  def get_spread(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(340,tuple([]))

    return _ret


  @functools.native_method
  def set_param_min(self, param:'int'  , value:'float'   ) -> None:
    r'''
				Sets the minimum value for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__initial_velocity_min = param







    self._ptr.call_with_return(341,tuple([param, value]))

  @functools.native_method
  def get_param_min(self, param:'int'  ) -> typing.Union[float]:
    r'''
				Returns the minimum value range for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(342,tuple([param]))

    return _ret


  @functools.native_method
  def set_param_max(self, param:'int'  , value:'float'   ) -> None:
    r'''
				Sets the maximum value for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__initial_velocity_max = param







    self._ptr.call_with_return(343,tuple([param, value]))

  @functools.native_method
  def get_param_max(self, param:'int'  ) -> typing.Union[float]:
    r'''
				Returns the maximum value range for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(344,tuple([param]))

    return _ret


  @functools.native_method
  def set_param_curve(self, param:'int'  , curve:'py4godot_curve.Curve'   ) -> None:
    r'''
				Sets the `Curve` of the parameter specified by `enum Parameter`. Should be a unit `Curve`.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'

    self.py__angular_velocity_curve = param







    self._ptr.call_with_return(345,tuple([param, curve._ptr]))

  @functools.native_method
  def get_param_curve(self, param:'int'  ) -> typing.Union['py4godot_curve.Curve']:
    r'''
				Returns the `Curve` of the parameter specified by `enum Parameter`.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(346,tuple([param]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__color = color






    self._ptr.call_with_return(347,tuple([color._ptr]))

  @functools.native_method
  def get_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(348,tuple([]))

    return _ret


  @functools.native_method
  def set_color_ramp(self, ramp:'py4godot_gradient.Gradient'   ) -> None:
    r''''''

    assert(not ramp is None)
    assert isinstance(ramp, get_class('Gradient')), 'ramp must be Gradient'

    self.py__color_ramp = ramp






    self._ptr.call_with_return(349,tuple([ramp._ptr]))

  @functools.native_method
  def get_color_ramp(self) -> typing.Union['py4godot_gradient.Gradient']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Gradient
    _ret._ptr = self._ptr.call_with_return(350,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_color_initial_ramp(self, ramp:'py4godot_gradient.Gradient'   ) -> None:
    r''''''

    assert(not ramp is None)
    assert isinstance(ramp, get_class('Gradient')), 'ramp must be Gradient'

    self.py__color_initial_ramp = ramp






    self._ptr.call_with_return(351,tuple([ramp._ptr]))

  @functools.native_method
  def get_color_initial_ramp(self) -> typing.Union['py4godot_gradient.Gradient']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Gradient
    _ret._ptr = self._ptr.call_with_return(352,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_particle_flag(self, particle_flag:'int'  , enable:'bool'   ) -> None:
    r'''
				Enables or disables the given particle flag.
			'''

    assert isinstance(particle_flag, (int, float)), 'particle_flag must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'

    self.py__particle_flag_align_y = particle_flag







    self._ptr.call_with_return(353,tuple([particle_flag, enable]))

  @functools.native_method
  def get_particle_flag(self, particle_flag:'int'  ) -> typing.Union[bool]:
    r'''
				Returns the enabled state of the given particle flag.
			'''

    assert isinstance(particle_flag, (int, float)), 'particle_flag must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(354,tuple([particle_flag]))

    return _ret


  @functools.native_method
  def set_emission_shape(self, shape:'int'  ) -> None:
    r''''''

    assert isinstance(shape, (int, float)), 'shape must be int or float'

    self.py__emission_shape = shape






    self._ptr.call_with_return(355,tuple([shape]))

  @functools.native_method
  def get_emission_shape(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(356,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_sphere_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'

    self.py__emission_sphere_radius = radius






    self._ptr.call_with_return(357,tuple([radius]))

  @functools.native_method
  def get_emission_sphere_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(358,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_rect_extents(self, extents:'Vector2'   ) -> None:
    r''''''

    assert(not extents is None)
    assert isinstance(extents, Vector2), 'extents must be Vector2'

    self.py__emission_rect_extents = extents






    self._ptr.call_with_return(359,tuple([extents._ptr]))

  @functools.native_method
  def get_emission_rect_extents(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(360,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_points(self, array:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedVector2Array), 'array must be PackedVector2Array'

    self.py__emission_points = array






    self._ptr.call_with_return(361,tuple([array._ptr]))

  @functools.native_method
  def get_emission_points(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(362,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_normals(self, array:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedVector2Array), 'array must be PackedVector2Array'

    self.py__emission_normals = array






    self._ptr.call_with_return(363,tuple([array._ptr]))

  @functools.native_method
  def get_emission_normals(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(364,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_colors(self, array:'PackedColorArray'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedColorArray), 'array must be PackedColorArray'

    self.py__emission_colors = array






    self._ptr.call_with_return(365,tuple([array._ptr]))

  @functools.native_method
  def get_emission_colors(self) -> typing.Union['PackedColorArray']:
    r''''''




    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(366,tuple([]))

    return _ret


  @functools.native_method
  def get_gravity(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(367,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity(self, accel_vec:'Vector2'   ) -> None:
    r''''''

    assert(not accel_vec is None)
    assert isinstance(accel_vec, Vector2), 'accel_vec must be Vector2'

    self.py__gravity = accel_vec






    self._ptr.call_with_return(368,tuple([accel_vec._ptr]))

  @functools.native_method
  def get_split_scale(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(369,tuple([]))

    return _ret


  @functools.native_method
  def set_split_scale(self, split_scale:'bool'   ) -> None:
    r''''''

    assert isinstance(split_scale, bool), 'split_scale must be bool'

    self.py__split_scale = split_scale






    self._ptr.call_with_return(370,tuple([split_scale]))

  @functools.native_method
  def get_scale_curve_x(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(371,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_scale_curve_x(self, scale_curve:'py4godot_curve.Curve'   ) -> None:
    r''''''

    assert(not scale_curve is None)
    assert isinstance(scale_curve, get_class('Curve')), 'scale_curve must be Curve'

    self.py__scale_curve_x = scale_curve






    self._ptr.call_with_return(372,tuple([scale_curve._ptr]))

  @functools.native_method
  def get_scale_curve_y(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(373,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_scale_curve_y(self, scale_curve:'py4godot_curve.Curve'   ) -> None:
    r''''''

    assert(not scale_curve is None)
    assert isinstance(scale_curve, get_class('Curve')), 'scale_curve must be Curve'

    self.py__scale_curve_y = scale_curve






    self._ptr.call_with_return(374,tuple([scale_curve._ptr]))

  @functools.native_method
  def convert_from_particles(self, particles:'py4godot_node.Node'   ) -> None:
    r'''
				Sets this node's properties to match a given `GPUParticles2D` node with an assigned `ParticleProcessMaterial`.
			'''

    assert(not particles is None)
    assert isinstance(particles, get_class('Node')), 'particles must be Node'






    self._ptr.call_with_return(375,tuple([particles._ptr]))


register_cast_function('CPUParticles2D', CPUParticles2D.cast)
register_class('CPUParticles2D', CPUParticles2D)
