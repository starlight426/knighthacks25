# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PhysicsBody3DTypedArray as py4godot_physicsbody3dtypedarray 
  import py4godot.classes.Node as py4godot_node 
import py4godot.classes.PhysicsBody3DTypedArray as py4godot_physicsbody3dtypedarray 
import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
from py4godot.wrappers.wrappers import CPPSoftBody3DWrapper

class DisableMode:
  DISABLE_MODE_REMOVE = 0
  DISABLE_MODE_KEEP_ACTIVE = 1


class SoftBody3D(py4godot_meshinstance3d.MeshInstance3D):
  r'''
		A deformable 3D physics mesh. Used to create elastic or deformable objects such as cloth, rubber, or other flexible materials.
		Additionally, `SoftBody3D` is subject to wind forces defined in `Area3D` (see `Area3D.wind_source_path`, `Area3D.wind_force_magnitude`, and `Area3D.wind_attenuation_factor`).
		**Note:** It's recommended to use Jolt Physics when using `SoftBody3D` instead of the default GodotPhysics3D, as Jolt Physics' soft body implementation is faster and more reliable. You can switch the physics engine using the `ProjectSettings.physics/3d/physics_engine` project setting.
	'''

  @staticmethod
  def constructor():
    class_ = SoftBody3D.construct_without_init()
    class_._ptr = constructor(766,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SoftBody3D.construct_without_init()
    class_._ptr = constructor(766,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSoftBody3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(766,0, ())


  def generate_wrapper(self):
    return CPPSoftBody3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SoftBody3D.__new__(SoftBody3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SoftBody3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SoftBody3D.construct_without_init()
    cls._ptr = CPPSoftBody3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SoftBody3D.construct_without_init()
    cls._ptr = CPPSoftBody3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def collision_layer(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_collision_layer()
    return _ret
  @collision_layer.setter
  def collision_layer(self,  value:'int'):
    self.set_collision_layer(value)
  @property
  def collision_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_collision_mask()
    return _ret
  @collision_mask.setter
  def collision_mask(self,  value:'int'):
    self.set_collision_mask(value)
  @property
  def parent_collision_ignore(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_parent_collision_ignore()
    return _ret
  @parent_collision_ignore.setter
  def parent_collision_ignore(self,  value:'object'):
    self.set_parent_collision_ignore(value)
  @property
  def simulation_precision(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_simulation_precision()
    return _ret
  @simulation_precision.setter
  def simulation_precision(self,  value:'int'):
    self.set_simulation_precision(value)
  @property
  def total_mass(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_total_mass()
    return _ret
  @total_mass.setter
  def total_mass(self,  value:'float'):
    self.set_total_mass(value)
  @property
  def linear_stiffness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_linear_stiffness()
    return _ret
  @linear_stiffness.setter
  def linear_stiffness(self,  value:'float'):
    self.set_linear_stiffness(value)
  @property
  def shrinking_factor(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_shrinking_factor()
    return _ret
  @shrinking_factor.setter
  def shrinking_factor(self,  value:'float'):
    self.set_shrinking_factor(value)
  @property
  def pressure_coefficient(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pressure_coefficient()
    return _ret
  @pressure_coefficient.setter
  def pressure_coefficient(self,  value:'float'):
    self.set_pressure_coefficient(value)
  @property
  def damping_coefficient(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_damping_coefficient()
    return _ret
  @damping_coefficient.setter
  def damping_coefficient(self,  value:'float'):
    self.set_damping_coefficient(value)
  @property
  def drag_coefficient(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_drag_coefficient()
    return _ret
  @drag_coefficient.setter
  def drag_coefficient(self,  value:'float'):
    self.set_drag_coefficient(value)
  @property
  def ray_pickable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ray_pickable()
    return _ret
  @ray_pickable.setter
  def ray_pickable(self,  value:'bool'):
    self.set_ray_pickable(value)
  @property
  def disable_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_disable_mode()
    return _ret
  @disable_mode.setter
  def disable_mode(self,  value:'int'):
    self.set_disable_mode(value)
  @functools.native_method
  def get_physics_rid(self) -> typing.Union['RID']:
    r'''
				Returns the internal `RID` used by the `PhysicsServer3D` for this body.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(319,tuple([]))
    return _ret


  @functools.native_method
  def set_collision_mask(self, collision_mask:'int'   ) -> None:
    r''''''

    assert isinstance(collision_mask, (int, float)), 'collision_mask must be int or float'

    self.py__collision_mask = collision_mask






    self._ptr.call_with_return(320,tuple([collision_mask]))

  @functools.native_method
  def get_collision_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_layer(self, collision_layer:'int'   ) -> None:
    r''''''

    assert isinstance(collision_layer, (int, float)), 'collision_layer must be int or float'

    self.py__collision_layer = collision_layer






    self._ptr.call_with_return(322,tuple([collision_layer]))

  @functools.native_method
  def get_collision_layer(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(323,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_mask_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `collision_mask`, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'







    self._ptr.call_with_return(324,tuple([layer_number, value]))

  @functools.native_method
  def get_collision_mask_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `collision_mask` is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_collision_layer_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `collision_layer`, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'







    self._ptr.call_with_return(326,tuple([layer_number, value]))

  @functools.native_method
  def get_collision_layer_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `collision_layer` is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(327,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_parent_collision_ignore(self, parent_collision_ignore:'object'   ) -> None:
    r''''''

    assert(not parent_collision_ignore is None)
    assert isinstance(parent_collision_ignore, (str, NodePath)), 'parent_collision_ignore must be str or NodePath'

    self.py__parent_collision_ignore = parent_collision_ignore



    assert(isinstance(parent_collision_ignore, (str, NodePath)))
    py_nodepath_parent_collision_ignore = parent_collision_ignore if isinstance(parent_collision_ignore,NodePath) else NodePath.new2(parent_collision_ignore)


    self._ptr.call_with_return(328,tuple([py_nodepath_parent_collision_ignore._ptr]))

  @functools.native_method
  def get_parent_collision_ignore(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(329,tuple([]))

    return _ret


  @functools.native_method
  def set_disable_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__disable_mode = mode






    self._ptr.call_with_return(330,tuple([mode]))

  @functools.native_method
  def get_disable_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(331,tuple([]))

    return _ret


  @functools.native_method
  def get_collision_exceptions(self) -> typing.Union['py4godot_physicsbody3dtypedarray.PhysicsBody3DTypedArray']:
    r'''
				Returns an array of nodes that were added as collision exceptions for this body.
			'''




    _ret = py4godot_physicsbody3dtypedarray.PhysicsBody3DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(332,tuple([]))
    return _ret


  @functools.native_method
  def add_collision_exception_with(self, body:'py4godot_node.Node'   ) -> None:
    r'''
				Adds a body to the list of bodies that this body can't collide with.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'






    self._ptr.call_with_return(333,tuple([body._ptr]))

  @functools.native_method
  def remove_collision_exception_with(self, body:'py4godot_node.Node'   ) -> None:
    r'''
				Removes a body from the list of bodies that this body can't collide with.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'






    self._ptr.call_with_return(334,tuple([body._ptr]))

  @functools.native_method
  def set_simulation_precision(self, simulation_precision:'int'   ) -> None:
    r''''''

    assert isinstance(simulation_precision, (int, float)), 'simulation_precision must be int or float'

    self.py__simulation_precision = simulation_precision






    self._ptr.call_with_return(335,tuple([simulation_precision]))

  @functools.native_method
  def get_simulation_precision(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(336,tuple([]))

    return _ret


  @functools.native_method
  def set_total_mass(self, mass:'float'   ) -> None:
    r''''''

    assert isinstance(mass, (int, float)), 'mass must be int or float'

    self.py__total_mass = mass






    self._ptr.call_with_return(337,tuple([mass]))

  @functools.native_method
  def get_total_mass(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(338,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_stiffness(self, linear_stiffness:'float'   ) -> None:
    r''''''

    assert isinstance(linear_stiffness, (int, float)), 'linear_stiffness must be int or float'

    self.py__linear_stiffness = linear_stiffness






    self._ptr.call_with_return(339,tuple([linear_stiffness]))

  @functools.native_method
  def get_linear_stiffness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(340,tuple([]))

    return _ret


  @functools.native_method
  def set_shrinking_factor(self, shrinking_factor:'float'   ) -> None:
    r''''''

    assert isinstance(shrinking_factor, (int, float)), 'shrinking_factor must be int or float'

    self.py__shrinking_factor = shrinking_factor






    self._ptr.call_with_return(341,tuple([shrinking_factor]))

  @functools.native_method
  def get_shrinking_factor(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(342,tuple([]))

    return _ret


  @functools.native_method
  def set_pressure_coefficient(self, pressure_coefficient:'float'   ) -> None:
    r''''''

    assert isinstance(pressure_coefficient, (int, float)), 'pressure_coefficient must be int or float'

    self.py__pressure_coefficient = pressure_coefficient






    self._ptr.call_with_return(343,tuple([pressure_coefficient]))

  @functools.native_method
  def get_pressure_coefficient(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(344,tuple([]))

    return _ret


  @functools.native_method
  def set_damping_coefficient(self, damping_coefficient:'float'   ) -> None:
    r''''''

    assert isinstance(damping_coefficient, (int, float)), 'damping_coefficient must be int or float'

    self.py__damping_coefficient = damping_coefficient






    self._ptr.call_with_return(345,tuple([damping_coefficient]))

  @functools.native_method
  def get_damping_coefficient(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(346,tuple([]))

    return _ret


  @functools.native_method
  def set_drag_coefficient(self, drag_coefficient:'float'   ) -> None:
    r''''''

    assert isinstance(drag_coefficient, (int, float)), 'drag_coefficient must be int or float'

    self.py__drag_coefficient = drag_coefficient






    self._ptr.call_with_return(347,tuple([drag_coefficient]))

  @functools.native_method
  def get_drag_coefficient(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(348,tuple([]))

    return _ret


  @functools.native_method
  def get_point_transform(self, point_index:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns local translation of a vertex in the surface array.
			'''

    assert isinstance(point_index, (int, float)), 'point_index must be int or float'






    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(349,tuple([point_index]))
    return _ret


  @functools.native_method
  def apply_impulse(self, point_index:'int'   , impulse:'Vector3'   ) -> None:
    r'''
				Applies an impulse to a point.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
			'''

    assert isinstance(point_index, (int, float)), 'point_index must be int or float'
    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'







    self._ptr.call_with_return(350,tuple([point_index, impulse._ptr]))

  @functools.native_method
  def apply_force(self, point_index:'int'   , force:'Vector3'   ) -> None:
    r'''
				Applies a force to a point. A force is time dependent and meant to be applied every physics update.
			'''

    assert isinstance(point_index, (int, float)), 'point_index must be int or float'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'







    self._ptr.call_with_return(351,tuple([point_index, force._ptr]))

  @functools.native_method
  def apply_central_impulse(self, impulse:'Vector3'   ) -> None:
    r'''
				Distributes and applies an impulse to all points.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
			'''

    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'






    self._ptr.call_with_return(352,tuple([impulse._ptr]))

  @functools.native_method
  def apply_central_force(self, force:'Vector3'   ) -> None:
    r'''
				Distributes and applies a force to all points. A force is time dependent and meant to be applied every physics update.
			'''

    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'






    self._ptr.call_with_return(353,tuple([force._ptr]))

  @functools.native_method
  def set_point_pinned(self, point_index:'int'   , pinned:'bool'   , attachment_path:'object' = None  , insert_at:'int' =-1  ) -> None:
    r'''
				Sets the pinned state of a surface vertex. When set to `true`, the optional `attachment_path` can define a `Node3D` the pinned vertex will be attached to.
			'''
    if attachment_path is None:
      attachment_path = NodePath.new0()
    if attachment_path is None:
      attachment_path = NodePath.new0()

    assert isinstance(point_index, (int, float)), 'point_index must be int or float'
    assert isinstance(pinned, bool), 'pinned must be bool'
    assert isinstance(insert_at, (int, float)), 'insert_at must be int or float'






    assert(isinstance(attachment_path, (str, NodePath)))
    py_nodepath_attachment_path = attachment_path if isinstance(attachment_path,NodePath) else NodePath.new2(attachment_path)


    self._ptr.call_with_return(354,tuple([point_index, pinned, py_nodepath_attachment_path._ptr, insert_at]))

  @functools.native_method
  def is_point_pinned(self, point_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if vertex is set to pinned.
			'''

    assert isinstance(point_index, (int, float)), 'point_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(355,tuple([point_index]))
    return _ret


  @functools.native_method
  def set_ray_pickable(self, ray_pickable:'bool'   ) -> None:
    r''''''

    assert isinstance(ray_pickable, bool), 'ray_pickable must be bool'

    self.py__ray_pickable = ray_pickable






    self._ptr.call_with_return(356,tuple([ray_pickable]))

  @functools.native_method
  def is_ray_pickable(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(357,tuple([]))

    return _ret



register_cast_function('SoftBody3D', SoftBody3D.cast)
register_class('SoftBody3D', SoftBody3D)
