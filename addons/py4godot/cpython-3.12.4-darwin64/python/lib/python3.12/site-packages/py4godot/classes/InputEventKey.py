# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.InputEventWithModifiers as py4godot_inputeventwithmodifiers 
from py4godot.wrappers.wrappers import CPPInputEventKeyWrapper


class InputEventKey(py4godot_inputeventwithmodifiers.InputEventWithModifiers):
  r'''
		An input event for keys on a keyboard. Supports key presses, key releases and `echo` events. It can also be received in `Node._unhandled_key_input`.
		**Note:** Events received from the keyboard usually have all properties set. Event mappings should have only one of the `keycode`, `physical_keycode` or `unicode` set.
		When events are compared, properties are checked in the following priority - `keycode`, `physical_keycode` and `unicode`. Events with the first matching value will be considered equal.
	'''

  @staticmethod
  def constructor():
    class_ = InputEventKey.construct_without_init()
    class_._ptr = constructor(419,0, ())
    return class_
  @staticmethod
  def new():
    class_ = InputEventKey.construct_without_init()
    class_._ptr = constructor(419,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPInputEventKeyWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(419,0, ())


  def generate_wrapper(self):
    return CPPInputEventKeyWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = InputEventKey.__new__(InputEventKey)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'InputEventKey'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEventKey.construct_without_init()
    cls._ptr = CPPInputEventKeyWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEventKey.construct_without_init()
    cls._ptr = CPPInputEventKeyWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def pressed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pressed()
    return _ret
  @pressed.setter
  def pressed(self,  value:'bool'):
    self.set_pressed(value)
  @property
  def keycode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_keycode()
    return _ret
  @keycode.setter
  def keycode(self,  value:'int'):
    self.set_keycode(value)
  @property
  def physical_keycode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_physical_keycode()
    return _ret
  @physical_keycode.setter
  def physical_keycode(self,  value:'int'):
    self.set_physical_keycode(value)
  @property
  def key_label(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_key_label()
    return _ret
  @key_label.setter
  def key_label(self,  value:'int'):
    self.set_key_label(value)
  @property
  def unicode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_unicode()
    return _ret
  @unicode.setter
  def unicode(self,  value:'int'):
    self.set_unicode(value)
  @property
  def location(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_location()
    return _ret
  @location.setter
  def location(self,  value:'int'):
    self.set_location(value)
  @property
  def echo(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_echo()
    return _ret
  @echo.setter
  def echo(self,  value:'bool'):
    self.set_echo(value)
  @functools.native_method
  def set_pressed(self, pressed:'bool'   ) -> None:
    r''''''

    assert isinstance(pressed, bool), 'pressed must be bool'

    self.py__pressed = pressed






    self._ptr.call_with_return(106,tuple([pressed]))

  @functools.native_method
  def set_keycode(self, keycode:'int'  ) -> None:
    r''''''

    assert isinstance(keycode, (int, float)), 'keycode must be int or float'

    self.py__keycode = keycode






    self._ptr.call_with_return(107,tuple([keycode]))

  @functools.native_method
  def get_keycode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(108,tuple([]))

    return _ret


  @functools.native_method
  def set_physical_keycode(self, physical_keycode:'int'  ) -> None:
    r''''''

    assert isinstance(physical_keycode, (int, float)), 'physical_keycode must be int or float'

    self.py__physical_keycode = physical_keycode






    self._ptr.call_with_return(109,tuple([physical_keycode]))

  @functools.native_method
  def get_physical_keycode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(110,tuple([]))

    return _ret


  @functools.native_method
  def set_key_label(self, key_label:'int'  ) -> None:
    r''''''

    assert isinstance(key_label, (int, float)), 'key_label must be int or float'

    self.py__key_label = key_label






    self._ptr.call_with_return(111,tuple([key_label]))

  @functools.native_method
  def get_key_label(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(112,tuple([]))

    return _ret


  @functools.native_method
  def set_unicode(self, unicode:'int'   ) -> None:
    r''''''

    assert isinstance(unicode, (int, float)), 'unicode must be int or float'

    self.py__unicode = unicode






    self._ptr.call_with_return(113,tuple([unicode]))

  @functools.native_method
  def get_unicode(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([]))

    return _ret


  @functools.native_method
  def set_location(self, location:'int'  ) -> None:
    r''''''

    assert isinstance(location, (int, float)), 'location must be int or float'

    self.py__location = location






    self._ptr.call_with_return(115,tuple([location]))

  @functools.native_method
  def get_location(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(116,tuple([]))

    return _ret


  @functools.native_method
  def set_echo(self, echo:'bool'   ) -> None:
    r''''''

    assert isinstance(echo, bool), 'echo must be bool'

    self.py__echo = echo






    self._ptr.call_with_return(117,tuple([echo]))

  @functools.native_method
  def get_keycode_with_modifiers(self) -> typing.Union[int]:
    r'''
				Returns the Latin keycode combined with modifier keys such as `kbd`Shift`/kbd` or `kbd`Alt`/kbd`. See also `InputEventWithModifiers`.
				To get a human-readable representation of the `InputEventKey` with modifiers, use `OS.get_keycode_string(event.get_keycode_with_modifiers())` where `event` is the `InputEventKey`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(118,tuple([]))
    return _ret


  @functools.native_method
  def get_physical_keycode_with_modifiers(self) -> typing.Union[int]:
    r'''
				Returns the physical keycode combined with modifier keys such as `kbd`Shift`/kbd` or `kbd`Alt`/kbd`. See also `InputEventWithModifiers`.
				To get a human-readable representation of the `InputEventKey` with modifiers, use `OS.get_keycode_string(event.get_physical_keycode_with_modifiers())` where `event` is the `InputEventKey`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(119,tuple([]))
    return _ret


  @functools.native_method
  def get_key_label_with_modifiers(self) -> typing.Union[int]:
    r'''
				Returns the localized key label combined with modifier keys such as `kbd`Shift`/kbd` or `kbd`Alt`/kbd`. See also `InputEventWithModifiers`.
				To get a human-readable representation of the `InputEventKey` with modifiers, use `OS.get_keycode_string(event.get_key_label_with_modifiers())` where `event` is the `InputEventKey`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(120,tuple([]))
    return _ret


  @functools.native_method
  def as_text_keycode(self) -> typing.Union[str]:
    r'''
				Returns a `String` representation of the event's `keycode` and modifiers.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(121,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def as_text_physical_keycode(self) -> typing.Union[str]:
    r'''
				Returns a `String` representation of the event's `physical_keycode` and modifiers.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(122,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def as_text_key_label(self) -> typing.Union[str]:
    r'''
				Returns a `String` representation of the event's `key_label` and modifiers.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(123,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def as_text_location(self) -> typing.Union[str]:
    r'''
				Returns a `String` representation of the event's `location`. This will be a blank string if the event is not specific to a location.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([]))
    return utils.gd_string_to_py_string(_ret)



register_cast_function('InputEventKey', InputEventKey.cast)
register_class('InputEventKey', InputEventKey)
