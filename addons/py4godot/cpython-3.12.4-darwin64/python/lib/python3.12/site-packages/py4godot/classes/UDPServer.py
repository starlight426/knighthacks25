# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PacketPeerUDP as py4godot_packetpeerudp 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPUDPServerWrapper


class UDPServer(py4godot_refcounted.RefCounted):
  r'''
		A simple server that opens a UDP socket and returns connected `PacketPeerUDP` upon receiving new packets. See also `PacketPeerUDP.connect_to_host`.
		After starting the server (`listen`), you will need to `poll` it at regular intervals (e.g. inside `Node._process`) for it to process new packets, delivering them to the appropriate `PacketPeerUDP`, and taking new connections.
		Below a small example of how it can be used:
		
		```gdscript
		# server_node.gd
		class_name ServerNode
		extends Node

		var server = UDPServer.new()
		var peers = ``

		func _ready():
			server.listen(4242)

		func _process(delta):
			server.poll() # Important!
			if server.is_connection_available():
				var peer = server.take_connection()
				var packet = peer.get_packet()
				print("Accepted peer: %s:%s" % `peer.get_packet_ip(), peer.get_packet_port()`)
				print("Received data: %s" % `packet.get_string_from_utf8()`)
				# Reply so it knows we received the message.
				peer.put_packet(packet)
				# Keep a reference so we can keep contacting the remote peer.
				peers.append(peer)

			for i in range(0, peers.size()):
				pass # Do something with the connected peers.
		```
		
		
		
		```gdscript
		# client_node.gd
		class_name ClientNode
		extends Node

		var udp = PacketPeerUDP.new()
		var connected = false

		func _ready():
			udp.connect_to_host("127.0.0.1", 4242)

		func _process(delta):
			if !connected:
				# Try to contact server
				udp.put_packet("The answer is... 42!".to_utf8_buffer())
			if udp.get_available_packet_count() > 0:
				print("Connected: %s" % udp.get_packet().get_string_from_utf8())
				connected = true
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = UDPServer.construct_without_init()
    class_._ptr = constructor(855,0, ())
    return class_
  @staticmethod
  def new():
    class_ = UDPServer.construct_without_init()
    class_._ptr = constructor(855,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPUDPServerWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(855,0, ())


  def generate_wrapper(self):
    return CPPUDPServerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = UDPServer.__new__(UDPServer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'UDPServer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = UDPServer.construct_without_init()
    cls._ptr = CPPUDPServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = UDPServer.construct_without_init()
    cls._ptr = CPPUDPServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def max_pending_connections(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_pending_connections()
    return _ret
  @max_pending_connections.setter
  def max_pending_connections(self,  value:'int'):
    self.set_max_pending_connections(value)
  @functools.native_method
  def listen(self, port:'int'   , bind_address:'str' ="*"  ) -> typing.Union[int]:
    r'''
				Starts the server by opening a UDP socket listening on the given `port`. You can optionally specify a `bind_address` to only listen for packets sent to that address. See also `PacketPeerUDP.bind`.
			'''
    if bind_address is None:
      bind_address = String.new0()
    if bind_address is None:
      bind_address = String.new0()

    assert isinstance(port, (int, float)), 'port must be int or float'





    assert(isinstance(bind_address, (str, String)))
    py_string_bind_address = bind_address if isinstance(bind_address, StringName) else c_utils.py_string_to_string(bind_address)

    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([port, py_string_bind_address._ptr]))
    return _ret


  @functools.native_method
  def poll(self) -> typing.Union[int]:
    r'''
				Call this method at regular intervals (e.g. inside `Node._process`) to process new packets. Any packet from a known address/port pair will be delivered to the appropriate `PacketPeerUDP`, while any packet received from an unknown address/port pair will be added as a pending connection (see `is_connection_available` and `take_connection`). The maximum number of pending connections is defined via `max_pending_connections`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(54,tuple([]))
    return _ret


  @functools.native_method
  def is_connection_available(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a packet with a new address/port combination was received on the socket.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def get_local_port(self) -> typing.Union[int]:
    r'''
				Returns the local port this server is listening to.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def is_listening(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the socket is open and listening on a port.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def take_connection(self) -> typing.Union['py4godot_packetpeerudp.PacketPeerUDP']:
    r'''
				Returns the first pending connection (connected to the appropriate address/port). Will return `null` if no new connection is available. See also `is_connection_available`, `PacketPeerUDP.connect_to_host`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PacketPeerUDP
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the server, closing the UDP socket if open. Will close all connected `PacketPeerUDP` accepted via `take_connection` (remote peers will not be notified).
			'''




    self._ptr.call_with_return(59,tuple([]))

  @functools.native_method
  def set_max_pending_connections(self, max_pending_connections:'int'   ) -> None:
    r''''''

    assert isinstance(max_pending_connections, (int, float)), 'max_pending_connections must be int or float'

    self.py__max_pending_connections = max_pending_connections






    self._ptr.call_with_return(60,tuple([max_pending_connections]))

  @functools.native_method
  def get_max_pending_connections(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([]))

    return _ret



register_cast_function('UDPServer', UDPServer.cast)
register_class('UDPServer', UDPServer)
