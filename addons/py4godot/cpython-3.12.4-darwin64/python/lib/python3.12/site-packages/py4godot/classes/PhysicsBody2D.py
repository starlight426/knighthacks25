# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.KinematicCollision2D as py4godot_kinematiccollision2d 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.PhysicsBody2DTypedArray as py4godot_physicsbody2dtypedarray 
import py4godot.classes.CollisionObject2D as py4godot_collisionobject2d 
import py4godot.classes.PhysicsBody2DTypedArray as py4godot_physicsbody2dtypedarray 
from py4godot.wrappers.wrappers import CPPPhysicsBody2DWrapper


class PhysicsBody2D(py4godot_collisionobject2d.CollisionObject2D):
  r'''
		`PhysicsBody2D` is an abstract base class for 2D game objects affected by physics. All 2D physics bodies inherit from it.
	'''

  @staticmethod
  def constructor():
    class_ = PhysicsBody2D.construct_without_init()
    class_._ptr = constructor(589,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PhysicsBody2D.construct_without_init()
    class_._ptr = constructor(589,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPhysicsBody2DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(589,0, ())


  def generate_wrapper(self):
    return CPPPhysicsBody2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PhysicsBody2D.__new__(PhysicsBody2D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PhysicsBody2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsBody2D.construct_without_init()
    cls._ptr = CPPPhysicsBody2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsBody2D.construct_without_init()
    cls._ptr = CPPPhysicsBody2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def move_and_collide(self, motion:'Vector2'   , test_only:'bool' =False  , safe_margin:'float' =0.08  , recovery_as_collision:'bool' =False  ) -> typing.Union['py4godot_kinematiccollision2d.KinematicCollision2D']:
    r'''
				Moves the body along the vector `motion`. In order to be frame rate independent in `Node._physics_process` or `Node._process`, `motion` should be computed using `delta`.
				Returns a `KinematicCollision2D`, which contains information about the collision when stopped, or when touching another body along the motion.
				If `test_only` is `true`, the body does not move but the would-be collision information is given.
				`safe_margin` is the extra margin used for collision recovery (see `CharacterBody2D.safe_margin` for more details).
				If `recovery_as_collision` is `true`, any depenetration from the recovery phase is also reported as a collision; this is used e.g. by `CharacterBody2D` for improving floor detection during floor snapping.
			'''

    assert(not motion is None)
    assert isinstance(motion, Vector2), 'motion must be Vector2'
    assert isinstance(test_only, bool), 'test_only must be bool'
    assert isinstance(safe_margin, (int, float)), 'safe_margin must be int or float'
    assert isinstance(recovery_as_collision, bool), 'recovery_as_collision must be bool'









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: KinematicCollision2D
    _ret._ptr = self._ptr.call_with_return(342,tuple([motion._ptr, test_only, safe_margin, recovery_as_collision]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def test_move(self, from_:'Transform2D'   , motion:'Vector2'   , collision:'py4godot_kinematiccollision2d.KinematicCollision2D' = None  , safe_margin:'float' =0.08  , recovery_as_collision:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Checks for collisions without moving the body. In order to be frame rate independent in `Node._physics_process` or `Node._process`, `motion` should be computed using `delta`.
				Virtually sets the node's position, scale and rotation to that of the given `Transform2D`, then tries to move the body along the vector `motion`. Returns `true` if a collision would stop the body from moving along the whole path.
				`collision` is an optional object of type `KinematicCollision2D`, which contains additional information about the collision when stopped, or when touching another body along the motion.
				`safe_margin` is the extra margin used for collision recovery (see `CharacterBody2D.safe_margin` for more details).
				If `recovery_as_collision` is `true`, any depenetration from the recovery phase is also reported as a collision; this is useful for checking whether the body would _touch_ any other bodies.
			'''
    if collision is None:
      collision = c_utils.empty_object
    if collision is None:
      collision = c_utils.empty_object

    assert(not from_ is None)
    assert isinstance(from_, Transform2D), 'from_ must be Transform2D'
    assert(not motion is None)
    assert isinstance(motion, Vector2), 'motion must be Vector2'
    assert isinstance(safe_margin, (int, float)), 'safe_margin must be int or float'
    assert isinstance(recovery_as_collision, bool), 'recovery_as_collision must be bool'










    _ret = 0
    _ret = self._ptr.call_with_return(343,tuple([from_._ptr, motion._ptr, collision._ptr, safe_margin, recovery_as_collision]))
    return _ret


  @functools.native_method
  def get_gravity(self) -> typing.Union['Vector2']:
    r'''
				Returns the gravity vector computed from all sources that can affect the body, including all gravity overrides from `Area2D` nodes and the global world gravity.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(344,tuple([]))
    return _ret


  @functools.native_method
  def get_collision_exceptions(self) -> typing.Union['py4godot_physicsbody2dtypedarray.PhysicsBody2DTypedArray']:
    r'''
				Returns an array of nodes that were added as collision exceptions for this body.
			'''




    _ret = py4godot_physicsbody2dtypedarray.PhysicsBody2DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(345,tuple([]))
    return _ret


  @functools.native_method
  def add_collision_exception_with(self, body:'py4godot_node.Node'   ) -> None:
    r'''
				Adds a body to the list of bodies that this body can't collide with.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'






    self._ptr.call_with_return(346,tuple([body._ptr]))

  @functools.native_method
  def remove_collision_exception_with(self, body:'py4godot_node.Node'   ) -> None:
    r'''
				Removes a body from the list of bodies that this body can't collide with.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'






    self._ptr.call_with_return(347,tuple([body._ptr]))


register_cast_function('PhysicsBody2D', PhysicsBody2D.cast)
register_class('PhysicsBody2D', PhysicsBody2D)
