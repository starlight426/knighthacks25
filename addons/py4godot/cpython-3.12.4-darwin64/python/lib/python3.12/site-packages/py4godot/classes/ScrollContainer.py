# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
import py4godot.classes.Container as py4godot_container 
from py4godot.wrappers.wrappers import CPPScrollContainerWrapper

class ScrollMode:
  SCROLL_MODE_DISABLED = 0
  SCROLL_MODE_AUTO = 1
  SCROLL_MODE_SHOW_ALWAYS = 2
  SCROLL_MODE_SHOW_NEVER = 3
  SCROLL_MODE_RESERVE = 4


class ScrollContainer(py4godot_container.Container):
  r'''
		A container used to provide a child control with scrollbars when needed. Scrollbars will automatically be drawn at the right (for vertical) or bottom (for horizontal) and will enable dragging to move the viewable Control (and its children) within the ScrollContainer. Scrollbars will also automatically resize the grabber based on the `Control.custom_minimum_size` of the Control relative to the ScrollContainer.
	'''

  @staticmethod
  def constructor():
    class_ = ScrollContainer.construct_without_init()
    class_._ptr = constructor(730,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ScrollContainer.construct_without_init()
    class_._ptr = constructor(730,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPScrollContainerWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(730,0, ())


  def generate_wrapper(self):
    return CPPScrollContainerWrapper()
  def init_signals(self):
    super().init_signals()
    scroll_started_name = utils.py_string_to_string_name("scroll_started")
    self.scroll_started = signals.BuiltinSignal(self, scroll_started_name)
    scroll_ended_name = utils.py_string_to_string_name("scroll_ended")
    self.scroll_ended = signals.BuiltinSignal(self, scroll_ended_name)

  @staticmethod
  def construct_without_init():
    cls = ScrollContainer.__new__(ScrollContainer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ScrollContainer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ScrollContainer.construct_without_init()
    cls._ptr = CPPScrollContainerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ScrollContainer.construct_without_init()
    cls._ptr = CPPScrollContainerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def follow_focus(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_following_focus()
    return _ret
  @follow_focus.setter
  def follow_focus(self,  value:'bool'):
    self.set_follow_focus(value)
  @property
  def draw_focus_border(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_focus_border()
    return _ret
  @draw_focus_border.setter
  def draw_focus_border(self,  value:'bool'):
    self.set_draw_focus_border(value)
  @property
  def scroll_horizontal(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_h_scroll()
    return _ret
  @scroll_horizontal.setter
  def scroll_horizontal(self,  value:'int'):
    self.set_h_scroll(value)
  @property
  def scroll_vertical(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_v_scroll()
    return _ret
  @scroll_vertical.setter
  def scroll_vertical(self,  value:'int'):
    self.set_v_scroll(value)
  @property
  def scroll_horizontal_custom_step(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_horizontal_custom_step()
    return _ret
  @scroll_horizontal_custom_step.setter
  def scroll_horizontal_custom_step(self,  value:'float'):
    self.set_horizontal_custom_step(value)
  @property
  def scroll_vertical_custom_step(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_vertical_custom_step()
    return _ret
  @scroll_vertical_custom_step.setter
  def scroll_vertical_custom_step(self,  value:'float'):
    self.set_vertical_custom_step(value)
  @property
  def horizontal_scroll_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_scroll_mode()
    return _ret
  @horizontal_scroll_mode.setter
  def horizontal_scroll_mode(self,  value:'int'):
    self.set_horizontal_scroll_mode(value)
  @property
  def vertical_scroll_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_vertical_scroll_mode()
    return _ret
  @vertical_scroll_mode.setter
  def vertical_scroll_mode(self,  value:'int'):
    self.set_vertical_scroll_mode(value)
  @property
  def scroll_deadzone(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_deadzone()
    return _ret
  @scroll_deadzone.setter
  def scroll_deadzone(self,  value:'int'):
    self.set_deadzone(value)
  @functools.native_method
  def set_h_scroll(self, value:'int'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__scroll_horizontal = value






    self._ptr.call_with_return(437,tuple([value]))

  @functools.native_method
  def get_h_scroll(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(438,tuple([]))

    return _ret


  @functools.native_method
  def set_v_scroll(self, value:'int'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__scroll_vertical = value






    self._ptr.call_with_return(439,tuple([value]))

  @functools.native_method
  def get_v_scroll(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(440,tuple([]))

    return _ret


  @functools.native_method
  def set_horizontal_custom_step(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__scroll_horizontal_custom_step = value






    self._ptr.call_with_return(441,tuple([value]))

  @functools.native_method
  def get_horizontal_custom_step(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(442,tuple([]))

    return _ret


  @functools.native_method
  def set_vertical_custom_step(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__scroll_vertical_custom_step = value






    self._ptr.call_with_return(443,tuple([value]))

  @functools.native_method
  def get_vertical_custom_step(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(444,tuple([]))

    return _ret


  @functools.native_method
  def set_horizontal_scroll_mode(self, enable:'int'  ) -> None:
    r''''''

    assert isinstance(enable, (int, float)), 'enable must be int or float'

    self.py__horizontal_scroll_mode = enable






    self._ptr.call_with_return(445,tuple([enable]))

  @functools.native_method
  def get_horizontal_scroll_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(446,tuple([]))

    return _ret


  @functools.native_method
  def set_vertical_scroll_mode(self, enable:'int'  ) -> None:
    r''''''

    assert isinstance(enable, (int, float)), 'enable must be int or float'

    self.py__vertical_scroll_mode = enable






    self._ptr.call_with_return(447,tuple([enable]))

  @functools.native_method
  def get_vertical_scroll_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(448,tuple([]))

    return _ret


  @functools.native_method
  def set_deadzone(self, deadzone:'int'   ) -> None:
    r''''''

    assert isinstance(deadzone, (int, float)), 'deadzone must be int or float'

    self.py__scroll_deadzone = deadzone






    self._ptr.call_with_return(449,tuple([deadzone]))

  @functools.native_method
  def get_deadzone(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(450,tuple([]))

    return _ret


  @functools.native_method
  def set_follow_focus(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__follow_focus = enabled






    self._ptr.call_with_return(451,tuple([enabled]))

  @functools.native_method
  def is_following_focus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(452,tuple([]))

    return _ret


  @functools.native_method
  def get_h_scroll_bar(self) -> typing.Union['py4godot_hscrollbar.HScrollBar']:
    r'''
				Returns the horizontal scrollbar `HScrollBar` of this `ScrollContainer`.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to disable or hide a scrollbar, you can use `horizontal_scroll_mode`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: HScrollBar
    _ret._ptr = self._ptr.call_with_return(453,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_v_scroll_bar(self) -> typing.Union['py4godot_vscrollbar.VScrollBar']:
    r'''
				Returns the vertical scrollbar `VScrollBar` of this `ScrollContainer`.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to disable or hide a scrollbar, you can use `vertical_scroll_mode`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VScrollBar
    _ret._ptr = self._ptr.call_with_return(454,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def ensure_control_visible(self, control:'py4godot_control.Control'   ) -> None:
    r'''
				Ensures the given `control` is visible (must be a direct or indirect child of the ScrollContainer). Used by `follow_focus`.
				**Note:** This will not work on a node that was just added during the same frame. If you want to scroll to a newly added child, you must wait until the next frame using `signal SceneTree.process_frame`:
				```gdscript
				add_child(child_node)
				await get_tree().process_frame
				ensure_control_visible(child_node)
				```
			'''

    assert(not control is None)
    assert isinstance(control, get_class('Control')), 'control must be Control'






    self._ptr.call_with_return(455,tuple([control._ptr]))

  @functools.native_method
  def set_draw_focus_border(self, draw:'bool'   ) -> None:
    r''''''

    assert isinstance(draw, bool), 'draw must be bool'

    self.py__draw_focus_border = draw






    self._ptr.call_with_return(456,tuple([draw]))

  @functools.native_method
  def get_draw_focus_border(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([]))

    return _ret



register_cast_function('ScrollContainer', ScrollContainer.cast)
register_class('ScrollContainer', ScrollContainer)
