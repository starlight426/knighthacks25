# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
from py4godot.wrappers.wrappers import CPPPerformanceWrapper

_Performance_singleton_instance = None
class Monitor:
  TIME_FPS = 0
  TIME_PROCESS = 1
  TIME_PHYSICS_PROCESS = 2
  TIME_NAVIGATION_PROCESS = 3
  MEMORY_STATIC = 4
  MEMORY_STATIC_MAX = 5
  MEMORY_MESSAGE_BUFFER_MAX = 6
  OBJECT_COUNT = 7
  OBJECT_RESOURCE_COUNT = 8
  OBJECT_NODE_COUNT = 9
  OBJECT_ORPHAN_NODE_COUNT = 10
  RENDER_TOTAL_OBJECTS_IN_FRAME = 11
  RENDER_TOTAL_PRIMITIVES_IN_FRAME = 12
  RENDER_TOTAL_DRAW_CALLS_IN_FRAME = 13
  RENDER_VIDEO_MEM_USED = 14
  RENDER_TEXTURE_MEM_USED = 15
  RENDER_BUFFER_MEM_USED = 16
  PHYSICS_2D_ACTIVE_OBJECTS = 17
  PHYSICS_2D_COLLISION_PAIRS = 18
  PHYSICS_2D_ISLAND_COUNT = 19
  PHYSICS_3D_ACTIVE_OBJECTS = 20
  PHYSICS_3D_COLLISION_PAIRS = 21
  PHYSICS_3D_ISLAND_COUNT = 22
  AUDIO_OUTPUT_LATENCY = 23
  NAVIGATION_ACTIVE_MAPS = 24
  NAVIGATION_REGION_COUNT = 25
  NAVIGATION_AGENT_COUNT = 26
  NAVIGATION_LINK_COUNT = 27
  NAVIGATION_POLYGON_COUNT = 28
  NAVIGATION_EDGE_COUNT = 29
  NAVIGATION_EDGE_MERGE_COUNT = 30
  NAVIGATION_EDGE_CONNECTION_COUNT = 31
  NAVIGATION_EDGE_FREE_COUNT = 32
  NAVIGATION_OBSTACLE_COUNT = 33
  PIPELINE_COMPILATIONS_CANVAS = 34
  PIPELINE_COMPILATIONS_MESH = 35
  PIPELINE_COMPILATIONS_SURFACE = 36
  PIPELINE_COMPILATIONS_DRAW = 37
  PIPELINE_COMPILATIONS_SPECIALIZATION = 38
  NAVIGATION_2D_ACTIVE_MAPS = 39
  NAVIGATION_2D_REGION_COUNT = 40
  NAVIGATION_2D_AGENT_COUNT = 41
  NAVIGATION_2D_LINK_COUNT = 42
  NAVIGATION_2D_POLYGON_COUNT = 43
  NAVIGATION_2D_EDGE_COUNT = 44
  NAVIGATION_2D_EDGE_MERGE_COUNT = 45
  NAVIGATION_2D_EDGE_CONNECTION_COUNT = 46
  NAVIGATION_2D_EDGE_FREE_COUNT = 47
  NAVIGATION_2D_OBSTACLE_COUNT = 48
  NAVIGATION_3D_ACTIVE_MAPS = 49
  NAVIGATION_3D_REGION_COUNT = 50
  NAVIGATION_3D_AGENT_COUNT = 51
  NAVIGATION_3D_LINK_COUNT = 52
  NAVIGATION_3D_POLYGON_COUNT = 53
  NAVIGATION_3D_EDGE_COUNT = 54
  NAVIGATION_3D_EDGE_MERGE_COUNT = 55
  NAVIGATION_3D_EDGE_CONNECTION_COUNT = 56
  NAVIGATION_3D_EDGE_FREE_COUNT = 57
  NAVIGATION_3D_OBSTACLE_COUNT = 58
  MONITOR_MAX = 59


class Performance(py4godot_object.Object):
  r'''
		This class provides access to a number of different monitors related to performance, such as memory usage, draw calls, and FPS. These are the same as the values displayed in the **Monitor** tab in the editor's **Debugger** panel. By using the `get_monitor` method of this class, you can access this data from your code.
		You can add custom monitors using the `add_custom_monitor` method. Custom monitors are available in **Monitor** tab in the editor's **Debugger** panel together with built-in monitors.
		**Note:** Some of the built-in monitors are only available in debug mode and will always return `0` when used in a project exported in release mode.
		**Note:** Some of the built-in monitors are not updated in real-time for performance reasons, so there may be a delay of up to 1 second between changes.
		**Note:** Custom monitors do not support negative values. Negative values are clamped to 0.
	'''


  def generate_wrapper(self):
    return CPPPerformanceWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Performance.__new__(Performance)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Performance'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Performance.construct_without_init()
    cls._ptr = CPPPerformanceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Performance.construct_without_init()
    cls._ptr = CPPPerformanceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _Performance_singleton_instance
    if _Performance_singleton_instance is None:
      singleton = Performance()
      singleton._ptr = constructor(584,0, ())
      _Performance_singleton_instance = singleton
    return _Performance_singleton_instance

  @functools.native_method
  def get_monitor(self, monitor:'int'  ) -> typing.Union[float]:
    r'''
				Returns the value of one of the available built-in monitors. You should provide one of the `enum Monitor` constants as the argument, like this:
				
				```gdscript
				print(Performance.get_monitor(Performance.TIME_FPS)) # Prints the FPS to the console.
				```
				
				
				See `get_custom_monitor` to query custom performance monitors' values.
			'''

    assert isinstance(monitor, (int, float)), 'monitor must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([monitor]))
    return _ret


  @functools.native_method
  def add_custom_monitor(self, id:'object'   , callable:'Callable'   , arguments:'Array' = None  ) -> None:
    r'''
				Adds a custom monitor with the name `id`. You can specify the category of the monitor using slash delimiters in `id` (for example: `"Game/NumberOfNPCs"`). If there is more than one slash delimiter, then the default category is used. The default category is `"Custom"`. Prints an error if given `id` is already present.
				
				```gdscript
				func _ready():
					var monitor_value = Callable(self, "get_monitor_value")

					# Adds monitor with name "MyName" to category "MyCategory".
					Performance.add_custom_monitor("MyCategory/MyMonitor", monitor_value)

					# Adds monitor with name "MyName" to category "Custom".
					# Note: "MyCategory/MyMonitor" and "MyMonitor" have same name but different IDs, so the code is valid.
					Performance.add_custom_monitor("MyMonitor", monitor_value)

					# Adds monitor with name "MyName" to category "Custom".
					# Note: "MyMonitor" and "Custom/MyMonitor" have same name and same category but different IDs, so the code is valid.
					Performance.add_custom_monitor("Custom/MyMonitor", monitor_value)

					# Adds monitor with name "MyCategoryOne/MyCategoryTwo/MyMonitor" to category "Custom".
					Performance.add_custom_monitor("MyCategoryOne/MyCategoryTwo/MyMonitor", monitor_value)

				func get_monitor_value():
					return randi() % 25
				```
				
				
				The debugger calls the callable to get the value of custom monitor. The callable must return a zero or positive integer or floating-point number.
				Callables are called with arguments supplied in argument array.
			'''
    if arguments is None:
      arguments = Array.new0()
    if arguments is None:
      arguments = Array.new0()

    assert(not id is None)
    assert isinstance(id, (str, StringName)), 'id must be str or StringName'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'




    assert(isinstance(id, (str, StringName)))
    py_stringname_id = id if isinstance(id, StringName) else c_utils.py_string_to_string_name(id)



    self._ptr.call_with_return(50,tuple([py_stringname_id._ptr, callable._ptr, arguments._ptr]))

  @functools.native_method
  def remove_custom_monitor(self, id:'object'   ) -> None:
    r'''
				Removes the custom monitor with given `id`. Prints an error if the given `id` is already absent.
			'''

    assert(not id is None)
    assert isinstance(id, (str, StringName)), 'id must be str or StringName'




    assert(isinstance(id, (str, StringName)))
    py_stringname_id = id if isinstance(id, StringName) else c_utils.py_string_to_string_name(id)

    self._ptr.call_with_return(51,tuple([py_stringname_id._ptr]))

  @functools.native_method
  def has_custom_monitor(self, id:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if custom monitor with the given `id` is present, `false` otherwise.
			'''

    assert(not id is None)
    assert isinstance(id, (str, StringName)), 'id must be str or StringName'




    assert(isinstance(id, (str, StringName)))
    py_stringname_id = id if isinstance(id, StringName) else c_utils.py_string_to_string_name(id)

    _ret = 0
    _ret = self._ptr.call_with_return(52,tuple([py_stringname_id._ptr]))
    return _ret


  @functools.native_method
  def get_custom_monitor(self, id:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of custom monitor with given `id`. The callable is called to get the value of custom monitor. See also `has_custom_monitor`. Prints an error if the given `id` is absent.
			'''

    assert(not id is None)
    assert isinstance(id, (str, StringName)), 'id must be str or StringName'




    assert(isinstance(id, (str, StringName)))
    py_stringname_id = id if isinstance(id, StringName) else c_utils.py_string_to_string_name(id)

    _ret = None
    _ret = self._ptr.call_with_return(53,tuple([py_stringname_id._ptr]))
    return _ret


  @functools.native_method
  def get_monitor_modification_time(self) -> typing.Union[int]:
    r'''
				Returns the last tick in which custom monitor was added/removed (in microseconds since the engine started). This is set to `Time.get_ticks_usec` when the monitor is updated.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([]))
    return _ret


  @functools.native_method
  def get_custom_monitor_names(self) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
				Returns the names of active custom monitors in an `Array`.
			'''




    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([]))
    return _ret



register_cast_function('Performance', Performance.cast)
register_class('Performance', Performance)
