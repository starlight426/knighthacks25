# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Node as py4godot_node 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPRangeWrapper


class Range(py4godot_control.Control):
  r'''
		Range is an abstract base class for controls that represent a number within a range, using a configured `step` and `page` size. See e.g. `ScrollBar` and `Slider` for examples of higher-level nodes using Range.
	'''

  @staticmethod
  def constructor():
    class_ = Range.construct_without_init()
    class_._ptr = constructor(662,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Range.construct_without_init()
    class_._ptr = constructor(662,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRangeWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(662,0, ())


  def generate_wrapper(self):
    return CPPRangeWrapper()
  def init_signals(self):
    super().init_signals()
    value_changed_name = utils.py_string_to_string_name("value_changed")
    self.value_changed = signals.BuiltinSignal(self, value_changed_name)
    changed_name = utils.py_string_to_string_name("changed")
    self.changed = signals.BuiltinSignal(self, changed_name)

  @staticmethod
  def construct_without_init():
    cls = Range.__new__(Range)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Range'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Range.construct_without_init()
    cls._ptr = CPPRangeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Range.construct_without_init()
    cls._ptr = CPPRangeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def min_value(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_min()
    return _ret
  @min_value.setter
  def min_value(self,  value:'float'):
    self.set_min(value)
  @property
  def max_value(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max()
    return _ret
  @max_value.setter
  def max_value(self,  value:'float'):
    self.set_max(value)
  @property
  def step(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_step()
    return _ret
  @step.setter
  def step(self,  value:'float'):
    self.set_step(value)
  @property
  def page(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_page()
    return _ret
  @page.setter
  def page(self,  value:'float'):
    self.set_page(value)
  @property
  def value(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_value()
    return _ret
  @value.setter
  def value(self,  value:'float'):
    self.set_value(value)
  @property
  def ratio(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_as_ratio()
    return _ret
  @ratio.setter
  def ratio(self,  value:'float'):
    self.set_as_ratio(value)
  @property
  def exp_edit(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ratio_exp()
    return _ret
  @exp_edit.setter
  def exp_edit(self,  value:'bool'):
    self.set_exp_ratio(value)
  @property
  def rounded(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_rounded_values()
    return _ret
  @rounded.setter
  def rounded(self,  value:'bool'):
    self.set_use_rounded_values(value)
  @property
  def allow_greater(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_greater_allowed()
    return _ret
  @allow_greater.setter
  def allow_greater(self,  value:'bool'):
    self.set_allow_greater(value)
  @property
  def allow_lesser(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_lesser_allowed()
    return _ret
  @allow_lesser.setter
  def allow_lesser(self,  value:'bool'):
    self.set_allow_lesser(value)
  @functools.native_method
  def _value_changed(self, new_value:'float'   ) -> None:
    r'''
				Called when the `Range`'s value is changed (following the same conditions as `signal value_changed`).
			'''

    assert isinstance(new_value, (int, float)), 'new_value must be int or float'






    self._ptr.call_with_return(433,tuple([new_value]))

  @functools.native_method
  def get_value(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(434,tuple([]))

    return _ret


  @functools.native_method
  def get_min(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(435,tuple([]))

    return _ret


  @functools.native_method
  def get_max(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(436,tuple([]))

    return _ret


  @functools.native_method
  def get_step(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(437,tuple([]))

    return _ret


  @functools.native_method
  def get_page(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(438,tuple([]))

    return _ret


  @functools.native_method
  def get_as_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(439,tuple([]))

    return _ret


  @functools.native_method
  def set_value(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__value = value






    self._ptr.call_with_return(440,tuple([value]))

  @functools.native_method
  def set_value_no_signal(self, value:'float'   ) -> None:
    r'''
				Sets the `Range`'s current value to the specified `value`, without emitting the `signal value_changed` signal.
			'''

    assert isinstance(value, (int, float)), 'value must be int or float'






    self._ptr.call_with_return(441,tuple([value]))

  @functools.native_method
  def set_min(self, minimum:'float'   ) -> None:
    r''''''

    assert isinstance(minimum, (int, float)), 'minimum must be int or float'

    self.py__min_value = minimum






    self._ptr.call_with_return(442,tuple([minimum]))

  @functools.native_method
  def set_max(self, maximum:'float'   ) -> None:
    r''''''

    assert isinstance(maximum, (int, float)), 'maximum must be int or float'

    self.py__max_value = maximum






    self._ptr.call_with_return(443,tuple([maximum]))

  @functools.native_method
  def set_step(self, step:'float'   ) -> None:
    r''''''

    assert isinstance(step, (int, float)), 'step must be int or float'

    self.py__step = step






    self._ptr.call_with_return(444,tuple([step]))

  @functools.native_method
  def set_page(self, pagesize:'float'   ) -> None:
    r''''''

    assert isinstance(pagesize, (int, float)), 'pagesize must be int or float'

    self.py__page = pagesize






    self._ptr.call_with_return(445,tuple([pagesize]))

  @functools.native_method
  def set_as_ratio(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'

    self.py__ratio = value






    self._ptr.call_with_return(446,tuple([value]))

  @functools.native_method
  def set_use_rounded_values(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__rounded = enabled






    self._ptr.call_with_return(447,tuple([enabled]))

  @functools.native_method
  def is_using_rounded_values(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(448,tuple([]))

    return _ret


  @functools.native_method
  def set_exp_ratio(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__exp_edit = enabled






    self._ptr.call_with_return(449,tuple([enabled]))

  @functools.native_method
  def is_ratio_exp(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(450,tuple([]))

    return _ret


  @functools.native_method
  def set_allow_greater(self, allow:'bool'   ) -> None:
    r''''''

    assert isinstance(allow, bool), 'allow must be bool'

    self.py__allow_greater = allow






    self._ptr.call_with_return(451,tuple([allow]))

  @functools.native_method
  def is_greater_allowed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(452,tuple([]))

    return _ret


  @functools.native_method
  def set_allow_lesser(self, allow:'bool'   ) -> None:
    r''''''

    assert isinstance(allow, bool), 'allow must be bool'

    self.py__allow_lesser = allow






    self._ptr.call_with_return(453,tuple([allow]))

  @functools.native_method
  def is_lesser_allowed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(454,tuple([]))

    return _ret


  @functools.native_method
  def share(self, with_:'py4godot_node.Node'   ) -> None:
    r'''
				Binds two `Range`s together along with any ranges previously grouped with either of them. When any of range's member variables change, it will share the new value with all other ranges in its group.
			'''

    assert(not with_ is None)
    assert isinstance(with_, get_class('Node')), 'with_ must be Node'






    self._ptr.call_with_return(455,tuple([with_._ptr]))

  @functools.native_method
  def unshare(self) -> None:
    r'''
				Stops the `Range` from sharing its member variables with any other.
			'''




    self._ptr.call_with_return(456,tuple([]))


register_cast_function('Range', Range.cast)
register_class('Range', Range)
