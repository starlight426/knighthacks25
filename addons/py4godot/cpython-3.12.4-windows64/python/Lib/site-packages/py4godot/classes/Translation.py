# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPTranslationWrapper


class Translation(py4godot_resource.Resource):
  r'''
		`Translation`s are resources that can be loaded and unloaded on demand. They map a collection of strings to their individual translations, and they also provide convenience methods for pluralization.
	'''

  @staticmethod
  def constructor():
    class_ = Translation.construct_without_init()
    class_._ptr = constructor(846,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Translation.construct_without_init()
    class_._ptr = constructor(846,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTranslationWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(846,0, ())


  def generate_wrapper(self):
    return CPPTranslationWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Translation.__new__(Translation)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Translation'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Translation.construct_without_init()
    cls._ptr = CPPTranslationWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Translation.construct_without_init()
    cls._ptr = CPPTranslationWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def messages(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. _get_messages()
    return _ret
  @messages.setter
  def messages(self,  value:'Dictionary'):
    self._set_messages(value)
  @property
  def locale(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_locale()
    return _ret
  @locale.setter
  def locale(self,  value:'str'):
    self.set_locale(value)
  @functools.native_method
  def _get_plural_message(self, src_message:'object'   , src_plural_message:'object'   , n:'int'   , context:'object'   ) -> typing.Union['StringName']:
    r'''
				Virtual method to override `get_plural_message`.
			'''

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not src_plural_message is None)
    assert isinstance(src_plural_message, (str, StringName)), 'src_plural_message must be str or StringName'
    assert isinstance(n, (int, float)), 'n must be int or float'
    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'




    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(src_plural_message, (str, StringName)))
    py_stringname_src_plural_message = src_plural_message if isinstance(src_plural_message, StringName) else c_utils.py_string_to_string_name(src_plural_message)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([py_stringname_src_message._ptr, py_stringname_src_plural_message._ptr, n, py_stringname_context._ptr]))
    return _ret


  @functools.native_method
  def _get_message(self, src_message:'object'   , context:'object'   ) -> typing.Union['StringName']:
    r'''
				Virtual method to override `get_message`.
			'''

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'




    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([py_stringname_src_message._ptr, py_stringname_context._ptr]))
    return _ret


  @functools.native_method
  def set_locale(self, locale:'str'   ) -> None:
    r''''''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'

    self.py__locale = locale



    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    py__string_locale = utils.py_string_to_string(locale)
    py__string_locale.shouldBeDeleted = False


    self._ptr.call_with_return(79,tuple([py__string_locale._ptr]))

  @functools.native_method
  def get_locale(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def add_message(self, src_message:'object'   , xlated_message:'object'   , context:'object' = None  ) -> None:
    r'''
				Adds a message if nonexistent, followed by its translation.
				An additional context could be used to specify the translation context or differentiate polysemic words.
			'''
    if context is None:
      context = StringName.new0()
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not xlated_message is None)
    assert isinstance(xlated_message, (str, StringName)), 'xlated_message must be str or StringName'




    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(xlated_message, (str, StringName)))
    py_stringname_xlated_message = xlated_message if isinstance(xlated_message, StringName) else c_utils.py_string_to_string_name(xlated_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    self._ptr.call_with_return(81,tuple([py_stringname_src_message._ptr, py_stringname_xlated_message._ptr, py_stringname_context._ptr]))

  @functools.native_method
  def add_plural_message(self, src_message:'object'   , xlated_messages:'PackedStringArray'   , context:'object' = None  ) -> None:
    r'''
				Adds a message involving plural translation if nonexistent, followed by its translation.
				An additional context could be used to specify the translation context or differentiate polysemic words.
				**Note:** Plurals are only supported in `url=$DOCS_URL/tutorials/i18n/localization_using_gettext.html`gettext-based translations (PO)`/url`, not CSV.
			'''
    if context is None:
      context = StringName.new0()
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not xlated_messages is None)
    assert isinstance(xlated_messages, PackedStringArray), 'xlated_messages must be PackedStringArray'




    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    self._ptr.call_with_return(82,tuple([py_stringname_src_message._ptr, xlated_messages._ptr, py_stringname_context._ptr]))

  @functools.native_method
  def get_message(self, src_message:'object'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns a message's translation.
			'''
    if context is None:
      context = StringName.new0()
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'




    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([py_stringname_src_message._ptr, py_stringname_context._ptr]))
    return _ret


  @functools.native_method
  def get_plural_message(self, src_message:'object'   , src_plural_message:'object'   , n:'int'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns a message's translation involving plurals.
				The number `n` is the number or quantity of the plural object. It will be used to guide the translation system to fetch the correct plural form for the selected language.
				**Note:** Plurals are only supported in `url=$DOCS_URL/tutorials/i18n/localization_using_gettext.html`gettext-based translations (PO)`/url`, not CSV.
			'''
    if context is None:
      context = StringName.new0()
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not src_plural_message is None)
    assert isinstance(src_plural_message, (str, StringName)), 'src_plural_message must be str or StringName'
    assert isinstance(n, (int, float)), 'n must be int or float'




    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(src_plural_message, (str, StringName)))
    py_stringname_src_plural_message = src_plural_message if isinstance(src_plural_message, StringName) else c_utils.py_string_to_string_name(src_plural_message)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([py_stringname_src_message._ptr, py_stringname_src_plural_message._ptr, n, py_stringname_context._ptr]))
    return _ret


  @functools.native_method
  def erase_message(self, src_message:'object'   , context:'object' = None  ) -> None:
    r'''
				Erases a message.
			'''
    if context is None:
      context = StringName.new0()
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'




    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    self._ptr.call_with_return(85,tuple([py_stringname_src_message._ptr, py_stringname_context._ptr]))

  @functools.native_method
  def get_message_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns all the messages (keys).
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def get_translated_message_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns all the messages (translated text).
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def get_message_count(self) -> typing.Union[int]:
    r'''
				Returns the number of existing messages.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))
    return _ret



register_cast_function('Translation', Translation.cast)
register_class('Translation', Translation)
