# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.QuadOccluder3D as py4godot_quadoccluder3d 
  import py4godot.classes.PolygonOccluder3D as py4godot_polygonoccluder3d 
  import py4godot.classes.BoxOccluder3D as py4godot_boxoccluder3d 
  import py4godot.classes.ArrayOccluder3D as py4godot_arrayoccluder3d 
  import py4godot.classes.Occluder3D as py4godot_occluder3d 
  import py4godot.classes.SphereOccluder3D as py4godot_sphereoccluder3d 
import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
from py4godot.wrappers.wrappers import CPPOccluderInstance3DWrapper


class OccluderInstance3D(py4godot_visualinstance3d.VisualInstance3D):
  r'''
		Occlusion culling can improve rendering performance in closed/semi-open areas by hiding geometry that is occluded by other objects.
		The occlusion culling system is mostly static. `OccluderInstance3D`s can be moved or hidden at run-time, but doing so will trigger a background recomputation that can take several frames. It is recommended to only move `OccluderInstance3D`s sporadically (e.g. for procedural generation purposes), rather than doing so every frame.
		The occlusion culling system works by rendering the occluders on the CPU in parallel using `url=https://www.embree.org/`Embree`/url`, drawing the result to a low-resolution buffer then using this to cull 3D nodes individually. In the 3D editor, you can preview the occlusion culling buffer by choosing **Perspective > Display Advanced... > Occlusion Culling Buffer** in the top-left corner of the 3D viewport. The occlusion culling buffer quality can be adjusted in the Project Settings.
		**Baking:** Select an `OccluderInstance3D` node, then use the **Bake Occluders** button at the top of the 3D editor. Only opaque materials will be taken into account; transparent materials (alpha-blended or alpha-tested) will be ignored by the occluder generation.
		**Note:** Occlusion culling is only effective if `ProjectSettings.rendering/occlusion_culling/use_occlusion_culling` is `true`. Enabling occlusion culling has a cost on the CPU. Only enable occlusion culling if you actually plan to use it. Large open scenes with few or no objects blocking the view will generally not benefit much from occlusion culling. Large open scenes generally benefit more from mesh LOD and visibility ranges (`GeometryInstance3D.visibility_range_begin` and `GeometryInstance3D.visibility_range_end`) compared to occlusion culling.
		**Note:** Due to memory constraints, occlusion culling is not supported by default in Web export templates. It can be enabled by compiling custom Web export templates with `module_raycast_enabled=yes`.
	'''

  @staticmethod
  def constructor():
    class_ = OccluderInstance3D.construct_without_init()
    class_._ptr = constructor(525,0, ())
    return class_
  @staticmethod
  def new():
    class_ = OccluderInstance3D.construct_without_init()
    class_._ptr = constructor(525,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPOccluderInstance3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(525,0, ())


  def generate_wrapper(self):
    return CPPOccluderInstance3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = OccluderInstance3D.__new__(OccluderInstance3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'OccluderInstance3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = OccluderInstance3D.construct_without_init()
    cls._ptr = CPPOccluderInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = OccluderInstance3D.construct_without_init()
    cls._ptr = CPPOccluderInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def occluder(self) -> typing.Any:
    r''''''
    _ret = self. get_occluder()
    return _ret
  @occluder.setter
  def occluder(self,  value:'py4godot_object.Object'):
    self.set_occluder(value)
  @property
  def bake_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bake_mask()
    return _ret
  @bake_mask.setter
  def bake_mask(self,  value:'int'):
    self.set_bake_mask(value)
  @property
  def bake_simplification_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bake_simplification_distance()
    return _ret
  @bake_simplification_distance.setter
  def bake_simplification_distance(self,  value:'float'):
    self.set_bake_simplification_distance(value)
  @functools.native_method
  def set_bake_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'

    self.py__bake_mask = mask






    self._ptr.call_with_return(264,tuple([mask]))

  @functools.native_method
  def get_bake_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_bake_mask_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `bake_mask`, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'







    self._ptr.call_with_return(266,tuple([layer_number, value]))

  @functools.native_method
  def get_bake_mask_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `bake_mask` is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(267,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_bake_simplification_distance(self, simplification_distance:'float'   ) -> None:
    r''''''

    assert isinstance(simplification_distance, (int, float)), 'simplification_distance must be int or float'

    self.py__bake_simplification_distance = simplification_distance






    self._ptr.call_with_return(268,tuple([simplification_distance]))

  @functools.native_method
  def get_bake_simplification_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_occluder(self, occluder:'py4godot_occluder3d.Occluder3D'   ) -> None:
    r''''''

    assert(not occluder is None)
    assert isinstance(occluder, get_class('Occluder3D')), 'occluder must be Occluder3D'

    self.py__occluder = occluder






    self._ptr.call_with_return(270,tuple([occluder._ptr]))

  @functools.native_method
  def get_occluder(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Occluder3D
    _ret._ptr = self._ptr.call_with_return(271,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('OccluderInstance3D', OccluderInstance3D.cast)
register_class('OccluderInstance3D', OccluderInstance3D)
