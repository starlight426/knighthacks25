# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Resource as py4godot_resource 
  import py4godot.classes.ResourceFormatSaver as py4godot_resourceformatsaver 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPResourceSaverWrapper

_ResourceSaver_singleton_instance = None
class SaverFlags:
  FLAG_NONE = 0
  FLAG_RELATIVE_PATHS = 1
  FLAG_BUNDLE_RESOURCES = 2
  FLAG_CHANGE_PATH = 4
  FLAG_OMIT_EDITOR_PROPERTIES = 8
  FLAG_SAVE_BIG_ENDIAN = 16
  FLAG_COMPRESS = 32
  FLAG_REPLACE_SUBRESOURCE_PATHS = 64


class ResourceSaver(py4godot_object.Object):
  r'''
		A singleton for saving resource types to the filesystem.
		It uses the many `ResourceFormatSaver` classes registered in the engine (either built-in or from a plugin) to save resource data to text-based (e.g. `.tres` or `.tscn`) or binary files (e.g. `.res` or `.scn`).
	'''


  def generate_wrapper(self):
    return CPPResourceSaverWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ResourceSaver.__new__(ResourceSaver)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ResourceSaver'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ResourceSaver.construct_without_init()
    cls._ptr = CPPResourceSaverWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ResourceSaver.construct_without_init()
    cls._ptr = CPPResourceSaverWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _ResourceSaver_singleton_instance
    if _ResourceSaver_singleton_instance is None:
      singleton = ResourceSaver()
      singleton._ptr = constructor(707,0, ())
      _ResourceSaver_singleton_instance = singleton
    return _ResourceSaver_singleton_instance

  @functools.native_method
  def save(self, resource:'py4godot_resource.Resource'   , path:'str' =""  , flags:'int' =0  ) -> typing.Union[int]:
    r'''
				Saves a resource to disk to the given path, using a `ResourceFormatSaver` that recognizes the resource object. If `path` is empty, `ResourceSaver` will try to use `Resource.resource_path`.
				The `flags` bitmask can be specified to customize the save behavior.
				Returns `constant OK` on success.
				**Note:** When the project is running, any generated UID associated with the resource will not be saved as the required code is only executed in editor mode.
			'''
    if path is None:
      path = String.new0()

    if path is None:
      path = String.new0()


    assert(not resource is None)
    assert isinstance(resource, get_class('Resource')), 'resource must be Resource'
    assert isinstance(flags, (int, float)), 'flags must be int or float'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(49,tuple([resource._ptr, py_string_path._ptr, flags]))
    return _ret


  @functools.native_method
  def set_uid(self, resource:'str'   , uid:'int'   ) -> typing.Union[int]:
    r'''
				Sets the UID of the given `resource` path to `uid`. You can generate a new UID using `ResourceUID.create_id`.
				Since resources will normally get a UID automatically, this method is only useful in very specific cases.
			'''

    assert(not resource is None)
    assert isinstance(resource, (str, String)), 'resource must be str or String'
    assert isinstance(uid, (int, float)), 'uid must be int or float'




    assert(isinstance(resource, (str, String)))
    py_string_resource = resource if isinstance(resource, StringName) else c_utils.py_string_to_string(resource)


    _ret:int
    _ret = self._ptr.call_with_return(50,tuple([py_string_resource._ptr, uid]))
    return _ret


  @functools.native_method
  def get_recognized_extensions(self, type:'py4godot_resource.Resource'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns the list of extensions available for saving a resource of a given type.
			'''

    assert(not type is None)
    assert isinstance(type, get_class('Resource')), 'type must be Resource'






    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([type._ptr]))
    return _ret


  @functools.native_method
  def add_resource_format_saver(self, format_saver:'py4godot_resourceformatsaver.ResourceFormatSaver'   , at_front:'bool' =False  ) -> None:
    r'''
				Registers a new `ResourceFormatSaver`. The ResourceSaver will use the ResourceFormatSaver as described in `save`.
				This method is performed implicitly for ResourceFormatSavers written in GDScript (see `ResourceFormatSaver` for more information).
			'''

    assert(not format_saver is None)
    assert isinstance(format_saver, get_class('ResourceFormatSaver')), 'format_saver must be ResourceFormatSaver'
    assert isinstance(at_front, bool), 'at_front must be bool'







    self._ptr.call_with_return(52,tuple([format_saver._ptr, at_front]))

  @functools.native_method
  def remove_resource_format_saver(self, format_saver:'py4godot_resourceformatsaver.ResourceFormatSaver'   ) -> None:
    r'''
				Unregisters the given `ResourceFormatSaver`.
			'''

    assert(not format_saver is None)
    assert isinstance(format_saver, get_class('ResourceFormatSaver')), 'format_saver must be ResourceFormatSaver'






    self._ptr.call_with_return(53,tuple([format_saver._ptr]))

  @functools.native_method
  def get_resource_id_for_path(self, path:'str'   , generate:'bool' =False  ) -> typing.Union[int]:
    r'''
				Returns the resource ID for the given path. If `generate` is `true`, a new resource ID will be generated if one for the path is not found. If `generate` is `false` and the path is not found, `constant ResourceUID.INVALID_ID` is returned.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(generate, bool), 'generate must be bool'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([py_string_path._ptr, generate]))
    return _ret



register_cast_function('ResourceSaver', ResourceSaver.cast)
register_class('ResourceSaver', ResourceSaver)
