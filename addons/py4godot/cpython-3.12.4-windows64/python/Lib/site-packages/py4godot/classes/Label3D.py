# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.SystemFont as py4godot_systemfont 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.FontFile as py4godot_fontfile 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.TriangleMesh as py4godot_trianglemesh 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.FontVariation as py4godot_fontvariation 
import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
from py4godot.wrappers.wrappers import CPPLabel3DWrapper

class DrawFlags:
  FLAG_SHADED = 0
  FLAG_DOUBLE_SIDED = 1
  FLAG_DISABLE_DEPTH_TEST = 2
  FLAG_FIXED_SIZE = 3
  FLAG_MAX = 4
class AlphaCutMode:
  ALPHA_CUT_DISABLED = 0
  ALPHA_CUT_DISCARD = 1
  ALPHA_CUT_OPAQUE_PREPASS = 2
  ALPHA_CUT_HASH = 3


class Label3D(py4godot_geometryinstance3d.GeometryInstance3D):
  r'''
		A node for displaying plain text in 3D space. By adjusting various properties of this node, you can configure things such as the text's appearance and whether it always faces the camera.
	'''

  @staticmethod
  def constructor():
    class_ = Label3D.construct_without_init()
    class_._ptr = constructor(447,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Label3D.construct_without_init()
    class_._ptr = constructor(447,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPLabel3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(447,0, ())


  def generate_wrapper(self):
    return CPPLabel3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Label3D.__new__(Label3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Label3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Label3D.construct_without_init()
    cls._ptr = CPPLabel3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Label3D.construct_without_init()
    cls._ptr = CPPLabel3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def pixel_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pixel_size()
    return _ret
  @pixel_size.setter
  def pixel_size(self,  value:'float'):
    self.set_pixel_size(value)
  @property
  def offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_offset()
    return _ret
  @offset.setter
  def offset(self,  value:'Vector2'):
    self.set_offset(value)
  @property
  def billboard(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_billboard_mode()
    return _ret
  @billboard.setter
  def billboard(self,  value:'int'):
    self.set_billboard_mode(value)
  @property
  def shaded(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(0)
    return _ret
  @shaded.setter
  def shaded(self,  value:'bool'):
    self.set_draw_flag(value)
  @property
  def double_sided(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(1)
    return _ret
  @double_sided.setter
  def double_sided(self,  value:'bool'):
    self.set_draw_flag(value)
  @property
  def no_depth_test(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(2)
    return _ret
  @no_depth_test.setter
  def no_depth_test(self,  value:'bool'):
    self.set_draw_flag(value)
  @property
  def fixed_size(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(3)
    return _ret
  @fixed_size.setter
  def fixed_size(self,  value:'bool'):
    self.set_draw_flag(value)
  @property
  def alpha_cut(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_alpha_cut_mode()
    return _ret
  @alpha_cut.setter
  def alpha_cut(self,  value:'int'):
    self.set_alpha_cut_mode(value)
  @property
  def alpha_scissor_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_scissor_threshold()
    return _ret
  @alpha_scissor_threshold.setter
  def alpha_scissor_threshold(self,  value:'float'):
    self.set_alpha_scissor_threshold(value)
  @property
  def alpha_hash_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_hash_scale()
    return _ret
  @alpha_hash_scale.setter
  def alpha_hash_scale(self,  value:'float'):
    self.set_alpha_hash_scale(value)
  @property
  def alpha_antialiasing_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_alpha_antialiasing()
    return _ret
  @alpha_antialiasing_mode.setter
  def alpha_antialiasing_mode(self,  value:'int'):
    self.set_alpha_antialiasing(value)
  @property
  def alpha_antialiasing_edge(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_antialiasing_edge()
    return _ret
  @alpha_antialiasing_edge.setter
  def alpha_antialiasing_edge(self,  value:'float'):
    self.set_alpha_antialiasing_edge(value)
  @property
  def texture_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_texture_filter()
    return _ret
  @texture_filter.setter
  def texture_filter(self,  value:'int'):
    self.set_texture_filter(value)
  @property
  def render_priority(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_render_priority()
    return _ret
  @render_priority.setter
  def render_priority(self,  value:'int'):
    self.set_render_priority(value)
  @property
  def outline_render_priority(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_outline_render_priority()
    return _ret
  @outline_render_priority.setter
  def outline_render_priority(self,  value:'int'):
    self.set_outline_render_priority(value)
  @property
  def modulate(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_modulate()
    return _ret
  @modulate.setter
  def modulate(self,  value:'Color'):
    self.set_modulate(value)
  @property
  def outline_modulate(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_outline_modulate()
    return _ret
  @outline_modulate.setter
  def outline_modulate(self,  value:'Color'):
    self.set_outline_modulate(value)
  @property
  def text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_text()
    return _ret
  @text.setter
  def text(self,  value:'str'):
    self.set_text(value)
  @property
  def font(self) -> typing.Union['py4godot_font.Font','py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation']:
    r''''''
    _ret = self. get_font()
    return _ret
  @font.setter
  def font(self,  value:'py4godot_object.Object'):
    self.set_font(value)
  @property
  def font_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_font_size()
    return _ret
  @font_size.setter
  def font_size(self,  value:'int'):
    self.set_font_size(value)
  @property
  def outline_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_outline_size()
    return _ret
  @outline_size.setter
  def outline_size(self,  value:'int'):
    self.set_outline_size(value)
  @property
  def horizontal_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_alignment()
    return _ret
  @horizontal_alignment.setter
  def horizontal_alignment(self,  value:'int'):
    self.set_horizontal_alignment(value)
  @property
  def vertical_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_vertical_alignment()
    return _ret
  @vertical_alignment.setter
  def vertical_alignment(self,  value:'int'):
    self.set_vertical_alignment(value)
  @property
  def uppercase(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_uppercase()
    return _ret
  @uppercase.setter
  def uppercase(self,  value:'bool'):
    self.set_uppercase(value)
  @property
  def line_spacing(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_line_spacing()
    return _ret
  @line_spacing.setter
  def line_spacing(self,  value:'float'):
    self.set_line_spacing(value)
  @property
  def autowrap_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_autowrap_mode()
    return _ret
  @autowrap_mode.setter
  def autowrap_mode(self,  value:'int'):
    self.set_autowrap_mode(value)
  @property
  def autowrap_trim_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_autowrap_trim_flags()
    return _ret
  @autowrap_trim_flags.setter
  def autowrap_trim_flags(self,  value:'int'):
    self.set_autowrap_trim_flags(value)
  @property
  def justification_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_justification_flags()
    return _ret
  @justification_flags.setter
  def justification_flags(self,  value:'int'):
    self.set_justification_flags(value)
  @property
  def width(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_width()
    return _ret
  @width.setter
  def width(self,  value:'float'):
    self.set_width(value)
  @property
  def text_direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_direction()
    return _ret
  @text_direction.setter
  def text_direction(self,  value:'int'):
    self.set_text_direction(value)
  @property
  def language(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_language()
    return _ret
  @language.setter
  def language(self,  value:'str'):
    self.set_language(value)
  @property
  def structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_structured_text_bidi_override()
    return _ret
  @structured_text_bidi_override.setter
  def structured_text_bidi_override(self,  value:'int'):
    self.set_structured_text_bidi_override(value)
  @property
  def structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_structured_text_bidi_override_options()
    return _ret
  @structured_text_bidi_override_options.setter
  def structured_text_bidi_override_options(self,  value:'Array'):
    self.set_structured_text_bidi_override_options(value)
  @functools.native_method
  def set_horizontal_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'

    self.py__horizontal_alignment = alignment






    self._ptr.call_with_return(298,tuple([alignment]))

  @functools.native_method
  def get_horizontal_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(299,tuple([]))

    return _ret


  @functools.native_method
  def set_vertical_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'

    self.py__vertical_alignment = alignment






    self._ptr.call_with_return(300,tuple([alignment]))

  @functools.native_method
  def get_vertical_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(301,tuple([]))

    return _ret


  @functools.native_method
  def set_modulate(self, modulate:'Color'   ) -> None:
    r''''''

    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'

    self.py__modulate = modulate






    self._ptr.call_with_return(302,tuple([modulate._ptr]))

  @functools.native_method
  def get_modulate(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(303,tuple([]))

    return _ret


  @functools.native_method
  def set_outline_modulate(self, modulate:'Color'   ) -> None:
    r''''''

    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'

    self.py__outline_modulate = modulate






    self._ptr.call_with_return(304,tuple([modulate._ptr]))

  @functools.native_method
  def get_outline_modulate(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def set_text(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'

    self.py__text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(306,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(307,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_text_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'

    self.py__text_direction = direction






    self._ptr.call_with_return(308,tuple([direction]))

  @functools.native_method
  def get_text_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(309,tuple([]))

    return _ret


  @functools.native_method
  def set_language(self, language:'str'   ) -> None:
    r''''''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'

    self.py__language = language



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    py__string_language = utils.py_string_to_string(language)
    py__string_language.shouldBeDeleted = False


    self._ptr.call_with_return(310,tuple([py__string_language._ptr]))

  @functools.native_method
  def get_language(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(311,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_structured_text_bidi_override(self, parser:'int'  ) -> None:
    r''''''

    assert isinstance(parser, (int, float)), 'parser must be int or float'

    self.py__structured_text_bidi_override = parser






    self._ptr.call_with_return(312,tuple([parser]))

  @functools.native_method
  def get_structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def set_structured_text_bidi_override_options(self, args:'Array'   ) -> None:
    r''''''

    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'

    self.py__structured_text_bidi_override_options = args






    self._ptr.call_with_return(314,tuple([args._ptr]))

  @functools.native_method
  def get_structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(315,tuple([]))

    return _ret


  @functools.native_method
  def set_uppercase(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__uppercase = enable






    self._ptr.call_with_return(316,tuple([enable]))

  @functools.native_method
  def is_uppercase(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def set_render_priority(self, priority:'int'   ) -> None:
    r''''''

    assert isinstance(priority, (int, float)), 'priority must be int or float'

    self.py__render_priority = priority






    self._ptr.call_with_return(318,tuple([priority]))

  @functools.native_method
  def get_render_priority(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def set_outline_render_priority(self, priority:'int'   ) -> None:
    r''''''

    assert isinstance(priority, (int, float)), 'priority must be int or float'

    self.py__outline_render_priority = priority






    self._ptr.call_with_return(320,tuple([priority]))

  @functools.native_method
  def get_outline_render_priority(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def set_font(self, font:'py4godot_font.Font'   ) -> None:
    r''''''

    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'

    self.py__font = font






    self._ptr.call_with_return(322,tuple([font._ptr]))

  @functools.native_method
  def get_font(self) -> typing.Union['py4godot_font.Font','py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(323,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_font_size(self, size:'int'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'

    self.py__font_size = size






    self._ptr.call_with_return(324,tuple([size]))

  @functools.native_method
  def get_font_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([]))

    return _ret


  @functools.native_method
  def set_outline_size(self, outline_size:'int'   ) -> None:
    r''''''

    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'

    self.py__outline_size = outline_size






    self._ptr.call_with_return(326,tuple([outline_size]))

  @functools.native_method
  def get_outline_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(327,tuple([]))

    return _ret


  @functools.native_method
  def set_line_spacing(self, line_spacing:'float'   ) -> None:
    r''''''

    assert isinstance(line_spacing, (int, float)), 'line_spacing must be int or float'

    self.py__line_spacing = line_spacing






    self._ptr.call_with_return(328,tuple([line_spacing]))

  @functools.native_method
  def get_line_spacing(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([]))

    return _ret


  @functools.native_method
  def set_autowrap_mode(self, autowrap_mode:'int'  ) -> None:
    r''''''

    assert isinstance(autowrap_mode, (int, float)), 'autowrap_mode must be int or float'

    self.py__autowrap_mode = autowrap_mode






    self._ptr.call_with_return(330,tuple([autowrap_mode]))

  @functools.native_method
  def get_autowrap_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(331,tuple([]))

    return _ret


  @functools.native_method
  def set_autowrap_trim_flags(self, autowrap_trim_flags:'int'   ) -> None:
    r''''''

    assert isinstance(autowrap_trim_flags, (int, float)), 'autowrap_trim_flags must be int or float'

    self.py__autowrap_trim_flags = autowrap_trim_flags






    self._ptr.call_with_return(332,tuple([autowrap_trim_flags]))

  @functools.native_method
  def get_autowrap_trim_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(333,tuple([]))

    return _ret


  @functools.native_method
  def set_justification_flags(self, justification_flags:'int'   ) -> None:
    r''''''

    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'

    self.py__justification_flags = justification_flags






    self._ptr.call_with_return(334,tuple([justification_flags]))

  @functools.native_method
  def get_justification_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(335,tuple([]))

    return _ret


  @functools.native_method
  def set_width(self, width:'float'   ) -> None:
    r''''''

    assert isinstance(width, (int, float)), 'width must be int or float'

    self.py__width = width






    self._ptr.call_with_return(336,tuple([width]))

  @functools.native_method
  def get_width(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(337,tuple([]))

    return _ret


  @functools.native_method
  def set_pixel_size(self, pixel_size:'float'   ) -> None:
    r''''''

    assert isinstance(pixel_size, (int, float)), 'pixel_size must be int or float'

    self.py__pixel_size = pixel_size






    self._ptr.call_with_return(338,tuple([pixel_size]))

  @functools.native_method
  def get_pixel_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(339,tuple([]))

    return _ret


  @functools.native_method
  def set_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'

    self.py__offset = offset






    self._ptr.call_with_return(340,tuple([offset._ptr]))

  @functools.native_method
  def get_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(341,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_flag(self, flag:'int'  , enabled:'bool'   ) -> None:
    r'''
				If `true`, the specified `flag` will be enabled.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__shaded = flag







    self._ptr.call_with_return(342,tuple([flag, enabled]))

  @functools.native_method
  def get_draw_flag(self, flag:'int'  ) -> typing.Union[bool]:
    r'''
				Returns the value of the specified flag.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(343,tuple([flag]))

    return _ret


  @functools.native_method
  def set_billboard_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__billboard = mode






    self._ptr.call_with_return(344,tuple([mode]))

  @functools.native_method
  def get_billboard_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(345,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_cut_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__alpha_cut = mode






    self._ptr.call_with_return(346,tuple([mode]))

  @functools.native_method
  def get_alpha_cut_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(347,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_scissor_threshold(self, threshold:'float'   ) -> None:
    r''''''

    assert isinstance(threshold, (int, float)), 'threshold must be int or float'

    self.py__alpha_scissor_threshold = threshold






    self._ptr.call_with_return(348,tuple([threshold]))

  @functools.native_method
  def get_alpha_scissor_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(349,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_hash_scale(self, threshold:'float'   ) -> None:
    r''''''

    assert isinstance(threshold, (int, float)), 'threshold must be int or float'

    self.py__alpha_hash_scale = threshold






    self._ptr.call_with_return(350,tuple([threshold]))

  @functools.native_method
  def get_alpha_hash_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(351,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_antialiasing(self, alpha_aa:'int'  ) -> None:
    r''''''

    assert isinstance(alpha_aa, (int, float)), 'alpha_aa must be int or float'

    self.py__alpha_antialiasing_mode = alpha_aa






    self._ptr.call_with_return(352,tuple([alpha_aa]))

  @functools.native_method
  def get_alpha_antialiasing(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(353,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_antialiasing_edge(self, edge:'float'   ) -> None:
    r''''''

    assert isinstance(edge, (int, float)), 'edge must be int or float'

    self.py__alpha_antialiasing_edge = edge






    self._ptr.call_with_return(354,tuple([edge]))

  @functools.native_method
  def get_alpha_antialiasing_edge(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(355,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_filter(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__texture_filter = mode






    self._ptr.call_with_return(356,tuple([mode]))

  @functools.native_method
  def get_texture_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(357,tuple([]))

    return _ret


  @functools.native_method
  def generate_triangle_mesh(self) -> typing.Union['py4godot_trianglemesh.TriangleMesh']:
    r'''
				Returns a `TriangleMesh` with the label's vertices following its current configuration (such as its `pixel_size`).
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TriangleMesh
    _ret._ptr = self._ptr.call_with_return(358,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('Label3D', Label3D.cast)
register_class('Label3D', Label3D)
