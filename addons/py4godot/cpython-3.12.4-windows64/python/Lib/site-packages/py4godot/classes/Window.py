# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.StyleBoxTexture as py4godot_styleboxtexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.FileDialog as py4godot_filedialog 
  import py4godot.classes.StyleBox as py4godot_stylebox 
  import py4godot.classes.SystemFont as py4godot_systemfont 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.DisplayServer as py4godot_displayserver 
  import py4godot.classes.EditorCommandPalette as py4godot_editorcommandpalette 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.AcceptDialog as py4godot_acceptdialog 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.StyleBoxLine as py4godot_styleboxline 
  import py4godot.classes.ScriptCreateDialog as py4godot_scriptcreatedialog 
  import py4godot.classes.FontVariation as py4godot_fontvariation 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.Theme as py4godot_theme 
  import py4godot.classes.EditorFileDialog as py4godot_editorfiledialog 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.FontFile as py4godot_fontfile 
  import py4godot.classes.Popup as py4godot_popup 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.StyleBoxFlat as py4godot_styleboxflat 
  import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.PopupPanel as py4godot_popuppanel 
  import py4godot.classes.StyleBoxEmpty as py4godot_styleboxempty 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.Viewport as py4godot_viewport 
from py4godot.wrappers.wrappers import CPPWindowWrapper

class Mode:
  MODE_WINDOWED = 0
  MODE_MINIMIZED = 1
  MODE_MAXIMIZED = 2
  MODE_FULLSCREEN = 3
  MODE_EXCLUSIVE_FULLSCREEN = 4
class Flags:
  FLAG_RESIZE_DISABLED = 0
  FLAG_BORDERLESS = 1
  FLAG_ALWAYS_ON_TOP = 2
  FLAG_TRANSPARENT = 3
  FLAG_NO_FOCUS = 4
  FLAG_POPUP = 5
  FLAG_EXTEND_TO_TITLE = 6
  FLAG_MOUSE_PASSTHROUGH = 7
  FLAG_SHARP_CORNERS = 8
  FLAG_EXCLUDE_FROM_CAPTURE = 9
  FLAG_POPUP_WM_HINT = 10
  FLAG_MINIMIZE_DISABLED = 11
  FLAG_MAXIMIZE_DISABLED = 12
  FLAG_MAX = 13
class ContentScaleMode:
  CONTENT_SCALE_MODE_DISABLED = 0
  CONTENT_SCALE_MODE_CANVAS_ITEMS = 1
  CONTENT_SCALE_MODE_VIEWPORT = 2
class ContentScaleAspect:
  CONTENT_SCALE_ASPECT_IGNORE = 0
  CONTENT_SCALE_ASPECT_KEEP = 1
  CONTENT_SCALE_ASPECT_KEEP_WIDTH = 2
  CONTENT_SCALE_ASPECT_KEEP_HEIGHT = 3
  CONTENT_SCALE_ASPECT_EXPAND = 4
class ContentScaleStretch:
  CONTENT_SCALE_STRETCH_FRACTIONAL = 0
  CONTENT_SCALE_STRETCH_INTEGER = 1
class LayoutDirection:
  LAYOUT_DIRECTION_INHERITED = 0
  LAYOUT_DIRECTION_APPLICATION_LOCALE = 1
  LAYOUT_DIRECTION_LTR = 2
  LAYOUT_DIRECTION_RTL = 3
  LAYOUT_DIRECTION_SYSTEM_LOCALE = 4
  LAYOUT_DIRECTION_MAX = 5
  LAYOUT_DIRECTION_LOCALE = 1
class WindowInitialPosition:
  WINDOW_INITIAL_POSITION_ABSOLUTE = 0
  WINDOW_INITIAL_POSITION_CENTER_PRIMARY_SCREEN = 1
  WINDOW_INITIAL_POSITION_CENTER_MAIN_WINDOW_SCREEN = 2
  WINDOW_INITIAL_POSITION_CENTER_OTHER_SCREEN = 3
  WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_MOUSE_FOCUS = 4
  WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_KEYBOARD_FOCUS = 5


class Window(py4godot_viewport.Viewport):
  r'''
		A node that creates a window. The window can either be a native system window or embedded inside another `Window` (see `Viewport.gui_embed_subwindows`).
		At runtime, `Window`s will not close automatically when requested. You need to handle it manually using the `signal close_requested` signal (this applies both to pressing the close button and clicking outside of a popup).
	'''
  NOTIFICATION_VISIBILITY_CHANGED:typing.ClassVar[int]

  NOTIFICATION_THEME_CHANGED:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = Window.construct_without_init()
    class_._ptr = constructor(1002,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Window.construct_without_init()
    class_._ptr = constructor(1002,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPWindowWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(1002,0, ())


  def generate_wrapper(self):
    return CPPWindowWrapper()
  def init_signals(self):
    super().init_signals()
    window_input_name = utils.py_string_to_string_name("window_input")
    self.window_input = signals.BuiltinSignal(self, window_input_name)
    files_dropped_name = utils.py_string_to_string_name("files_dropped")
    self.files_dropped = signals.BuiltinSignal(self, files_dropped_name)
    mouse_entered_name = utils.py_string_to_string_name("mouse_entered")
    self.mouse_entered = signals.BuiltinSignal(self, mouse_entered_name)
    mouse_exited_name = utils.py_string_to_string_name("mouse_exited")
    self.mouse_exited = signals.BuiltinSignal(self, mouse_exited_name)
    focus_entered_name = utils.py_string_to_string_name("focus_entered")
    self.focus_entered = signals.BuiltinSignal(self, focus_entered_name)
    focus_exited_name = utils.py_string_to_string_name("focus_exited")
    self.focus_exited = signals.BuiltinSignal(self, focus_exited_name)
    close_requested_name = utils.py_string_to_string_name("close_requested")
    self.close_requested = signals.BuiltinSignal(self, close_requested_name)
    go_back_requested_name = utils.py_string_to_string_name("go_back_requested")
    self.go_back_requested = signals.BuiltinSignal(self, go_back_requested_name)
    visibility_changed_name = utils.py_string_to_string_name("visibility_changed")
    self.visibility_changed = signals.BuiltinSignal(self, visibility_changed_name)
    about_to_popup_name = utils.py_string_to_string_name("about_to_popup")
    self.about_to_popup = signals.BuiltinSignal(self, about_to_popup_name)
    theme_changed_name = utils.py_string_to_string_name("theme_changed")
    self.theme_changed = signals.BuiltinSignal(self, theme_changed_name)
    dpi_changed_name = utils.py_string_to_string_name("dpi_changed")
    self.dpi_changed = signals.BuiltinSignal(self, dpi_changed_name)
    titlebar_changed_name = utils.py_string_to_string_name("titlebar_changed")
    self.titlebar_changed = signals.BuiltinSignal(self, titlebar_changed_name)
    title_changed_name = utils.py_string_to_string_name("title_changed")
    self.title_changed = signals.BuiltinSignal(self, title_changed_name)

  @staticmethod
  def construct_without_init():
    cls = Window.__new__(Window)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Window'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Window.construct_without_init()
    cls._ptr = CPPWindowWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Window.construct_without_init()
    cls._ptr = CPPWindowWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_mode()
    return _ret
  @mode.setter
  def mode(self,  value:'int'):
    self.set_mode(value)
  @property
  def title(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_title()
    return _ret
  @title.setter
  def title(self,  value:'str'):
    self.set_title(value)
  @property
  def initial_position(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_initial_position()
    return _ret
  @initial_position.setter
  def initial_position(self,  value:'int'):
    self.set_initial_position(value)
  @property
  def position(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_position()
    return _ret
  @position.setter
  def position(self,  value:'Vector2i'):
    self.set_position(value)
  @property
  def size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'Vector2i'):
    self.set_size(value)
  @property
  def current_screen(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_current_screen()
    return _ret
  @current_screen.setter
  def current_screen(self,  value:'int'):
    self.set_current_screen(value)
  @property
  def mouse_passthrough_polygon(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_mouse_passthrough_polygon()
    return _ret
  @mouse_passthrough_polygon.setter
  def mouse_passthrough_polygon(self,  value:'PackedVector2Array'):
    self.set_mouse_passthrough_polygon(value)
  @property
  def visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_visible()
    return _ret
  @visible.setter
  def visible(self,  value:'bool'):
    self.set_visible(value)
  @property
  def wrap_controls(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_wrapping_controls()
    return _ret
  @wrap_controls.setter
  def wrap_controls(self,  value:'bool'):
    self.set_wrap_controls(value)
  @property
  def transient(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_transient()
    return _ret
  @transient.setter
  def transient(self,  value:'bool'):
    self.set_transient(value)
  @property
  def transient_to_focused(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_transient_to_focused()
    return _ret
  @transient_to_focused.setter
  def transient_to_focused(self,  value:'bool'):
    self.set_transient_to_focused(value)
  @property
  def exclusive(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_exclusive()
    return _ret
  @exclusive.setter
  def exclusive(self,  value:'bool'):
    self.set_exclusive(value)
  @property
  def unresizable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(0)
    return _ret
  @unresizable.setter
  def unresizable(self,  value:'bool'):
    self.set_flag(value)
  @property
  def borderless(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(1)
    return _ret
  @borderless.setter
  def borderless(self,  value:'bool'):
    self.set_flag(value)
  @property
  def always_on_top(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(2)
    return _ret
  @always_on_top.setter
  def always_on_top(self,  value:'bool'):
    self.set_flag(value)
  @property
  def transparent(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(3)
    return _ret
  @transparent.setter
  def transparent(self,  value:'bool'):
    self.set_flag(value)
  @property
  def unfocusable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(4)
    return _ret
  @unfocusable.setter
  def unfocusable(self,  value:'bool'):
    self.set_flag(value)
  @property
  def popup_window(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(5)
    return _ret
  @popup_window.setter
  def popup_window(self,  value:'bool'):
    self.set_flag(value)
  @property
  def extend_to_title(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(6)
    return _ret
  @extend_to_title.setter
  def extend_to_title(self,  value:'bool'):
    self.set_flag(value)
  @property
  def mouse_passthrough(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(7)
    return _ret
  @mouse_passthrough.setter
  def mouse_passthrough(self,  value:'bool'):
    self.set_flag(value)
  @property
  def sharp_corners(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(8)
    return _ret
  @sharp_corners.setter
  def sharp_corners(self,  value:'bool'):
    self.set_flag(value)
  @property
  def exclude_from_capture(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(9)
    return _ret
  @exclude_from_capture.setter
  def exclude_from_capture(self,  value:'bool'):
    self.set_flag(value)
  @property
  def popup_wm_hint(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(10)
    return _ret
  @popup_wm_hint.setter
  def popup_wm_hint(self,  value:'bool'):
    self.set_flag(value)
  @property
  def minimize_disabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(11)
    return _ret
  @minimize_disabled.setter
  def minimize_disabled(self,  value:'bool'):
    self.set_flag(value)
  @property
  def maximize_disabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(12)
    return _ret
  @maximize_disabled.setter
  def maximize_disabled(self,  value:'bool'):
    self.set_flag(value)
  @property
  def force_native(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_force_native()
    return _ret
  @force_native.setter
  def force_native(self,  value:'bool'):
    self.set_force_native(value)
  @property
  def min_size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_min_size()
    return _ret
  @min_size.setter
  def min_size(self,  value:'Vector2i'):
    self.set_min_size(value)
  @property
  def max_size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_max_size()
    return _ret
  @max_size.setter
  def max_size(self,  value:'Vector2i'):
    self.set_max_size(value)
  @property
  def keep_title_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_keep_title_visible()
    return _ret
  @keep_title_visible.setter
  def keep_title_visible(self,  value:'bool'):
    self.set_keep_title_visible(value)
  @property
  def content_scale_size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_content_scale_size()
    return _ret
  @content_scale_size.setter
  def content_scale_size(self,  value:'Vector2i'):
    self.set_content_scale_size(value)
  @property
  def content_scale_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_content_scale_mode()
    return _ret
  @content_scale_mode.setter
  def content_scale_mode(self,  value:'int'):
    self.set_content_scale_mode(value)
  @property
  def content_scale_aspect(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_content_scale_aspect()
    return _ret
  @content_scale_aspect.setter
  def content_scale_aspect(self,  value:'int'):
    self.set_content_scale_aspect(value)
  @property
  def content_scale_stretch(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_content_scale_stretch()
    return _ret
  @content_scale_stretch.setter
  def content_scale_stretch(self,  value:'int'):
    self.set_content_scale_stretch(value)
  @property
  def content_scale_factor(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_content_scale_factor()
    return _ret
  @content_scale_factor.setter
  def content_scale_factor(self,  value:'float'):
    self.set_content_scale_factor(value)
  @property
  def auto_translate(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_auto_translating()
    return _ret
  @auto_translate.setter
  def auto_translate(self,  value:'bool'):
    self.set_auto_translate(value)
  @property
  def accessibility_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_accessibility_name()
    return _ret
  @accessibility_name.setter
  def accessibility_name(self,  value:'str'):
    self.set_accessibility_name(value)
  @property
  def accessibility_description(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_accessibility_description()
    return _ret
  @accessibility_description.setter
  def accessibility_description(self,  value:'str'):
    self.set_accessibility_description(value)
  @property
  def theme(self) -> typing.Union['py4godot_theme.Theme']:
    r''''''
    _ret = self. get_theme()
    return _ret
  @theme.setter
  def theme(self,  value:'py4godot_object.Object'):
    self.set_theme(value)
  @property
  def theme_type_variation(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_theme_type_variation()
    return _ret
  @theme_type_variation.setter
  def theme_type_variation(self,  value:'str'):
    self.set_theme_type_variation(value)
  @functools.native_method
  def _get_contents_minimum_size(self) -> typing.Union['Vector2']:
    r'''
				Virtual method to be implemented by the user. Overrides the value returned by `get_contents_minimum_size`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(308,tuple([]))
    return _ret


  @functools.native_method
  def set_title(self, title:'str'   ) -> None:
    r''''''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'

    self.py__title = title



    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)

    py__string_title = utils.py_string_to_string(title)
    py__string_title.shouldBeDeleted = False


    self._ptr.call_with_return(309,tuple([py__string_title._ptr]))

  @functools.native_method
  def get_title(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(310,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_initial_position(self, initial_position:'int'  ) -> None:
    r''''''

    assert isinstance(initial_position, (int, float)), 'initial_position must be int or float'

    self.py__initial_position = initial_position






    self._ptr.call_with_return(311,tuple([initial_position]))

  @functools.native_method
  def get_initial_position(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(312,tuple([]))

    return _ret


  @functools.native_method
  def set_current_screen(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'

    self.py__current_screen = index






    self._ptr.call_with_return(313,tuple([index]))

  @functools.native_method
  def get_current_screen(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(314,tuple([]))

    return _ret


  @functools.native_method
  def set_position(self, position:'Vector2i'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'

    self.py__position = position






    self._ptr.call_with_return(315,tuple([position._ptr]))

  @functools.native_method
  def get_position(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(316,tuple([]))

    return _ret


  @functools.native_method
  def move_to_center(self) -> None:
    r'''
				Centers a native window on the current screen and an embedded window on its embedder `Viewport`.
			'''




    self._ptr.call_with_return(317,tuple([]))

  @functools.native_method
  def set_size(self, size:'Vector2i'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'

    self.py__size = size






    self._ptr.call_with_return(318,tuple([size._ptr]))

  @functools.native_method
  def get_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def reset_size(self) -> None:
    r'''
				Resets the size to the minimum size, which is the max of `min_size` and (if `wrap_controls` is enabled) `get_contents_minimum_size`. This is equivalent to calling `set_size(Vector2i())` (or any size below the minimum).
			'''




    self._ptr.call_with_return(320,tuple([]))

  @functools.native_method
  def get_position_with_decorations(self) -> typing.Union['Vector2i']:
    r'''
				Returns the window's position including its border.
				**Note:** If `visible` is `false`, this method returns the same value as `position`.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(321,tuple([]))
    return _ret


  @functools.native_method
  def get_size_with_decorations(self) -> typing.Union['Vector2i']:
    r'''
				Returns the window's size including its border.
				**Note:** If `visible` is `false`, this method returns the same value as `size`.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(322,tuple([]))
    return _ret


  @functools.native_method
  def set_max_size(self, max_size:'Vector2i'   ) -> None:
    r''''''

    assert(not max_size is None)
    assert isinstance(max_size, Vector2i), 'max_size must be Vector2i'

    self.py__max_size = max_size






    self._ptr.call_with_return(323,tuple([max_size._ptr]))

  @functools.native_method
  def get_max_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(324,tuple([]))

    return _ret


  @functools.native_method
  def set_min_size(self, min_size:'Vector2i'   ) -> None:
    r''''''

    assert(not min_size is None)
    assert isinstance(min_size, Vector2i), 'min_size must be Vector2i'

    self.py__min_size = min_size






    self._ptr.call_with_return(325,tuple([min_size._ptr]))

  @functools.native_method
  def get_min_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(326,tuple([]))

    return _ret


  @functools.native_method
  def set_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__mode = mode






    self._ptr.call_with_return(327,tuple([mode]))

  @functools.native_method
  def get_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(328,tuple([]))

    return _ret


  @functools.native_method
  def set_flag(self, flag:'int'  , enabled:'bool'   ) -> None:
    r'''
				Sets a specified window flag.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__unresizable = flag







    self._ptr.call_with_return(329,tuple([flag, enabled]))

  @functools.native_method
  def get_flag(self, flag:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `flag` is set.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(330,tuple([flag]))

    return _ret


  @functools.native_method
  def is_maximize_allowed(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the window can be maximized (the maximize button is enabled).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(331,tuple([]))
    return _ret


  @functools.native_method
  def request_attention(self) -> None:
    r'''
				Tells the OS that the `Window` needs an attention. This makes the window stand out in some way depending on the system, e.g. it might blink on the task bar.
			'''




    self._ptr.call_with_return(332,tuple([]))

  @functools.native_method
  def move_to_foreground(self) -> None:
    r'''
				Causes the window to grab focus, allowing it to receive user input.
			'''




    self._ptr.call_with_return(333,tuple([]))

  @functools.native_method
  def set_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'

    self.py__visible = visible






    self._ptr.call_with_return(334,tuple([visible]))

  @functools.native_method
  def is_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(335,tuple([]))

    return _ret


  @functools.native_method
  def hide(self) -> None:
    r'''
				Hides the window. This is not the same as minimized state. Hidden window can't be interacted with and needs to be made visible with `show`.
			'''




    self._ptr.call_with_return(336,tuple([]))

  @functools.native_method
  def show(self) -> None:
    r'''
				Makes the `Window` appear. This enables interactions with the `Window` and doesn't change any of its property other than visibility (unlike e.g. `popup`).
			'''




    self._ptr.call_with_return(337,tuple([]))

  @functools.native_method
  def set_transient(self, transient:'bool'   ) -> None:
    r''''''

    assert isinstance(transient, bool), 'transient must be bool'

    self.py__transient = transient






    self._ptr.call_with_return(338,tuple([transient]))

  @functools.native_method
  def is_transient(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(339,tuple([]))

    return _ret


  @functools.native_method
  def set_transient_to_focused(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__transient_to_focused = enable






    self._ptr.call_with_return(340,tuple([enable]))

  @functools.native_method
  def is_transient_to_focused(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(341,tuple([]))

    return _ret


  @functools.native_method
  def set_exclusive(self, exclusive:'bool'   ) -> None:
    r''''''

    assert isinstance(exclusive, bool), 'exclusive must be bool'

    self.py__exclusive = exclusive






    self._ptr.call_with_return(342,tuple([exclusive]))

  @functools.native_method
  def is_exclusive(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(343,tuple([]))

    return _ret


  @functools.native_method
  def set_unparent_when_invisible(self, unparent:'bool'   ) -> None:
    r'''
				If `unparent` is `true`, the window is automatically unparented when going invisible.
				**Note:** Make sure to keep a reference to the node, otherwise it will be orphaned. You also need to manually call `Node.queue_free` to free the window if it's not parented.
			'''

    assert isinstance(unparent, bool), 'unparent must be bool'






    self._ptr.call_with_return(344,tuple([unparent]))

  @functools.native_method
  def can_draw(self) -> typing.Union[bool]:
    r'''
				Returns whether the window is being drawn to the screen.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(345,tuple([]))
    return _ret


  @functools.native_method
  def has_focus(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the window is focused.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(346,tuple([]))
    return _ret


  @functools.native_method
  def grab_focus(self) -> None:
    r'''
				Causes the window to grab focus, allowing it to receive user input.
			'''




    self._ptr.call_with_return(347,tuple([]))

  @functools.native_method
  def start_drag(self) -> None:
    r'''
				Starts an interactive drag operation on the window, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's title bar. Using this method allows the window to participate in space switching, tiling, and other system features.
			'''




    self._ptr.call_with_return(348,tuple([]))

  @functools.native_method
  def start_resize(self, edge:'int'  ) -> None:
    r'''
				Starts an interactive resize operation on the window, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's edge.
			'''

    assert isinstance(edge, (int, float)), 'edge must be int or float'






    self._ptr.call_with_return(349,tuple([edge]))

  @functools.native_method
  def set_ime_active(self, active:'bool'   ) -> None:
    r'''
				If `active` is `true`, enables system's native IME (Input Method Editor).
			'''

    assert isinstance(active, bool), 'active must be bool'






    self._ptr.call_with_return(350,tuple([active]))

  @functools.native_method
  def set_ime_position(self, position:'Vector2i'   ) -> None:
    r'''
				Moves IME to the given position.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'






    self._ptr.call_with_return(351,tuple([position._ptr]))

  @functools.native_method
  def is_embedded(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the window is currently embedded in another window.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(352,tuple([]))
    return _ret


  @functools.native_method
  def get_contents_minimum_size(self) -> typing.Union['Vector2']:
    r'''
				Returns the combined minimum size from the child `Control` nodes of the window. Use `child_controls_changed` to update it when child nodes have changed.
				The value returned by this method can be overridden with `_get_contents_minimum_size`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(353,tuple([]))
    return _ret


  @functools.native_method
  def set_force_native(self, force_native:'bool'   ) -> None:
    r''''''

    assert isinstance(force_native, bool), 'force_native must be bool'

    self.py__force_native = force_native






    self._ptr.call_with_return(354,tuple([force_native]))

  @functools.native_method
  def get_force_native(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(355,tuple([]))

    return _ret


  @functools.native_method
  def set_content_scale_size(self, size:'Vector2i'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'

    self.py__content_scale_size = size






    self._ptr.call_with_return(356,tuple([size._ptr]))

  @functools.native_method
  def get_content_scale_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(357,tuple([]))

    return _ret


  @functools.native_method
  def set_content_scale_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__content_scale_mode = mode






    self._ptr.call_with_return(358,tuple([mode]))

  @functools.native_method
  def get_content_scale_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(359,tuple([]))

    return _ret


  @functools.native_method
  def set_content_scale_aspect(self, aspect:'int'  ) -> None:
    r''''''

    assert isinstance(aspect, (int, float)), 'aspect must be int or float'

    self.py__content_scale_aspect = aspect






    self._ptr.call_with_return(360,tuple([aspect]))

  @functools.native_method
  def get_content_scale_aspect(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(361,tuple([]))

    return _ret


  @functools.native_method
  def set_content_scale_stretch(self, stretch:'int'  ) -> None:
    r''''''

    assert isinstance(stretch, (int, float)), 'stretch must be int or float'

    self.py__content_scale_stretch = stretch






    self._ptr.call_with_return(362,tuple([stretch]))

  @functools.native_method
  def get_content_scale_stretch(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(363,tuple([]))

    return _ret


  @functools.native_method
  def set_keep_title_visible(self, title_visible:'bool'   ) -> None:
    r''''''

    assert isinstance(title_visible, bool), 'title_visible must be bool'

    self.py__keep_title_visible = title_visible






    self._ptr.call_with_return(364,tuple([title_visible]))

  @functools.native_method
  def get_keep_title_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(365,tuple([]))

    return _ret


  @functools.native_method
  def set_content_scale_factor(self, factor:'float'   ) -> None:
    r''''''

    assert isinstance(factor, (int, float)), 'factor must be int or float'

    self.py__content_scale_factor = factor






    self._ptr.call_with_return(366,tuple([factor]))

  @functools.native_method
  def get_content_scale_factor(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(367,tuple([]))

    return _ret


  @functools.native_method
  def set_mouse_passthrough_polygon(self, polygon:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not polygon is None)
    assert isinstance(polygon, PackedVector2Array), 'polygon must be PackedVector2Array'

    self.py__mouse_passthrough_polygon = polygon






    self._ptr.call_with_return(368,tuple([polygon._ptr]))

  @functools.native_method
  def get_mouse_passthrough_polygon(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(369,tuple([]))

    return _ret


  @functools.native_method
  def set_wrap_controls(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__wrap_controls = enable






    self._ptr.call_with_return(370,tuple([enable]))

  @functools.native_method
  def is_wrapping_controls(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(371,tuple([]))

    return _ret


  @functools.native_method
  def child_controls_changed(self) -> None:
    r'''
				Requests an update of the `Window` size to fit underlying `Control` nodes.
			'''




    self._ptr.call_with_return(372,tuple([]))

  @functools.native_method
  def set_theme(self, theme:'py4godot_theme.Theme'   ) -> None:
    r''''''

    assert(not theme is None)
    assert isinstance(theme, get_class('Theme')), 'theme must be Theme'

    self.py__theme = theme






    self._ptr.call_with_return(373,tuple([theme._ptr]))

  @functools.native_method
  def get_theme(self) -> typing.Union['py4godot_theme.Theme']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Theme
    _ret._ptr = self._ptr.call_with_return(374,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_theme_type_variation(self, theme_type:'object'   ) -> None:
    r''''''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'

    self.py__theme_type_variation = theme_type



    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(375,tuple([py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_theme_type_variation(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(376,tuple([]))

    return _ret


  @functools.native_method
  def begin_bulk_theme_override(self) -> None:
    r'''
				Prevents `*_theme_*_override` methods from emitting `constant NOTIFICATION_THEME_CHANGED` until `end_bulk_theme_override` is called.
			'''




    self._ptr.call_with_return(377,tuple([]))

  @functools.native_method
  def end_bulk_theme_override(self) -> None:
    r'''
				Ends a bulk theme override update. See `begin_bulk_theme_override`.
			'''




    self._ptr.call_with_return(378,tuple([]))

  @functools.native_method
  def add_theme_icon_override(self, name:'object'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Creates a local override for a theme icon with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_icon_override`.
				See also `get_theme_icon`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(379,tuple([py_stringname_name._ptr, texture._ptr]))

  @functools.native_method
  def add_theme_stylebox_override(self, name:'object'   , stylebox:'py4godot_stylebox.StyleBox'   ) -> None:
    r'''
				Creates a local override for a theme `StyleBox` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_stylebox_override`.
				See also `get_theme_stylebox` and `Control.add_theme_stylebox_override` for more details.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not stylebox is None)
    assert isinstance(stylebox, get_class('StyleBox')), 'stylebox must be StyleBox'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(380,tuple([py_stringname_name._ptr, stylebox._ptr]))

  @functools.native_method
  def add_theme_font_override(self, name:'object'   , font:'py4godot_font.Font'   ) -> None:
    r'''
				Creates a local override for a theme `Font` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_font_override`.
				See also `get_theme_font`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(381,tuple([py_stringname_name._ptr, font._ptr]))

  @functools.native_method
  def add_theme_font_size_override(self, name:'object'   , font_size:'int'   ) -> None:
    r'''
				Creates a local override for a theme font size with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_font_size_override`.
				See also `get_theme_font_size`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(382,tuple([py_stringname_name._ptr, font_size]))

  @functools.native_method
  def add_theme_color_override(self, name:'object'   , color:'Color'   ) -> None:
    r'''
				Creates a local override for a theme `Color` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_color_override`.
				See also `get_theme_color` and `Control.add_theme_color_override` for more details.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(383,tuple([py_stringname_name._ptr, color._ptr]))

  @functools.native_method
  def add_theme_constant_override(self, name:'object'   , constant:'int'   ) -> None:
    r'''
				Creates a local override for a theme constant with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_constant_override`.
				See also `get_theme_constant`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(constant, (int, float)), 'constant must be int or float'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(384,tuple([py_stringname_name._ptr, constant]))

  @functools.native_method
  def remove_theme_icon_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme icon with the specified `name` previously added by `add_theme_icon_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(385,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_stylebox_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme `StyleBox` with the specified `name` previously added by `add_theme_stylebox_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(386,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_font_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme `Font` with the specified `name` previously added by `add_theme_font_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(387,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_font_size_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme font size with the specified `name` previously added by `add_theme_font_size_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(388,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_color_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme `Color` with the specified `name` previously added by `add_theme_color_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(389,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_constant_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme constant with the specified `name` previously added by `add_theme_constant_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(390,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_theme_icon(self, name:'object'   , theme_type:'object' = None  ) -> typing.Any:
    r'''
				Returns an icon from the first matching `Theme` in the tree if that `Theme` has an icon item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(391,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_stylebox(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union['py4godot_stylebox.StyleBox','py4godot_styleboxflat.StyleBoxFlat','py4godot_styleboxtexture.StyleBoxTexture','py4godot_styleboxempty.StyleBoxEmpty','py4godot_styleboxline.StyleBoxLine']:
    r'''
				Returns a `StyleBox` from the first matching `Theme` in the tree if that `Theme` has a stylebox item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: StyleBox
    _ret._ptr = self._ptr.call_with_return(392,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_font(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union['py4godot_font.Font','py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation']:
    r'''
				Returns a `Font` from the first matching `Theme` in the tree if that `Theme` has a font item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(393,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_font_size(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[int]:
    r'''
				Returns a font size from the first matching `Theme` in the tree if that `Theme` has a font size item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(394,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_theme_color(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union['Color']:
    r'''
				Returns a `Color` from the first matching `Theme` in the tree if that `Theme` has a color item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for more details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(395,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_theme_constant(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[int]:
    r'''
				Returns a constant from the first matching `Theme` in the tree if that `Theme` has a constant item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for more details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(396,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_icon_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme icon with the specified `name` in this `Control` node.
				See `add_theme_icon_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(397,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_stylebox_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme `StyleBox` with the specified `name` in this `Control` node.
				See `add_theme_stylebox_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(398,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme `Font` with the specified `name` in this `Control` node.
				See `add_theme_font_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(399,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font_size_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme font size with the specified `name` in this `Control` node.
				See `add_theme_font_size_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(400,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_color_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme `Color` with the specified `name` in this `Control` node.
				See `add_theme_color_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(401,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_constant_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme constant with the specified `name` in this `Control` node.
				See `add_theme_constant_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(402,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_icon(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has an icon item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(403,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_stylebox(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a stylebox item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(404,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a font item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(405,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font_size(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a font size item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(406,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_color(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a color item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(407,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_constant(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a constant item with the specified `name` and `theme_type`.
				See `Control.get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(408,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_theme_default_base_scale(self) -> typing.Union[float]:
    r'''
				Returns the default base scale value from the first matching `Theme` in the tree if that `Theme` has a valid `Theme.default_base_scale` value.
				See `Control.get_theme_color` for details.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(409,tuple([]))
    return _ret


  @functools.native_method
  def get_theme_default_font(self) -> typing.Union['py4godot_font.Font','py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation']:
    r'''
				Returns the default font from the first matching `Theme` in the tree if that `Theme` has a valid `Theme.default_font` value.
				See `Control.get_theme_color` for details.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(410,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_default_font_size(self) -> typing.Union[int]:
    r'''
				Returns the default font size value from the first matching `Theme` in the tree if that `Theme` has a valid `Theme.default_font_size` value.
				See `Control.get_theme_color` for details.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(411,tuple([]))
    return _ret


  @functools.native_method
  def get_window_id(self) -> typing.Union[int]:
    r'''
				Returns the ID of the window.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(412,tuple([]))
    return _ret


  @functools.native_method
  def set_accessibility_name(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'

    self.py__accessibility_name = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(413,tuple([py__string_name._ptr]))

  @functools.native_method
  def get_accessibility_name(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(414,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_accessibility_description(self, description:'str'   ) -> None:
    r''''''

    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'

    self.py__accessibility_description = description



    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    py__string_description = utils.py_string_to_string(description)
    py__string_description.shouldBeDeleted = False


    self._ptr.call_with_return(415,tuple([py__string_description._ptr]))

  @functools.native_method
  def get_accessibility_description(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(416,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def get_focused_window() -> typing.Any:
    r'''
				Returns the focused window.
			'''




    _ret = Window.construct_without_init()
    _ret._ptr = static_method(1002,2,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_layout_direction(self, direction:'int'  ) -> None:
    r'''
				Sets layout direction and text writing direction. Right-to-left layouts are necessary for certain languages (e.g. Arabic and Hebrew).
			'''

    assert isinstance(direction, (int, float)), 'direction must be int or float'






    self._ptr.call_with_return(417,tuple([direction]))

  @functools.native_method
  def get_layout_direction(self) -> typing.Union[int]:
    r'''
				Returns layout direction and text writing direction.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(418,tuple([]))
    return _ret


  @functools.native_method
  def is_layout_rtl(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the layout is right-to-left.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(419,tuple([]))
    return _ret


  @functools.native_method
  def set_auto_translate(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'

    self.py__auto_translate = enable






    self._ptr.call_with_return(420,tuple([enable]))

  @functools.native_method
  def is_auto_translating(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(421,tuple([]))

    return _ret


  @functools.native_method
  def set_use_font_oversampling(self, enable:'bool'   ) -> None:
    r'''
				Enables font oversampling. This makes fonts look better when they are scaled up.
			'''

    assert isinstance(enable, bool), 'enable must be bool'






    self._ptr.call_with_return(422,tuple([enable]))

  @functools.native_method
  def is_using_font_oversampling(self) -> typing.Union[bool]:
    r'''
				Returns `true` if font oversampling is enabled. See `set_use_font_oversampling`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(423,tuple([]))
    return _ret


  @functools.native_method
  def popup(self, rect:'Rect2i' = None  ) -> None:
    r'''
				Shows the `Window` and makes it transient (see `transient`). If `rect` is provided, it will be set as the `Window`'s size. Fails if called on the main window.
				If `ProjectSettings.display/window/subwindows/embed_subwindows` is `true` (single-window mode), `rect`'s coordinates are global and relative to the main window's top-left corner (excluding window decorations). If `rect`'s position coordinates are negative, the window will be located outside the main window and may not be visible as a result.
				If `ProjectSettings.display/window/subwindows/embed_subwindows` is `false` (multi-window mode), `rect`'s coordinates are global and relative to the top-left corner of the leftmost screen. If `rect`'s position coordinates are negative, the window will be placed at the top-left corner of the screen.
				**Note:** `rect` must be in global coordinates if specified.
			'''
    if rect is None:
      rect = Rect2i.new0()
    if rect is None:
      rect = Rect2i.new0()







    self._ptr.call_with_return(424,tuple([rect._ptr]))

  @functools.native_method
  def popup_on_parent(self, parent_rect:'Rect2i'   ) -> None:
    r'''
				Popups the `Window` with a position shifted by parent `Window`'s position. If the `Window` is embedded, has the same effect as `popup`.
			'''

    assert(not parent_rect is None)
    assert isinstance(parent_rect, Rect2i), 'parent_rect must be Rect2i'






    self._ptr.call_with_return(425,tuple([parent_rect._ptr]))

  @functools.native_method
  def popup_centered(self, minsize:'Vector2i' = None  ) -> None:
    r'''
				Popups the `Window` at the center of the current screen, with optionally given minimum size. If the `Window` is embedded, it will be centered in the parent `Viewport` instead.
				**Note:** Calling it with the default value of `minsize` is equivalent to calling it with `size`.
			'''
    if minsize is None:
      minsize = Vector2i.new0()
    if minsize is None:
      minsize = Vector2i.new0()







    self._ptr.call_with_return(426,tuple([minsize._ptr]))

  @functools.native_method
  def popup_centered_ratio(self, ratio:'float' =0.8  ) -> None:
    r'''
				If `Window` is embedded, popups the `Window` centered inside its embedder and sets its size as a `ratio` of embedder's size.
				If `Window` is a native window, popups the `Window` centered inside the screen of its parent `Window` and sets its size as a `ratio` of the screen size.
			'''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'






    self._ptr.call_with_return(427,tuple([ratio]))

  @functools.native_method
  def popup_centered_clamped(self, minsize:'Vector2i' = None  , fallback_ratio:'float' =0.75  ) -> None:
    r'''
				Popups the `Window` centered inside its parent `Window`. `fallback_ratio` determines the maximum size of the `Window`, in relation to its parent.
				**Note:** Calling it with the default value of `minsize` is equivalent to calling it with `size`.
			'''
    if minsize is None:
      minsize = Vector2i.new0()
    if minsize is None:
      minsize = Vector2i.new0()

    assert isinstance(fallback_ratio, (int, float)), 'fallback_ratio must be int or float'







    self._ptr.call_with_return(428,tuple([minsize._ptr, fallback_ratio]))

  @functools.native_method
  def popup_exclusive(self, from_node:'py4godot_node.Node'   , rect:'Rect2i' = None  ) -> None:
    r'''
				Attempts to parent this dialog to the last exclusive window relative to `from_node`, and then calls `Window.popup` on it. The dialog must have no current parent, otherwise the method fails.
				See also `set_unparent_when_invisible` and `Node.get_last_exclusive_window`.
			'''
    if rect is None:
      rect = Rect2i.new0()
    if rect is None:
      rect = Rect2i.new0()

    assert(not from_node is None)
    assert isinstance(from_node, get_class('Node')), 'from_node must be Node'







    self._ptr.call_with_return(429,tuple([from_node._ptr, rect._ptr]))

  @functools.native_method
  def popup_exclusive_on_parent(self, from_node:'py4godot_node.Node'   , parent_rect:'Rect2i'   ) -> None:
    r'''
				Attempts to parent this dialog to the last exclusive window relative to `from_node`, and then calls `Window.popup_on_parent` on it. The dialog must have no current parent, otherwise the method fails.
				See also `set_unparent_when_invisible` and `Node.get_last_exclusive_window`.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, get_class('Node')), 'from_node must be Node'
    assert(not parent_rect is None)
    assert isinstance(parent_rect, Rect2i), 'parent_rect must be Rect2i'







    self._ptr.call_with_return(430,tuple([from_node._ptr, parent_rect._ptr]))

  @functools.native_method
  def popup_exclusive_centered(self, from_node:'py4godot_node.Node'   , minsize:'Vector2i' = None  ) -> None:
    r'''
				Attempts to parent this dialog to the last exclusive window relative to `from_node`, and then calls `Window.popup_centered` on it. The dialog must have no current parent, otherwise the method fails.
				See also `set_unparent_when_invisible` and `Node.get_last_exclusive_window`.
			'''
    if minsize is None:
      minsize = Vector2i.new0()
    if minsize is None:
      minsize = Vector2i.new0()

    assert(not from_node is None)
    assert isinstance(from_node, get_class('Node')), 'from_node must be Node'







    self._ptr.call_with_return(431,tuple([from_node._ptr, minsize._ptr]))

  @functools.native_method
  def popup_exclusive_centered_ratio(self, from_node:'py4godot_node.Node'   , ratio:'float' =0.8  ) -> None:
    r'''
				Attempts to parent this dialog to the last exclusive window relative to `from_node`, and then calls `Window.popup_centered_ratio` on it. The dialog must have no current parent, otherwise the method fails.
				See also `set_unparent_when_invisible` and `Node.get_last_exclusive_window`.
			'''

    assert(not from_node is None)
    assert isinstance(from_node, get_class('Node')), 'from_node must be Node'
    assert isinstance(ratio, (int, float)), 'ratio must be int or float'







    self._ptr.call_with_return(432,tuple([from_node._ptr, ratio]))

  @functools.native_method
  def popup_exclusive_centered_clamped(self, from_node:'py4godot_node.Node'   , minsize:'Vector2i' = None  , fallback_ratio:'float' =0.75  ) -> None:
    r'''
				Attempts to parent this dialog to the last exclusive window relative to `from_node`, and then calls `Window.popup_centered_clamped` on it. The dialog must have no current parent, otherwise the method fails.
				See also `set_unparent_when_invisible` and `Node.get_last_exclusive_window`.
			'''
    if minsize is None:
      minsize = Vector2i.new0()
    if minsize is None:
      minsize = Vector2i.new0()

    assert(not from_node is None)
    assert isinstance(from_node, get_class('Node')), 'from_node must be Node'
    assert isinstance(fallback_ratio, (int, float)), 'fallback_ratio must be int or float'








    self._ptr.call_with_return(433,tuple([from_node._ptr, minsize._ptr, fallback_ratio]))


register_cast_function('Window', Window.cast)
register_class('Window', Window)
