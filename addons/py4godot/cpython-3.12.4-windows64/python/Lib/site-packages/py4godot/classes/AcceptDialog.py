# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
import py4godot.classes.Window as py4godot_window 
from py4godot.wrappers.wrappers import CPPAcceptDialogWrapper


class AcceptDialog(py4godot_window.Window):
  r'''
		The default use of `AcceptDialog` is to allow it to only be accepted or closed, with the same result. However, the `signal confirmed` and `signal canceled` signals allow to make the two actions different, and the `add_button` method allows to add custom buttons and actions.
	'''

  @staticmethod
  def constructor():
    class_ = AcceptDialog.construct_without_init()
    class_._ptr = constructor(65,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AcceptDialog.construct_without_init()
    class_._ptr = constructor(65,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAcceptDialogWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(65,0, ())


  def generate_wrapper(self):
    return CPPAcceptDialogWrapper()
  def init_signals(self):
    super().init_signals()
    confirmed_name = utils.py_string_to_string_name("confirmed")
    self.confirmed = signals.BuiltinSignal(self, confirmed_name)
    canceled_name = utils.py_string_to_string_name("canceled")
    self.canceled = signals.BuiltinSignal(self, canceled_name)
    custom_action_name = utils.py_string_to_string_name("custom_action")
    self.custom_action = signals.BuiltinSignal(self, custom_action_name)

  @staticmethod
  def construct_without_init():
    cls = AcceptDialog.__new__(AcceptDialog)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AcceptDialog'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AcceptDialog.construct_without_init()
    cls._ptr = CPPAcceptDialogWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AcceptDialog.construct_without_init()
    cls._ptr = CPPAcceptDialogWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def ok_button_text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_ok_button_text()
    return _ret
  @ok_button_text.setter
  def ok_button_text(self,  value:'str'):
    self.set_ok_button_text(value)
  @property
  def dialog_text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_text()
    return _ret
  @dialog_text.setter
  def dialog_text(self,  value:'str'):
    self.set_text(value)
  @property
  def dialog_hide_on_ok(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_hide_on_ok()
    return _ret
  @dialog_hide_on_ok.setter
  def dialog_hide_on_ok(self,  value:'bool'):
    self.set_hide_on_ok(value)
  @property
  def dialog_close_on_escape(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_close_on_escape()
    return _ret
  @dialog_close_on_escape.setter
  def dialog_close_on_escape(self,  value:'bool'):
    self.set_close_on_escape(value)
  @property
  def dialog_autowrap(self) -> typing.Union[bool]:
    r''''''
    _ret = self. has_autowrap()
    return _ret
  @dialog_autowrap.setter
  def dialog_autowrap(self,  value:'bool'):
    self.set_autowrap(value)
  @functools.native_method
  def get_ok_button(self) -> typing.Any:
    r'''
				Returns the OK `Button` instance.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Button
    _ret._ptr = self._ptr.call_with_return(434,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_label(self) -> typing.Union['py4godot_label.Label']:
    r'''
				Returns the label used for built-in text.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Label
    _ret._ptr = self._ptr.call_with_return(435,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_hide_on_ok(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__dialog_hide_on_ok = enabled






    self._ptr.call_with_return(436,tuple([enabled]))

  @functools.native_method
  def get_hide_on_ok(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(437,tuple([]))

    return _ret


  @functools.native_method
  def set_close_on_escape(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__dialog_close_on_escape = enabled






    self._ptr.call_with_return(438,tuple([enabled]))

  @functools.native_method
  def get_close_on_escape(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(439,tuple([]))

    return _ret


  @functools.native_method
  def add_button(self, text:'str'   , right:'bool' =False  , action:'str' =""  ) -> typing.Any:
    r'''
				Adds a button with label `text` and a custom `action` to the dialog and returns the created button.
				If `action` is not empty, pressing the button will emit the `signal custom_action` signal with the specified action string.
				If `true`, `right` will place the button to the right of any sibling buttons.
				You can use `remove_button` method to remove a button created with this method from the dialog.
			'''
    if action is None:
      action = String.new0()
    if action is None:
      action = String.new0()

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(right, bool), 'right must be bool'




    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    assert(isinstance(action, (str, String)))
    py_string_action = action if isinstance(action, StringName) else c_utils.py_string_to_string(action)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Button
    _ret._ptr = self._ptr.call_with_return(440,tuple([py_string_text._ptr, right, py_string_action._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def add_cancel_button(self, name:'str'   ) -> typing.Any:
    r'''
				Adds a button with label `name` and a cancel action to the dialog and returns the created button.
				You can use `remove_button` method to remove a button created with this method from the dialog.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Button
    _ret._ptr = self._ptr.call_with_return(441,tuple([py_string_name._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def remove_button(self, button:'py4godot_button.Button'   ) -> None:
    r'''
				Removes the `button` from the dialog. Does NOT free the `button`. The `button` must be a `Button` added with `add_button` or `add_cancel_button` method. After removal, pressing the `button` will no longer emit this dialog's `signal custom_action` or `signal canceled` signals.
			'''

    assert(not button is None)
    assert isinstance(button, get_class('Button')), 'button must be Button'






    self._ptr.call_with_return(442,tuple([button._ptr]))

  @functools.native_method
  def register_text_enter(self, line_edit:'py4godot_lineedit.LineEdit'   ) -> None:
    r'''
				Registers a `LineEdit` in the dialog. When the enter key is pressed, the dialog will be accepted.
			'''

    assert(not line_edit is None)
    assert isinstance(line_edit, get_class('LineEdit')), 'line_edit must be LineEdit'






    self._ptr.call_with_return(443,tuple([line_edit._ptr]))

  @functools.native_method
  def set_text(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'

    self.py__dialog_text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(444,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(445,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_autowrap(self, autowrap:'bool'   ) -> None:
    r''''''

    assert isinstance(autowrap, bool), 'autowrap must be bool'

    self.py__dialog_autowrap = autowrap






    self._ptr.call_with_return(446,tuple([autowrap]))

  @functools.native_method
  def has_autowrap(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(447,tuple([]))

    return _ret


  @functools.native_method
  def set_ok_button_text(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'

    self.py__ok_button_text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(448,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_ok_button_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(449,tuple([]))

    return utils.gd_string_to_py_string(_ret)



register_cast_function('AcceptDialog', AcceptDialog.cast)
register_class('AcceptDialog', AcceptDialog)
