# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
from py4godot.wrappers.wrappers import CPPIPWrapper

_IP_singleton_instance = None
class ResolverStatus:
  RESOLVER_STATUS_NONE = 0
  RESOLVER_STATUS_WAITING = 1
  RESOLVER_STATUS_DONE = 2
  RESOLVER_STATUS_ERROR = 3
class Type:
  TYPE_NONE = 0
  TYPE_IPV4 = 1
  TYPE_IPV6 = 2
  TYPE_ANY = 3


class IP(py4godot_object.Object):
  r'''
		IP contains support functions for the Internet Protocol (IP). TCP/IP support is in different classes (see `StreamPeerTCP` and `TCPServer`). IP provides DNS hostname resolution support, both blocking and threaded.
	'''
  RESOLVER_MAX_QUERIES:typing.ClassVar[int]

  RESOLVER_INVALID_ID:typing.ClassVar[int]


  def generate_wrapper(self):
    return CPPIPWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = IP.__new__(IP)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'IP'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = IP.construct_without_init()
    cls._ptr = CPPIPWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = IP.construct_without_init()
    cls._ptr = CPPIPWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _IP_singleton_instance
    if _IP_singleton_instance is None:
      singleton = IP()
      singleton._ptr = constructor(402,0, ())
      _IP_singleton_instance = singleton
    return _IP_singleton_instance

  @functools.native_method
  def resolve_hostname(self, host:'str'   , ip_type:'int'  =3) -> typing.Union[str]:
    r'''
				Returns a given hostname's IPv4 or IPv6 address when resolved (blocking-type method). The address type returned depends on the `enum Type` constant given as `ip_type`.
			'''



    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(ip_type, (int, float)), 'ip_type must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([py_string_host._ptr, ip_type]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def resolve_hostname_addresses(self, host:'str'   , ip_type:'int'  =3) -> typing.Union['PackedStringArray']:
    r'''
				Resolves a given hostname in a blocking way. Addresses are returned as an `Array` of IPv4 or IPv6 addresses depending on `ip_type`.
			'''



    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(ip_type, (int, float)), 'ip_type must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)


    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([py_string_host._ptr, ip_type]))
    return _ret


  @functools.native_method
  def resolve_hostname_queue_item(self, host:'str'   , ip_type:'int'  =3) -> typing.Union[int]:
    r'''
				Creates a queue item to resolve a hostname to an IPv4 or IPv6 address depending on the `enum Type` constant given as `ip_type`. Returns the queue ID if successful, or `constant RESOLVER_INVALID_ID` on error.
			'''



    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(ip_type, (int, float)), 'ip_type must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)


    _ret = 0
    _ret = self._ptr.call_with_return(51,tuple([py_string_host._ptr, ip_type]))
    return _ret


  @functools.native_method
  def get_resolve_item_status(self, id:'int'   ) -> typing.Union[int]:
    r'''
				Returns a queued hostname's status as a `enum ResolverStatus` constant, given its queue `id`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(52,tuple([id]))
    return _ret


  @functools.native_method
  def get_resolve_item_address(self, id:'int'   ) -> typing.Union[str]:
    r'''
				Returns a queued hostname's IP address, given its queue `id`. Returns an empty string on error or if resolution hasn't happened yet (see `get_resolve_item_status`).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([id]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_resolve_item_addresses(self, id:'int'   ) -> typing.Union['Array']:
    r'''
				Returns resolved addresses, or an empty array if an error happened or resolution didn't happen yet (see `get_resolve_item_status`).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([id]))
    return _ret


  @functools.native_method
  def erase_resolve_item(self, id:'int'   ) -> None:
    r'''
				Removes a given item `id` from the queue. This should be used to free a queue after it has completed to enable more queries to happen.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    self._ptr.call_with_return(55,tuple([id]))

  @functools.native_method
  def get_local_addresses(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns all the user's current IPv4 and IPv6 addresses as an array.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def get_local_interfaces(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns all network adapters as an array.
				Each adapter is a dictionary of the form:
				```gdscript
				{
					"index": "1", # Interface index.
					"name": "eth0", # Interface name.
					"friendly": "Ethernet One", # A friendly name (might be empty).
					"addresses": `"192.168.1.101"`, # An array of IP addresses associated to this interface.
				}
				```
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def clear_cache(self, hostname:'str' =""  ) -> None:
    r'''
				Removes all of a `hostname`'s cached references. If no `hostname` is given, all cached IP addresses are removed.
			'''
    if hostname is None:
      hostname = String.new0()
    if hostname is None:
      hostname = String.new0()





    assert(isinstance(hostname, (str, String)))
    py_string_hostname = hostname if isinstance(hostname, StringName) else c_utils.py_string_to_string(hostname)

    self._ptr.call_with_return(58,tuple([py_string_hostname._ptr]))


register_cast_function('IP', IP.cast)
register_class('IP', IP)
