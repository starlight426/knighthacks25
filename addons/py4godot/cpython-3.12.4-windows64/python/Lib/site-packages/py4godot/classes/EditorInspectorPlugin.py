# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.Object as py4godot_object 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPEditorInspectorPluginWrapper


class EditorInspectorPlugin(py4godot_refcounted.RefCounted):
  r'''
		`EditorInspectorPlugin` allows adding custom property editors to `EditorInspector`.
		When an object is edited, the `_can_handle` function is called and must return `true` if the object type is supported.
		If supported, the function `_parse_begin` will be called, allowing to place custom controls at the beginning of the class.
		Subsequently, the `_parse_category` and `_parse_property` are called for every category and property. They offer the ability to add custom controls to the inspector too.
		Finally, `_parse_end` will be called.
		On each of these calls, the "add" functions can be called.
		To use `EditorInspectorPlugin`, register it using the `EditorPlugin.add_inspector_plugin` method first.
	'''

  @staticmethod
  def constructor():
    class_ = EditorInspectorPlugin.construct_without_init()
    class_._ptr = constructor(290,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorInspectorPlugin.construct_without_init()
    class_._ptr = constructor(290,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorInspectorPluginWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(290,0, ())


  def generate_wrapper(self):
    return CPPEditorInspectorPluginWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorInspectorPlugin.__new__(EditorInspectorPlugin)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorInspectorPlugin'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorInspectorPlugin.construct_without_init()
    cls._ptr = CPPEditorInspectorPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorInspectorPlugin.construct_without_init()
    cls._ptr = CPPEditorInspectorPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _can_handle(self, object_:'py4godot_object.Object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if this object can be handled by this plugin.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'






    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([object_._ptr]))
    return _ret


  @functools.native_method
  def _parse_begin(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Called to allow adding controls at the beginning of the property list for `object`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'






    self._ptr.call_with_return(54,tuple([object_._ptr]))

  @functools.native_method
  def _parse_category(self, object_:'py4godot_object.Object'   , category:'str'   ) -> None:
    r'''
				Called to allow adding controls at the beginning of a category in the property list for `object`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not category is None)
    assert isinstance(category, (str, String)), 'category must be str or String'





    assert(isinstance(category, (str, String)))
    py_string_category = category if isinstance(category, StringName) else c_utils.py_string_to_string(category)

    self._ptr.call_with_return(55,tuple([object_._ptr, py_string_category._ptr]))

  @functools.native_method
  def _parse_group(self, object_:'py4godot_object.Object'   , group:'str'   ) -> None:
    r'''
				Called to allow adding controls at the beginning of a group or a sub-group in the property list for `object`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not group is None)
    assert isinstance(group, (str, String)), 'group must be str or String'





    assert(isinstance(group, (str, String)))
    py_string_group = group if isinstance(group, StringName) else c_utils.py_string_to_string(group)

    self._ptr.call_with_return(56,tuple([object_._ptr, py_string_group._ptr]))

  @functools.native_method
  def _parse_property(self, object_:'py4godot_object.Object'   , type:'int'  , name:'str'   , hint_type:'int'  , hint_string:'str'   , usage_flags:'int'   , wide:'bool'   ) -> typing.Union[bool]:
    r'''
				Called to allow adding property-specific editors to the property list for `object`. The added editor control must extend `EditorProperty`. Returning `true` removes the built-in editor for this property, otherwise allows to insert a custom editor before the built-in one.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(hint_type, (int, float)), 'hint_type must be int or float'
    assert(not hint_string is None)
    assert isinstance(hint_string, (str, String)), 'hint_string must be str or String'
    assert isinstance(usage_flags, get_class('bitfield::PropertyUsageFlags')), 'usage_flags must be bitfield::PropertyUsageFlags'
    assert isinstance(wide, bool), 'wide must be bool'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    assert(isinstance(hint_string, (str, String)))
    py_string_hint_string = hint_string if isinstance(hint_string, StringName) else c_utils.py_string_to_string(hint_string)



    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([object_._ptr, type, py_string_name._ptr, hint_type, py_string_hint_string._ptr, usage_flags, wide]))
    return _ret


  @functools.native_method
  def _parse_end(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Called to allow adding controls at the end of the property list for `object`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'






    self._ptr.call_with_return(58,tuple([object_._ptr]))

  @functools.native_method
  def add_custom_control(self, control:'py4godot_control.Control'   ) -> None:
    r'''
				Adds a custom control, which is not necessarily a property editor.
			'''

    assert(not control is None)
    assert isinstance(control, get_class('Control')), 'control must be Control'






    self._ptr.call_with_return(59,tuple([control._ptr]))

  @functools.native_method
  def add_property_editor(self, property:'str'   , editor:'py4godot_control.Control'   , add_to_end:'bool' =False  , label:'str' =""  ) -> None:
    r'''
				Adds a property editor for an individual property. The `editor` control must extend `EditorProperty`.
				There can be multiple property editors for a property. If `add_to_end` is `true`, this newly added editor will be displayed after all the other editors of the property whose `add_to_end` is `false`. For example, the editor uses this parameter to add an "Edit Region" button for `Sprite2D.region_rect` below the regular `Rect2` editor.
				`label` can be used to choose a custom label for the property editor in the inspector. If left empty, the label is computed from the name of the property instead.
			'''
    if label is None:
      label = String.new0()
    if label is None:
      label = String.new0()

    assert(not property is None)
    assert isinstance(property, (str, String)), 'property must be str or String'
    assert(not editor is None)
    assert isinstance(editor, get_class('Control')), 'editor must be Control'
    assert isinstance(add_to_end, bool), 'add_to_end must be bool'




    assert(isinstance(property, (str, String)))
    py_string_property = property if isinstance(property, StringName) else c_utils.py_string_to_string(property)


    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)

    self._ptr.call_with_return(60,tuple([py_string_property._ptr, editor._ptr, add_to_end, py_string_label._ptr]))

  @functools.native_method
  def add_property_editor_for_multiple_properties(self, label:'str'   , properties:'PackedStringArray'   , editor:'py4godot_control.Control'   ) -> None:
    r'''
				Adds an editor that allows modifying multiple properties. The `editor` control must extend `EditorProperty`.
			'''

    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    assert(not properties is None)
    assert isinstance(properties, PackedStringArray), 'properties must be PackedStringArray'
    assert(not editor is None)
    assert isinstance(editor, get_class('Control')), 'editor must be Control'




    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)



    self._ptr.call_with_return(61,tuple([py_string_label._ptr, properties._ptr, editor._ptr]))


register_cast_function('EditorInspectorPlugin', EditorInspectorPlugin.cast)
register_class('EditorInspectorPlugin', EditorInspectorPlugin)
