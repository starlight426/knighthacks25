# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.Skin as py4godot_skin 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.ImporterMesh as py4godot_importermesh 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
import py4godot.classes.Node3D as py4godot_node3d 
from py4godot.wrappers.wrappers import CPPImporterMeshInstance3DWrapper


class ImporterMeshInstance3D(py4godot_node3d.Node3D):
  r'''
'''

  @staticmethod
  def constructor():
    class_ = ImporterMeshInstance3D.construct_without_init()
    class_._ptr = constructor(411,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ImporterMeshInstance3D.construct_without_init()
    class_._ptr = constructor(411,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPImporterMeshInstance3DWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(411,0, ())


  def generate_wrapper(self):
    return CPPImporterMeshInstance3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ImporterMeshInstance3D.__new__(ImporterMeshInstance3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ImporterMeshInstance3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ImporterMeshInstance3D.construct_without_init()
    cls._ptr = CPPImporterMeshInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ImporterMeshInstance3D.construct_without_init()
    cls._ptr = CPPImporterMeshInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def mesh(self) -> typing.Union['py4godot_importermesh.ImporterMesh']:
    r''''''
    _ret = self. get_mesh()
    return _ret
  @mesh.setter
  def mesh(self,  value:'py4godot_object.Object'):
    self.set_mesh(value)
  @property
  def skin(self) -> typing.Union['py4godot_skin.Skin']:
    r''''''
    _ret = self. get_skin()
    return _ret
  @skin.setter
  def skin(self,  value:'py4godot_object.Object'):
    self.set_skin(value)
  @property
  def skeleton_path(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_skeleton_path()
    return _ret
  @skeleton_path.setter
  def skeleton_path(self,  value:'object'):
    self.set_skeleton_path(value)
  @property
  def layer_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_layer_mask()
    return _ret
  @layer_mask.setter
  def layer_mask(self,  value:'int'):
    self.set_layer_mask(value)
  @property
  def cast_shadow(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cast_shadows_setting()
    return _ret
  @cast_shadow.setter
  def cast_shadow(self,  value:'int'):
    self.set_cast_shadows_setting(value)
  @property
  def visibility_range_begin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_begin()
    return _ret
  @visibility_range_begin.setter
  def visibility_range_begin(self,  value:'float'):
    self.set_visibility_range_begin(value)
  @property
  def visibility_range_begin_margin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_begin_margin()
    return _ret
  @visibility_range_begin_margin.setter
  def visibility_range_begin_margin(self,  value:'float'):
    self.set_visibility_range_begin_margin(value)
  @property
  def visibility_range_end(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_end()
    return _ret
  @visibility_range_end.setter
  def visibility_range_end(self,  value:'float'):
    self.set_visibility_range_end(value)
  @property
  def visibility_range_end_margin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_end_margin()
    return _ret
  @visibility_range_end_margin.setter
  def visibility_range_end_margin(self,  value:'float'):
    self.set_visibility_range_end_margin(value)
  @property
  def visibility_range_fade_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visibility_range_fade_mode()
    return _ret
  @visibility_range_fade_mode.setter
  def visibility_range_fade_mode(self,  value:'int'):
    self.set_visibility_range_fade_mode(value)
  @functools.native_method
  def set_mesh(self, mesh:'py4godot_importermesh.ImporterMesh'   ) -> None:
    r''''''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('ImporterMesh')), 'mesh must be ImporterMesh'

    self.py__mesh = mesh






    self._ptr.call_with_return(251,tuple([mesh._ptr]))

  @functools.native_method
  def get_mesh(self) -> typing.Union['py4godot_importermesh.ImporterMesh']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ImporterMesh
    _ret._ptr = self._ptr.call_with_return(252,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_skin(self, skin:'py4godot_skin.Skin'   ) -> None:
    r''''''

    assert(not skin is None)
    assert isinstance(skin, get_class('Skin')), 'skin must be Skin'

    self.py__skin = skin






    self._ptr.call_with_return(253,tuple([skin._ptr]))

  @functools.native_method
  def get_skin(self) -> typing.Union['py4godot_skin.Skin']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Skin
    _ret._ptr = self._ptr.call_with_return(254,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_skeleton_path(self, skeleton_path:'object'   ) -> None:
    r''''''

    assert(not skeleton_path is None)
    assert isinstance(skeleton_path, (str, NodePath)), 'skeleton_path must be str or NodePath'

    self.py__skeleton_path = skeleton_path



    assert(isinstance(skeleton_path, (str, NodePath)))
    py_nodepath_skeleton_path = skeleton_path if isinstance(skeleton_path,NodePath) else NodePath.new2(skeleton_path)


    self._ptr.call_with_return(255,tuple([py_nodepath_skeleton_path._ptr]))

  @functools.native_method
  def get_skeleton_path(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(256,tuple([]))

    return _ret


  @functools.native_method
  def set_layer_mask(self, layer_mask:'int'   ) -> None:
    r''''''

    assert isinstance(layer_mask, (int, float)), 'layer_mask must be int or float'

    self.py__layer_mask = layer_mask






    self._ptr.call_with_return(257,tuple([layer_mask]))

  @functools.native_method
  def get_layer_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(258,tuple([]))

    return _ret


  @functools.native_method
  def set_cast_shadows_setting(self, shadow_casting_setting:'int'  ) -> None:
    r''''''

    assert isinstance(shadow_casting_setting, (int, float)), 'shadow_casting_setting must be int or float'

    self.py__cast_shadow = shadow_casting_setting






    self._ptr.call_with_return(259,tuple([shadow_casting_setting]))

  @functools.native_method
  def get_cast_shadows_setting(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(260,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_end_margin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'

    self.py__visibility_range_end_margin = distance






    self._ptr.call_with_return(261,tuple([distance]))

  @functools.native_method
  def get_visibility_range_end_margin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(262,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_end(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'

    self.py__visibility_range_end = distance






    self._ptr.call_with_return(263,tuple([distance]))

  @functools.native_method
  def get_visibility_range_end(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(264,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_begin_margin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'

    self.py__visibility_range_begin_margin = distance






    self._ptr.call_with_return(265,tuple([distance]))

  @functools.native_method
  def get_visibility_range_begin_margin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(266,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_begin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'

    self.py__visibility_range_begin = distance






    self._ptr.call_with_return(267,tuple([distance]))

  @functools.native_method
  def get_visibility_range_begin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(268,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_fade_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__visibility_range_fade_mode = mode






    self._ptr.call_with_return(269,tuple([mode]))

  @functools.native_method
  def get_visibility_range_fade_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(270,tuple([]))

    return _ret



register_cast_function('ImporterMeshInstance3D', ImporterMeshInstance3D.cast)
register_class('ImporterMeshInstance3D', ImporterMeshInstance3D)
