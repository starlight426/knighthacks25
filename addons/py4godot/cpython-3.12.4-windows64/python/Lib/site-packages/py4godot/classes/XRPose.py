# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPXRPoseWrapper

class TrackingConfidence:
  XR_TRACKING_CONFIDENCE_NONE = 0
  XR_TRACKING_CONFIDENCE_LOW = 1
  XR_TRACKING_CONFIDENCE_HIGH = 2


class XRPose(py4godot_refcounted.RefCounted):
  r'''
		XR runtimes often identify multiple locations on devices such as controllers that are spatially tracked.
		Orientation, location, linear velocity and angular velocity are all provided for each pose by the XR runtime. This object contains this state of a pose.
	'''

  @staticmethod
  def constructor():
    class_ = XRPose.construct_without_init()
    class_._ptr = constructor(1025,0, ())
    return class_
  @staticmethod
  def new():
    class_ = XRPose.construct_without_init()
    class_._ptr = constructor(1025,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPXRPoseWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(1025,0, ())


  def generate_wrapper(self):
    return CPPXRPoseWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = XRPose.__new__(XRPose)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'XRPose'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRPose.construct_without_init()
    cls._ptr = CPPXRPoseWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRPose.construct_without_init()
    cls._ptr = CPPXRPoseWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def has_tracking_data(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_has_tracking_data()
    return _ret
  @has_tracking_data.setter
  def has_tracking_data(self,  value:'bool'):
    self.set_has_tracking_data(value)
  @property
  def name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_name()
    return _ret
  @name.setter
  def name(self,  value:'str'):
    self.set_name(value)
  @property
  def transform(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_transform()
    return _ret
  @transform.setter
  def transform(self,  value:'str'):
    self.set_transform(value)
  @property
  def linear_velocity(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_linear_velocity()
    return _ret
  @linear_velocity.setter
  def linear_velocity(self,  value:'str'):
    self.set_linear_velocity(value)
  @property
  def angular_velocity(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_angular_velocity()
    return _ret
  @angular_velocity.setter
  def angular_velocity(self,  value:'str'):
    self.set_angular_velocity(value)
  @property
  def tracking_confidence(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tracking_confidence()
    return _ret
  @tracking_confidence.setter
  def tracking_confidence(self,  value:'int'):
    self.set_tracking_confidence(value)
  @functools.native_method
  def set_has_tracking_data(self, has_tracking_data:'bool'   ) -> None:
    r''''''

    assert isinstance(has_tracking_data, bool), 'has_tracking_data must be bool'

    self.py__has_tracking_data = has_tracking_data






    self._ptr.call_with_return(53,tuple([has_tracking_data]))

  @functools.native_method
  def get_has_tracking_data(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([]))

    return _ret


  @functools.native_method
  def set_name(self, name:'object'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'

    self.py__name = name



    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(55,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))

    return _ret


  @functools.native_method
  def set_transform(self, transform:'Transform3D'   ) -> None:
    r''''''

    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'

    self.py__transform = transform






    self._ptr.call_with_return(57,tuple([transform._ptr]))

  @functools.native_method
  def get_transform(self) -> typing.Union['Transform3D']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))

    return _ret


  @functools.native_method
  def get_adjusted_transform(self) -> typing.Union['Transform3D']:
    r'''
				Returns the `transform` with world scale and our reference frame applied. This is the transform used to position `XRNode3D` objects.
			'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([]))
    return _ret


  @functools.native_method
  def set_linear_velocity(self, velocity:'Vector3'   ) -> None:
    r''''''

    assert(not velocity is None)
    assert isinstance(velocity, Vector3), 'velocity must be Vector3'

    self.py__linear_velocity = velocity






    self._ptr.call_with_return(60,tuple([velocity._ptr]))

  @functools.native_method
  def get_linear_velocity(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_velocity(self, velocity:'Vector3'   ) -> None:
    r''''''

    assert(not velocity is None)
    assert isinstance(velocity, Vector3), 'velocity must be Vector3'

    self.py__angular_velocity = velocity






    self._ptr.call_with_return(62,tuple([velocity._ptr]))

  @functools.native_method
  def get_angular_velocity(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([]))

    return _ret


  @functools.native_method
  def set_tracking_confidence(self, tracking_confidence:'int'  ) -> None:
    r''''''

    assert isinstance(tracking_confidence, (int, float)), 'tracking_confidence must be int or float'

    self.py__tracking_confidence = tracking_confidence






    self._ptr.call_with_return(64,tuple([tracking_confidence]))

  @functools.native_method
  def get_tracking_confidence(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(65,tuple([]))

    return _ret



register_cast_function('XRPose', XRPose.cast)
register_class('XRPose', XRPose)
