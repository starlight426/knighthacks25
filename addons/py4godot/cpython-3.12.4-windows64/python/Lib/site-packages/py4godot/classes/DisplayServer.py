# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.Rect2TypedArray as py4godot_rect2typedarray 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.Rect2TypedArray as py4godot_rect2typedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
from py4godot.wrappers.wrappers import CPPDisplayServerWrapper

_DisplayServer_singleton_instance = None
class Feature:
  FEATURE_GLOBAL_MENU = 0
  FEATURE_SUBWINDOWS = 1
  FEATURE_TOUCHSCREEN = 2
  FEATURE_MOUSE = 3
  FEATURE_MOUSE_WARP = 4
  FEATURE_CLIPBOARD = 5
  FEATURE_VIRTUAL_KEYBOARD = 6
  FEATURE_CURSOR_SHAPE = 7
  FEATURE_CUSTOM_CURSOR_SHAPE = 8
  FEATURE_NATIVE_DIALOG = 9
  FEATURE_IME = 10
  FEATURE_WINDOW_TRANSPARENCY = 11
  FEATURE_HIDPI = 12
  FEATURE_ICON = 13
  FEATURE_NATIVE_ICON = 14
  FEATURE_ORIENTATION = 15
  FEATURE_SWAP_BUFFERS = 16
  FEATURE_CLIPBOARD_PRIMARY = 18
  FEATURE_TEXT_TO_SPEECH = 19
  FEATURE_EXTEND_TO_TITLE = 20
  FEATURE_SCREEN_CAPTURE = 21
  FEATURE_STATUS_INDICATOR = 22
  FEATURE_NATIVE_HELP = 23
  FEATURE_NATIVE_DIALOG_INPUT = 24
  FEATURE_NATIVE_DIALOG_FILE = 25
  FEATURE_NATIVE_DIALOG_FILE_EXTRA = 26
  FEATURE_WINDOW_DRAG = 27
  FEATURE_SCREEN_EXCLUDE_FROM_CAPTURE = 28
  FEATURE_WINDOW_EMBEDDING = 29
  FEATURE_NATIVE_DIALOG_FILE_MIME = 30
  FEATURE_EMOJI_AND_SYMBOL_PICKER = 31
  FEATURE_NATIVE_COLOR_PICKER = 32
  FEATURE_SELF_FITTING_WINDOWS = 33
  FEATURE_ACCESSIBILITY_SCREEN_READER = 34
class AccessibilityRole:
  ROLE_UNKNOWN = 0
  ROLE_DEFAULT_BUTTON = 1
  ROLE_AUDIO = 2
  ROLE_VIDEO = 3
  ROLE_STATIC_TEXT = 4
  ROLE_CONTAINER = 5
  ROLE_PANEL = 6
  ROLE_BUTTON = 7
  ROLE_LINK = 8
  ROLE_CHECK_BOX = 9
  ROLE_RADIO_BUTTON = 10
  ROLE_CHECK_BUTTON = 11
  ROLE_SCROLL_BAR = 12
  ROLE_SCROLL_VIEW = 13
  ROLE_SPLITTER = 14
  ROLE_SLIDER = 15
  ROLE_SPIN_BUTTON = 16
  ROLE_PROGRESS_INDICATOR = 17
  ROLE_TEXT_FIELD = 18
  ROLE_MULTILINE_TEXT_FIELD = 19
  ROLE_COLOR_PICKER = 20
  ROLE_TABLE = 21
  ROLE_CELL = 22
  ROLE_ROW = 23
  ROLE_ROW_GROUP = 24
  ROLE_ROW_HEADER = 25
  ROLE_COLUMN_HEADER = 26
  ROLE_TREE = 27
  ROLE_TREE_ITEM = 28
  ROLE_LIST = 29
  ROLE_LIST_ITEM = 30
  ROLE_LIST_BOX = 31
  ROLE_LIST_BOX_OPTION = 32
  ROLE_TAB_BAR = 33
  ROLE_TAB = 34
  ROLE_TAB_PANEL = 35
  ROLE_MENU_BAR = 36
  ROLE_MENU = 37
  ROLE_MENU_ITEM = 38
  ROLE_MENU_ITEM_CHECK_BOX = 39
  ROLE_MENU_ITEM_RADIO = 40
  ROLE_IMAGE = 41
  ROLE_WINDOW = 42
  ROLE_TITLE_BAR = 43
  ROLE_DIALOG = 44
  ROLE_TOOLTIP = 45
class AccessibilityPopupType:
  POPUP_MENU = 0
  POPUP_LIST = 1
  POPUP_TREE = 2
  POPUP_DIALOG = 3
class AccessibilityFlags:
  FLAG_HIDDEN = 0
  FLAG_MULTISELECTABLE = 1
  FLAG_REQUIRED = 2
  FLAG_VISITED = 3
  FLAG_BUSY = 4
  FLAG_MODAL = 5
  FLAG_TOUCH_PASSTHROUGH = 6
  FLAG_READONLY = 7
  FLAG_DISABLED = 8
  FLAG_CLIPS_CHILDREN = 9
class AccessibilityAction:
  ACTION_CLICK = 0
  ACTION_FOCUS = 1
  ACTION_BLUR = 2
  ACTION_COLLAPSE = 3
  ACTION_EXPAND = 4
  ACTION_DECREMENT = 5
  ACTION_INCREMENT = 6
  ACTION_HIDE_TOOLTIP = 7
  ACTION_SHOW_TOOLTIP = 8
  ACTION_SET_TEXT_SELECTION = 9
  ACTION_REPLACE_SELECTED_TEXT = 10
  ACTION_SCROLL_BACKWARD = 11
  ACTION_SCROLL_DOWN = 12
  ACTION_SCROLL_FORWARD = 13
  ACTION_SCROLL_LEFT = 14
  ACTION_SCROLL_RIGHT = 15
  ACTION_SCROLL_UP = 16
  ACTION_SCROLL_INTO_VIEW = 17
  ACTION_SCROLL_TO_POINT = 18
  ACTION_SET_SCROLL_OFFSET = 19
  ACTION_SET_VALUE = 20
  ACTION_SHOW_CONTEXT_MENU = 21
  ACTION_CUSTOM = 22
class AccessibilityLiveMode:
  LIVE_OFF = 0
  LIVE_POLITE = 1
  LIVE_ASSERTIVE = 2
class AccessibilityScrollUnit:
  SCROLL_UNIT_ITEM = 0
  SCROLL_UNIT_PAGE = 1
class AccessibilityScrollHint:
  SCROLL_HINT_TOP_LEFT = 0
  SCROLL_HINT_BOTTOM_RIGHT = 1
  SCROLL_HINT_TOP_EDGE = 2
  SCROLL_HINT_BOTTOM_EDGE = 3
  SCROLL_HINT_LEFT_EDGE = 4
  SCROLL_HINT_RIGHT_EDGE = 5
class MouseMode:
  MOUSE_MODE_VISIBLE = 0
  MOUSE_MODE_HIDDEN = 1
  MOUSE_MODE_CAPTURED = 2
  MOUSE_MODE_CONFINED = 3
  MOUSE_MODE_CONFINED_HIDDEN = 4
  MOUSE_MODE_MAX = 5
class ScreenOrientation:
  SCREEN_LANDSCAPE = 0
  SCREEN_PORTRAIT = 1
  SCREEN_REVERSE_LANDSCAPE = 2
  SCREEN_REVERSE_PORTRAIT = 3
  SCREEN_SENSOR_LANDSCAPE = 4
  SCREEN_SENSOR_PORTRAIT = 5
  SCREEN_SENSOR = 6
class VirtualKeyboardType:
  KEYBOARD_TYPE_DEFAULT = 0
  KEYBOARD_TYPE_MULTILINE = 1
  KEYBOARD_TYPE_NUMBER = 2
  KEYBOARD_TYPE_NUMBER_DECIMAL = 3
  KEYBOARD_TYPE_PHONE = 4
  KEYBOARD_TYPE_EMAIL_ADDRESS = 5
  KEYBOARD_TYPE_PASSWORD = 6
  KEYBOARD_TYPE_URL = 7
class CursorShape:
  CURSOR_ARROW = 0
  CURSOR_IBEAM = 1
  CURSOR_POINTING_HAND = 2
  CURSOR_CROSS = 3
  CURSOR_WAIT = 4
  CURSOR_BUSY = 5
  CURSOR_DRAG = 6
  CURSOR_CAN_DROP = 7
  CURSOR_FORBIDDEN = 8
  CURSOR_VSIZE = 9
  CURSOR_HSIZE = 10
  CURSOR_BDIAGSIZE = 11
  CURSOR_FDIAGSIZE = 12
  CURSOR_MOVE = 13
  CURSOR_VSPLIT = 14
  CURSOR_HSPLIT = 15
  CURSOR_HELP = 16
  CURSOR_MAX = 17
class FileDialogMode:
  FILE_DIALOG_MODE_OPEN_FILE = 0
  FILE_DIALOG_MODE_OPEN_FILES = 1
  FILE_DIALOG_MODE_OPEN_DIR = 2
  FILE_DIALOG_MODE_OPEN_ANY = 3
  FILE_DIALOG_MODE_SAVE_FILE = 4
class WindowMode:
  WINDOW_MODE_WINDOWED = 0
  WINDOW_MODE_MINIMIZED = 1
  WINDOW_MODE_MAXIMIZED = 2
  WINDOW_MODE_FULLSCREEN = 3
  WINDOW_MODE_EXCLUSIVE_FULLSCREEN = 4
class WindowFlags:
  WINDOW_FLAG_RESIZE_DISABLED = 0
  WINDOW_FLAG_BORDERLESS = 1
  WINDOW_FLAG_ALWAYS_ON_TOP = 2
  WINDOW_FLAG_TRANSPARENT = 3
  WINDOW_FLAG_NO_FOCUS = 4
  WINDOW_FLAG_POPUP = 5
  WINDOW_FLAG_EXTEND_TO_TITLE = 6
  WINDOW_FLAG_MOUSE_PASSTHROUGH = 7
  WINDOW_FLAG_SHARP_CORNERS = 8
  WINDOW_FLAG_EXCLUDE_FROM_CAPTURE = 9
  WINDOW_FLAG_POPUP_WM_HINT = 10
  WINDOW_FLAG_MINIMIZE_DISABLED = 11
  WINDOW_FLAG_MAXIMIZE_DISABLED = 12
  WINDOW_FLAG_MAX = 13
class WindowEvent:
  WINDOW_EVENT_MOUSE_ENTER = 0
  WINDOW_EVENT_MOUSE_EXIT = 1
  WINDOW_EVENT_FOCUS_IN = 2
  WINDOW_EVENT_FOCUS_OUT = 3
  WINDOW_EVENT_CLOSE_REQUEST = 4
  WINDOW_EVENT_GO_BACK_REQUEST = 5
  WINDOW_EVENT_DPI_CHANGE = 6
  WINDOW_EVENT_TITLEBAR_CHANGE = 7
  WINDOW_EVENT_FORCE_CLOSE = 8
class WindowResizeEdge:
  WINDOW_EDGE_TOP_LEFT = 0
  WINDOW_EDGE_TOP = 1
  WINDOW_EDGE_TOP_RIGHT = 2
  WINDOW_EDGE_LEFT = 3
  WINDOW_EDGE_RIGHT = 4
  WINDOW_EDGE_BOTTOM_LEFT = 5
  WINDOW_EDGE_BOTTOM = 6
  WINDOW_EDGE_BOTTOM_RIGHT = 7
  WINDOW_EDGE_MAX = 8
class VSyncMode:
  VSYNC_DISABLED = 0
  VSYNC_ENABLED = 1
  VSYNC_ADAPTIVE = 2
  VSYNC_MAILBOX = 3
class HandleType:
  DISPLAY_HANDLE = 0
  WINDOW_HANDLE = 1
  WINDOW_VIEW = 2
  OPENGL_CONTEXT = 3
  EGL_DISPLAY = 4
  EGL_CONFIG = 5
class TTSUtteranceEvent:
  TTS_UTTERANCE_STARTED = 0
  TTS_UTTERANCE_ENDED = 1
  TTS_UTTERANCE_CANCELED = 2
  TTS_UTTERANCE_BOUNDARY = 3


class DisplayServer(py4godot_object.Object):
  r'''
		`DisplayServer` handles everything related to window management. It is separated from `OS` as a single operating system may support multiple display servers.
		**Headless mode:** Starting the engine with the `--headless` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url` disables all rendering and window management functions. Most functions from `DisplayServer` will return dummy values in this case.
	'''
  INVALID_SCREEN:typing.ClassVar[int]

  SCREEN_WITH_MOUSE_FOCUS:typing.ClassVar[int]

  SCREEN_WITH_KEYBOARD_FOCUS:typing.ClassVar[int]

  SCREEN_PRIMARY:typing.ClassVar[int]

  SCREEN_OF_MAIN_WINDOW:typing.ClassVar[int]

  MAIN_WINDOW_ID:typing.ClassVar[int]

  INVALID_WINDOW_ID:typing.ClassVar[int]

  INVALID_INDICATOR_ID:typing.ClassVar[int]


  def generate_wrapper(self):
    return CPPDisplayServerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = DisplayServer.__new__(DisplayServer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'DisplayServer'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = DisplayServer.construct_without_init()
    cls._ptr = CPPDisplayServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = DisplayServer.construct_without_init()
    cls._ptr = CPPDisplayServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _DisplayServer_singleton_instance
    if _DisplayServer_singleton_instance is None:
      singleton = DisplayServer()
      singleton._ptr = constructor(262,0, ())
      _DisplayServer_singleton_instance = singleton
    return _DisplayServer_singleton_instance

  @functools.native_method
  def has_feature(self, feature:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `feature` is supported by the current `DisplayServer`, `false` otherwise.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([feature]))
    return _ret


  @functools.native_method
  def get_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the `DisplayServer` currently in use. Most operating systems only have a single `DisplayServer`, but Linux has access to more than one `DisplayServer` (currently X11 and Wayland).
				The names of built-in display servers are `Windows`, `macOS`, `X11` (Linux), `Wayland` (Linux), `Android`, `iOS`, `web` (HTML5), and `headless` (when started with the `--headless` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def help_set_search_callbacks(self, search_callback:'Callable'   , action_callback:'Callable'   ) -> None:
    r'''
				Sets native help system search callbacks.
				`search_callback` has the following arguments: `String search_string, int result_limit` and return a `Dictionary` with "key, display name" pairs for the search results. Called when the user enters search terms in the `Help` menu.
				`action_callback` has the following arguments: `String key`. Called when the user selects a search result in the `Help` menu.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not search_callback is None)
    assert isinstance(search_callback, Callable), 'search_callback must be Callable'
    assert(not action_callback is None)
    assert isinstance(action_callback, Callable), 'action_callback must be Callable'







    self._ptr.call_with_return(51,tuple([search_callback._ptr, action_callback._ptr]))

  @functools.native_method
  def global_menu_set_popup_callbacks(self, menu_root:'str'   , open_callback:'Callable'   , close_callback:'Callable'   ) -> None:
    r'''
				Registers callables to emit when the menu is respectively about to show or closed. Callback methods should have zero arguments.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not open_callback is None)
    assert isinstance(open_callback, Callable), 'open_callback must be Callable'
    assert(not close_callback is None)
    assert isinstance(close_callback, Callable), 'close_callback must be Callable'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(52,tuple([py_string_menu_root._ptr, open_callback._ptr, close_callback._ptr]))

  @functools.native_method
  def global_menu_add_submenu_item(self, menu_root:'str'   , label:'str'   , submenu:'str'   , index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds an item that will act as a submenu of the global menu `menu_root`. The `submenu` argument is the ID of the global menu root that will be shown when the item is clicked.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    assert(not submenu is None)
    assert isinstance(submenu, (str, String)), 'submenu must be str or String'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)
    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)
    assert(isinstance(submenu, (str, String)))
    py_string_submenu = submenu if isinstance(submenu, StringName) else c_utils.py_string_to_string(submenu)


    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([py_string_menu_root._ptr, py_string_label._ptr, py_string_submenu._ptr, index]))
    return _ret


  @functools.native_method
  def global_menu_add_item(self, menu_root:'str'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new item with text `label` to the global menu with ID `menu_root`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()


    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)
    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([py_string_menu_root._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def global_menu_add_check_item(self, menu_root:'str'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new checkable item with text `label` to the global menu with ID `menu_root`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()


    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)
    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([py_string_menu_root._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def global_menu_add_icon_item(self, menu_root:'str'   , icon:'py4godot_texture2d.Texture2D'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new item with text `label` and icon `icon` to the global menu with ID `menu_root`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()


    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([py_string_menu_root._ptr, icon._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def global_menu_add_icon_check_item(self, menu_root:'str'   , icon:'py4godot_texture2d.Texture2D'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new checkable item with text `label` and icon `icon` to the global menu with ID `menu_root`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()


    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([py_string_menu_root._ptr, icon._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def global_menu_add_radio_check_item(self, menu_root:'str'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new radio-checkable item with text `label` to the global menu with ID `menu_root`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See `global_menu_set_item_checked` for more info on how to control it.
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()


    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)
    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([py_string_menu_root._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def global_menu_add_icon_radio_check_item(self, menu_root:'str'   , icon:'py4godot_texture2d.Texture2D'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new radio-checkable item with text `label` and icon `icon` to the global menu with ID `menu_root`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See `global_menu_set_item_checked` for more info on how to control it.
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()


    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([py_string_menu_root._ptr, icon._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def global_menu_add_multistate_item(self, menu_root:'str'   , label:'str'   , max_states:'int'   , default_state:'int'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new item with text `label` to the global menu with ID `menu_root`.
				Contrarily to normal binary items, multistate items can have more than two states, as defined by `max_states`. Each press or activate of the item will increase the state by one. The default value is defined by `default_state`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** By default, there's no indication of the current item state, it should be changed manually.
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()


    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    assert isinstance(max_states, (int, float)), 'max_states must be int or float'
    assert isinstance(default_state, (int, float)), 'default_state must be int or float'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)
    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)








    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([py_string_menu_root._ptr, py_string_label._ptr, max_states, default_state, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def global_menu_add_separator(self, menu_root:'str'   , index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a separator between items to the global menu with ID `menu_root`. Separators also occupy an index.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(index, (int, float)), 'index must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([py_string_menu_root._ptr, index]))
    return _ret


  @functools.native_method
  def global_menu_get_item_index_from_text(self, menu_root:'str'   , text:'str'   ) -> typing.Union[int]:
    r'''
				Returns the index of the item with the specified `text`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)
    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([py_string_menu_root._ptr, py_string_text._ptr]))
    return _ret


  @functools.native_method
  def global_menu_get_item_index_from_tag(self, menu_root:'str'   , tag:'object'   ) -> typing.Union[int]:
    r'''
				Returns the index of the item with the specified `tag`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(63,tuple([py_string_menu_root._ptr, tag]))
    return _ret


  @functools.native_method
  def global_menu_is_item_checked(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is checked.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_is_item_checkable(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is checkable in some way, i.e. if it has a checkbox or radio button.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_is_item_radio_checkable(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` has radio button-style checkability.
				**Note:** This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_get_item_callback(self, menu_root:'str'   , idx:'int'   ) -> typing.Union['Callable']:
    r'''
				Returns the callback of the item at index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_get_item_key_callback(self, menu_root:'str'   , idx:'int'   ) -> typing.Union['Callable']:
    r'''
				Returns the callback of the item accelerator at index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_get_item_tag(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata of the specified item, which might be of any type. You can set it with `global_menu_set_item_tag`, which provides a simple way of assigning context data to items.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = None
    _ret = self._ptr.call_with_return(69,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_get_item_text(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the text of the item at index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([py_string_menu_root._ptr, idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def global_menu_get_item_submenu(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the submenu ID of the item at index `idx`. See `global_menu_add_submenu_item` for more info on how to add a submenu.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([py_string_menu_root._ptr, idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def global_menu_get_item_accelerator(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the accelerator of the item at index `idx`. Accelerators are special combinations of keys that activate the item, no matter which control is focused.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret:int
    _ret = self._ptr.call_with_return(72,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_is_item_disabled(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is disabled. When it is disabled it can't be selected, or its action invoked.
				See `global_menu_set_item_disabled` for more info on how to disable an item.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_is_item_hidden(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is hidden.
				See `global_menu_set_item_hidden` for more info on how to hide an item.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(74,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_get_item_tooltip(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the tooltip associated with the specified index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([py_string_menu_root._ptr, idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def global_menu_get_item_state(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the state of a multistate item. See `global_menu_add_multistate_item` for details.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(76,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_get_item_max_states(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns number of states of a multistate item. See `global_menu_add_multistate_item` for details.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_get_item_icon(self, menu_root:'str'   , idx:'int'   ) -> typing.Any:
    r'''
				Returns the icon of the item at index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(78,tuple([py_string_menu_root._ptr, idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def global_menu_get_item_indentation_level(self, menu_root:'str'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the horizontal offset of the item at the given `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([py_string_menu_root._ptr, idx]))
    return _ret


  @functools.native_method
  def global_menu_set_item_checked(self, menu_root:'str'   , idx:'int'   , checked:'bool'   ) -> None:
    r'''
				Sets the checkstate status of the item at index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(checked, bool), 'checked must be bool'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(80,tuple([py_string_menu_root._ptr, idx, checked]))

  @functools.native_method
  def global_menu_set_item_checkable(self, menu_root:'str'   , idx:'int'   , checkable:'bool'   ) -> None:
    r'''
				Sets whether the item at index `idx` has a checkbox. If `false`, sets the type of the item to plain text.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(checkable, bool), 'checkable must be bool'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(81,tuple([py_string_menu_root._ptr, idx, checkable]))

  @functools.native_method
  def global_menu_set_item_radio_checkable(self, menu_root:'str'   , idx:'int'   , checkable:'bool'   ) -> None:
    r'''
				Sets the type of the item at the specified index `idx` to radio button. If `false`, sets the type of the item to plain text.
				**Note:** This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(checkable, bool), 'checkable must be bool'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(82,tuple([py_string_menu_root._ptr, idx, checkable]))

  @functools.native_method
  def global_menu_set_item_callback(self, menu_root:'str'   , idx:'int'   , callback:'Callable'   ) -> None:
    r'''
				Sets the callback of the item at index `idx`. Callback is emitted when an item is pressed.
				**Note:** The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(83,tuple([py_string_menu_root._ptr, idx, callback._ptr]))

  @functools.native_method
  def global_menu_set_item_hover_callbacks(self, menu_root:'str'   , idx:'int'   , callback:'Callable'   ) -> None:
    r'''
				Sets the callback of the item at index `idx`. The callback is emitted when an item is hovered.
				**Note:** The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(84,tuple([py_string_menu_root._ptr, idx, callback._ptr]))

  @functools.native_method
  def global_menu_set_item_key_callback(self, menu_root:'str'   , idx:'int'   , key_callback:'Callable'   ) -> None:
    r'''
				Sets the callback of the item at index `idx`. Callback is emitted when its accelerator is activated.
				**Note:** The `key_callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not key_callback is None)
    assert isinstance(key_callback, Callable), 'key_callback must be Callable'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(85,tuple([py_string_menu_root._ptr, idx, key_callback._ptr]))

  @functools.native_method
  def global_menu_set_item_tag(self, menu_root:'str'   , idx:'int'   , tag:'object'   ) -> None:
    r'''
				Sets the metadata of an item, which may be of any type. You can later get it with `global_menu_get_item_tag`, which provides a simple way of assigning context data to items.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(86,tuple([py_string_menu_root._ptr, idx, tag]))

  @functools.native_method
  def global_menu_set_item_text(self, menu_root:'str'   , idx:'int'   , text:'str'   ) -> None:
    r'''
				Sets the text of the item at index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(87,tuple([py_string_menu_root._ptr, idx, py_string_text._ptr]))

  @functools.native_method
  def global_menu_set_item_submenu(self, menu_root:'str'   , idx:'int'   , submenu:'str'   ) -> None:
    r'''
				Sets the submenu of the item at index `idx`. The submenu is the ID of a global menu root that would be shown when the item is clicked.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not submenu is None)
    assert isinstance(submenu, (str, String)), 'submenu must be str or String'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    assert(isinstance(submenu, (str, String)))
    py_string_submenu = submenu if isinstance(submenu, StringName) else c_utils.py_string_to_string(submenu)

    self._ptr.call_with_return(88,tuple([py_string_menu_root._ptr, idx, py_string_submenu._ptr]))

  @functools.native_method
  def global_menu_set_item_accelerator(self, menu_root:'str'   , idx:'int'   , keycode:'int'  ) -> None:
    r'''
				Sets the accelerator of the item at index `idx`. `keycode` can be a single `enum Key`, or a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(keycode, (int, float)), 'keycode must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(89,tuple([py_string_menu_root._ptr, idx, keycode]))

  @functools.native_method
  def global_menu_set_item_disabled(self, menu_root:'str'   , idx:'int'   , disabled:'bool'   ) -> None:
    r'''
				Enables/disables the item at index `idx`. When it is disabled, it can't be selected and its action can't be invoked.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(90,tuple([py_string_menu_root._ptr, idx, disabled]))

  @functools.native_method
  def global_menu_set_item_hidden(self, menu_root:'str'   , idx:'int'   , hidden:'bool'   ) -> None:
    r'''
				Hides/shows the item at index `idx`. When it is hidden, an item does not appear in a menu and its action cannot be invoked.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(hidden, bool), 'hidden must be bool'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(91,tuple([py_string_menu_root._ptr, idx, hidden]))

  @functools.native_method
  def global_menu_set_item_tooltip(self, menu_root:'str'   , idx:'int'   , tooltip:'str'   ) -> None:
    r'''
				Sets the `String` tooltip of the item at the specified index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(92,tuple([py_string_menu_root._ptr, idx, py_string_tooltip._ptr]))

  @functools.native_method
  def global_menu_set_item_state(self, menu_root:'str'   , idx:'int'   , state:'int'   ) -> None:
    r'''
				Sets the state of a multistate item. See `global_menu_add_multistate_item` for details.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(state, (int, float)), 'state must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(93,tuple([py_string_menu_root._ptr, idx, state]))

  @functools.native_method
  def global_menu_set_item_max_states(self, menu_root:'str'   , idx:'int'   , max_states:'int'   ) -> None:
    r'''
				Sets number of state of a multistate item. See `global_menu_add_multistate_item` for details.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(max_states, (int, float)), 'max_states must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(94,tuple([py_string_menu_root._ptr, idx, max_states]))

  @functools.native_method
  def global_menu_set_item_icon(self, menu_root:'str'   , idx:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Replaces the `Texture2D` icon of the specified `idx`.
				**Note:** This method is implemented only on macOS.
				**Note:** This method is not supported by macOS "_dock" menu items.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(95,tuple([py_string_menu_root._ptr, idx, icon._ptr]))

  @functools.native_method
  def global_menu_set_item_indentation_level(self, menu_root:'str'   , idx:'int'   , level:'int'   ) -> None:
    r'''
				Sets the horizontal offset of the item at the given `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(level, (int, float)), 'level must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)



    self._ptr.call_with_return(96,tuple([py_string_menu_root._ptr, idx, level]))

  @functools.native_method
  def global_menu_get_item_count(self, menu_root:'str'   ) -> typing.Union[int]:
    r'''
				Returns number of items in the global menu with ID `menu_root`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([py_string_menu_root._ptr]))
    return _ret


  @functools.native_method
  def global_menu_remove_item(self, menu_root:'str'   , idx:'int'   ) -> None:
    r'''
				Removes the item at index `idx` from the global menu `menu_root`.
				**Note:** The indices of items after the removed item will be shifted by one.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'
    assert isinstance(idx, (int, float)), 'idx must be int or float'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)


    self._ptr.call_with_return(98,tuple([py_string_menu_root._ptr, idx]))

  @functools.native_method
  def global_menu_clear(self, menu_root:'str'   ) -> None:
    r'''
				Removes all items from the global menu with ID `menu_root`.
				**Note:** This method is implemented only on macOS.
				**Supported system menu IDs:**
				`codeblock lang=text`
				"_main" - Main menu (macOS).
				"_dock" - Dock popup menu (macOS).
				"_apple" - Apple menu (macOS, custom items added before "Services").
				"_window" - Window menu (macOS, custom items added after "Bring All to Front").
				"_help" - Help menu (macOS).
				```
			'''

    assert(not menu_root is None)
    assert isinstance(menu_root, (str, String)), 'menu_root must be str or String'




    assert(isinstance(menu_root, (str, String)))
    py_string_menu_root = menu_root if isinstance(menu_root, StringName) else c_utils.py_string_to_string(menu_root)

    self._ptr.call_with_return(99,tuple([py_string_menu_root._ptr]))

  @functools.native_method
  def global_menu_get_system_menu_roots(self) -> typing.Union['Dictionary']:
    r'''
				Returns Dictionary of supported system menu IDs and names.
				**Note:** This method is implemented only on macOS.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(100,tuple([]))
    return _ret


  @functools.native_method
  def tts_is_speaking(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the synthesizer is generating speech, or have utterance waiting in the queue.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))
    return _ret


  @functools.native_method
  def tts_is_paused(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the synthesizer is in a paused state.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))
    return _ret


  @functools.native_method
  def tts_get_voices(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an `Array` of voice information dictionaries.
				Each `Dictionary` contains two `String` entries:
				- `name` is voice name.
				- `id` is voice identifier.
				- `language` is language code in `lang_Variant` format. The `lang` part is a 2 or 3-letter code based on the ISO-639 standard, in lowercase. The `code skip-lint`Variant` part is an engine-dependent string describing country, region or/and dialect.
				Note that Godot depends on system libraries for text-to-speech functionality. These libraries are installed by default on Windows and macOS, but not on all Linux distributions. If they are not present, this method will return an empty list. This applies to both Godot users on Linux, as well as end-users on Linux running Godot games that use text-to-speech.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def tts_get_voices_for_language(self, language:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a `PackedStringArray` of voice identifiers for the `language`.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'




    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([py_string_language._ptr]))
    return _ret


  @functools.native_method
  def tts_speak(self, text:'str'   , voice:'str'   , volume:'int' =50  , pitch:'float' =1.0  , rate:'float' =1.0  , utterance_id:'int' =0  , interrupt:'bool' =False  ) -> None:
    r'''
				Adds an utterance to the queue. If `interrupt` is `true`, the queue is cleared first.
				- `voice` identifier is one of the `"id"` values returned by `tts_get_voices` or one of the values returned by `tts_get_voices_for_language`.
				- `volume` ranges from `0` (lowest) to `100` (highest).
				- `pitch` ranges from `0.0` (lowest) to `2.0` (highest), `1.0` is default pitch for the current voice.
				- `rate` ranges from `0.1` (lowest) to `10.0` (highest), `1.0` is a normal speaking rate. Other values act as a percentage relative.
				- `utterance_id` is passed as a parameter to the callback functions.
				**Note:** On Windows and Linux (X11/Wayland), utterance `text` can use SSML markup. SSML support is engine and voice dependent. If the engine does not support SSML, you should strip out all XML markup before calling `tts_speak`.
				**Note:** The granularity of pitch, rate, and volume is engine and voice dependent. Values may be truncated.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert(not voice is None)
    assert isinstance(voice, (str, String)), 'voice must be str or String'
    assert isinstance(volume, (int, float)), 'volume must be int or float'
    assert isinstance(pitch, (int, float)), 'pitch must be int or float'
    assert isinstance(rate, (int, float)), 'rate must be int or float'
    assert isinstance(utterance_id, (int, float)), 'utterance_id must be int or float'
    assert isinstance(interrupt, bool), 'interrupt must be bool'




    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)
    assert(isinstance(voice, (str, String)))
    py_string_voice = voice if isinstance(voice, StringName) else c_utils.py_string_to_string(voice)






    self._ptr.call_with_return(105,tuple([py_string_text._ptr, py_string_voice._ptr, volume, pitch, rate, utterance_id, interrupt]))

  @functools.native_method
  def tts_pause(self) -> None:
    r'''
				Puts the synthesizer into a paused state.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''




    self._ptr.call_with_return(106,tuple([]))

  @functools.native_method
  def tts_resume(self) -> None:
    r'''
				Resumes the synthesizer if it was paused.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''




    self._ptr.call_with_return(107,tuple([]))

  @functools.native_method
  def tts_stop(self) -> None:
    r'''
				Stops synthesis in progress and removes all utterances from the queue.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''




    self._ptr.call_with_return(108,tuple([]))

  @functools.native_method
  def tts_set_utterance_callback(self, event:'int'  , callable:'Callable'   ) -> None:
    r'''
				Adds a callback, which is called when the utterance has started, finished, canceled or reached a text boundary.
				- `constant TTS_UTTERANCE_STARTED`, `constant TTS_UTTERANCE_ENDED`, and `constant TTS_UTTERANCE_CANCELED` callable's method should take one `int` parameter, the utterance ID.
				- `constant TTS_UTTERANCE_BOUNDARY` callable's method should take two `int` parameters, the index of the character and the utterance ID.
				**Note:** The granularity of the boundary callbacks is engine dependent.
				**Note:** This method is implemented on Android, iOS, Web, Linux (X11/Wayland), macOS, and Windows.
			'''

    assert isinstance(event, (int, float)), 'event must be int or float'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'







    self._ptr.call_with_return(109,tuple([event, callable._ptr]))

  @functools.native_method
  def is_dark_mode_supported(self) -> typing.Union[bool]:
    r'''
				Returns `true` if OS supports dark mode.
				**Note:** This method is implemented on Android, iOS, macOS, Windows, and Linux (X11/Wayland).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([]))
    return _ret


  @functools.native_method
  def is_dark_mode(self) -> typing.Union[bool]:
    r'''
				Returns `true` if OS is using dark mode.
				**Note:** This method is implemented on Android, iOS, macOS, Windows, and Linux (X11/Wayland).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(111,tuple([]))
    return _ret


  @functools.native_method
  def get_accent_color(self) -> typing.Union['Color']:
    r'''
				Returns OS theme accent color. Returns `Color(0, 0, 0, 0)`, if accent color is unknown.
				**Note:** This method is implemented on macOS, Windows, Android, and Linux (X11/Wayland).
			'''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(112,tuple([]))
    return _ret


  @functools.native_method
  def get_base_color(self) -> typing.Union['Color']:
    r'''
				Returns the OS theme base color (default control background). Returns `Color(0, 0, 0, 0)` if the base color is unknown.
				**Note:** This method is implemented on macOS, Windows, and Android.
			'''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(113,tuple([]))
    return _ret


  @functools.native_method
  def set_system_theme_change_callback(self, callable:'Callable'   ) -> None:
    r'''
				Sets the `callable` that should be called when system theme settings are changed. Callback method should have zero arguments.
				**Note:** This method is implemented on Android, iOS, macOS, Windows, and Linux (X11/Wayland).
			'''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'






    self._ptr.call_with_return(114,tuple([callable._ptr]))

  @functools.native_method
  def mouse_set_mode(self, mouse_mode:'int'  ) -> None:
    r'''
				Sets the current mouse mode. See also `mouse_get_mode`.
			'''

    assert isinstance(mouse_mode, (int, float)), 'mouse_mode must be int or float'






    self._ptr.call_with_return(115,tuple([mouse_mode]))

  @functools.native_method
  def mouse_get_mode(self) -> typing.Union[int]:
    r'''
				Returns the current mouse mode. See also `mouse_set_mode`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(116,tuple([]))
    return _ret


  @functools.native_method
  def warp_mouse(self, position:'Vector2i'   ) -> None:
    r'''
				Sets the mouse cursor position to the given `position` relative to an origin at the upper left corner of the currently focused game Window Manager window.
				**Note:** `warp_mouse` is only supported on Windows, macOS, and Linux (X11/Wayland). It has no effect on Android, iOS, and Web.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'






    self._ptr.call_with_return(117,tuple([position._ptr]))

  @functools.native_method
  def mouse_get_position(self) -> typing.Union['Vector2i']:
    r'''
				Returns the mouse cursor's current position in screen coordinates.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(118,tuple([]))
    return _ret


  @functools.native_method
  def mouse_get_button_state(self) -> typing.Union[int]:
    r'''
				Returns the current state of mouse buttons (whether each button is pressed) as a bitmask. If multiple mouse buttons are pressed at the same time, the bits are added together. Equivalent to `Input.get_mouse_button_mask`.
			'''




    _ret
    _ret = self._ptr.call_with_return(119,tuple([]))
    return _ret


  @functools.native_method
  def clipboard_set(self, clipboard:'str'   ) -> None:
    r'''
				Sets the user's clipboard content to the given string.
			'''

    assert(not clipboard is None)
    assert isinstance(clipboard, (str, String)), 'clipboard must be str or String'




    assert(isinstance(clipboard, (str, String)))
    py_string_clipboard = clipboard if isinstance(clipboard, StringName) else c_utils.py_string_to_string(clipboard)

    self._ptr.call_with_return(120,tuple([py_string_clipboard._ptr]))

  @functools.native_method
  def clipboard_get(self) -> typing.Union[str]:
    r'''
				Returns the user's clipboard as a string if possible.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(121,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def clipboard_get_image(self) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns the user's clipboard as an image if possible.
				**Note:** This method uses the copied pixel data, e.g. from an image editing software or a web browser, not an image file copied from file explorer.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(122,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def clipboard_has(self) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a text content on the user's clipboard.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(123,tuple([]))
    return _ret


  @functools.native_method
  def clipboard_has_image(self) -> typing.Union[bool]:
    r'''
				Returns `true` if there is an image content on the user's clipboard.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(124,tuple([]))
    return _ret


  @functools.native_method
  def clipboard_set_primary(self, clipboard_primary:'str'   ) -> None:
    r'''
				Sets the user's `url=https://unix.stackexchange.com/questions/139191/whats-the-difference-between-primary-selection-and-clipboard-buffer`primary`/url` clipboard content to the given string. This is the clipboard that is set when the user selects text in any application, rather than when pressing `kbd`Ctrl + C`/kbd`. The clipboard data can then be pasted by clicking the middle mouse button in any application that supports the primary clipboard mechanism.
				**Note:** This method is only implemented on Linux (X11/Wayland).
			'''

    assert(not clipboard_primary is None)
    assert isinstance(clipboard_primary, (str, String)), 'clipboard_primary must be str or String'




    assert(isinstance(clipboard_primary, (str, String)))
    py_string_clipboard_primary = clipboard_primary if isinstance(clipboard_primary, StringName) else c_utils.py_string_to_string(clipboard_primary)

    self._ptr.call_with_return(125,tuple([py_string_clipboard_primary._ptr]))

  @functools.native_method
  def clipboard_get_primary(self) -> typing.Union[str]:
    r'''
				Returns the user's `url=https://unix.stackexchange.com/questions/139191/whats-the-difference-between-primary-selection-and-clipboard-buffer`primary`/url` clipboard as a string if possible. This is the clipboard that is set when the user selects text in any application, rather than when pressing `kbd`Ctrl + C`/kbd`. The clipboard data can then be pasted by clicking the middle mouse button in any application that supports the primary clipboard mechanism.
				**Note:** This method is only implemented on Linux (X11/Wayland).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(126,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_display_cutouts(self) -> typing.Union['py4godot_rect2typedarray.Rect2TypedArray']:
    r'''
				Returns an `Array` of `Rect2`, each of which is the bounding rectangle for a display cutout or notch. These are non-functional areas on edge-to-edge screens used by cameras and sensors. Returns an empty array if the device does not have cutouts. See also `get_display_safe_area`.
				**Note:** Currently only implemented on Android. Other platforms will return an empty array even if they do have display cutouts or notches.
			'''




    _ret = py4godot_rect2typedarray.Rect2TypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(127,tuple([]))
    return _ret


  @functools.native_method
  def get_display_safe_area(self) -> typing.Union['Rect2i']:
    r'''
				Returns the unobscured area of the display where interactive controls should be rendered. See also `get_display_cutouts`.
				**Note:** Currently only implemented on Android and iOS. On other platforms, `screen_get_usable_rect(SCREEN_OF_MAIN_WINDOW)` will be returned as a fallback. See also `screen_get_usable_rect`.
			'''




    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(128,tuple([]))
    return _ret


  @functools.native_method
  def get_screen_count(self) -> typing.Union[int]:
    r'''
				Returns the number of displays available.
				**Note:** This method is implemented on Linux (X11 and Wayland), macOS, and Windows. On other platforms, this method always returns `1`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(129,tuple([]))
    return _ret


  @functools.native_method
  def get_primary_screen(self) -> typing.Union[int]:
    r'''
				Returns index of the primary screen.
				**Note:** This method is implemented on Linux/X11, macOS, and Windows. On other platforms, this method always returns `0`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(130,tuple([]))
    return _ret


  @functools.native_method
  def get_keyboard_focus_screen(self) -> typing.Union[int]:
    r'''
				Returns the index of the screen containing the window with the keyboard focus, or the primary screen if there's no focused window.
				**Note:** This method is implemented on Linux/X11, macOS, and Windows. On other platforms, this method always returns the primary screen.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(131,tuple([]))
    return _ret


  @functools.native_method
  def get_screen_from_rect(self, rect:'Rect2'   ) -> typing.Union[int]:
    r'''
				Returns the index of the screen that overlaps the most with the given rectangle. Returns `constant INVALID_SCREEN` if the rectangle doesn't overlap with any screen or has no area.
			'''

    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'






    _ret = 0
    _ret = self._ptr.call_with_return(132,tuple([rect._ptr]))
    return _ret


  @functools.native_method
  def screen_get_position(self, screen:'int' =-1  ) -> typing.Union['Vector2i']:
    r'''
				Returns the screen's top-left corner position in pixels. Returns `constant Vector2i.ZERO` if `screen` is invalid. On multi-monitor setups, the screen position is relative to the virtual desktop area. On multi-monitor setups with different screen resolutions or orientations, the origin might be located outside any display like this:
				`codeblock lang=text`
				* (0, 0)        +-------+
				                |       |
				+-------------+ |       |
				|             | |       |
				|             | |       |
				+-------------+ +-------+
				```
				See also `screen_get_size`.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(133,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_get_size(self, screen:'int' =-1  ) -> typing.Union['Vector2i']:
    r'''
				Returns the screen's size in pixels. See also `screen_get_position` and `screen_get_usable_rect`. Returns `constant Vector2i.ZERO` if `screen` is invalid.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(134,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_get_usable_rect(self, screen:'int' =-1  ) -> typing.Union['Rect2i']:
    r'''
				Returns the portion of the screen that is not obstructed by a status bar in pixels. See also `screen_get_size`.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** This method is implemented on Linux/X11, macOS, and Windows. On other platforms, this method always returns `Rect2i(screen_get_position(screen), screen_get_size(screen))`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(135,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_get_dpi(self, screen:'int' =-1  ) -> typing.Union[int]:
    r'''
				Returns the dots per inch density of the specified screen. Returns platform specific default value if `screen` is invalid.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** On macOS, returned value is inaccurate if fractional display scaling mode is used.
				**Note:** On Android devices, the actual screen densities are grouped into six generalized densities:
				`codeblock lang=text`
				   ldpi - 120 dpi
				   mdpi - 160 dpi
				   hdpi - 240 dpi
				  xhdpi - 320 dpi
				 xxhdpi - 480 dpi
				xxxhdpi - 640 dpi
				```
				**Note:** This method is implemented on Android, iOS, Linux (X11/Wayland), macOS, Web, and Windows. On other platforms, this method always returns `72`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(136,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_get_scale(self, screen:'int' =-1  ) -> typing.Union[float]:
    r'''
				Returns the scale factor of the specified screen by index. Returns `1.0` if `screen` is invalid.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** On macOS, the returned value is `2.0` for hiDPI (Retina) screens, and `1.0` for all other cases.
				**Note:** On Linux (Wayland), the returned value is accurate only when `screen` is `constant SCREEN_OF_MAIN_WINDOW`. Due to API limitations, passing a direct index will return a rounded-up integer, if the screen has a fractional scale (e.g. `1.25` would get rounded up to `2.0`).
				**Note:** This method is implemented on Android, iOS, Web, macOS, and Linux (Wayland). On other platforms, this method always returns `1.0`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(137,tuple([screen]))
    return _ret


  @functools.native_method
  def is_touchscreen_available(self) -> typing.Union[bool]:
    r'''
				Returns `true` if touch events are available (Android or iOS), the capability is detected on the Web platform or if `ProjectSettings.input_devices/pointing/emulate_touch_from_mouse` is `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(138,tuple([]))
    return _ret


  @functools.native_method
  def screen_get_max_scale(self) -> typing.Union[float]:
    r'''
				Returns the greatest scale factor of all screens.
				**Note:** On macOS returned value is `2.0` if there is at least one hiDPI (Retina) screen in the system, and `1.0` in all other cases.
				**Note:** This method is implemented only on macOS.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(139,tuple([]))
    return _ret


  @functools.native_method
  def screen_get_refresh_rate(self, screen:'int' =-1  ) -> typing.Union[float]:
    r'''
				Returns the current refresh rate of the specified screen. Returns `-1.0` if `screen` is invalid or the `DisplayServer` fails to find the refresh rate for the specified screen.
				To fallback to a default refresh rate if the method fails, try:
				```gdscript
				var refresh_rate = DisplayServer.screen_get_refresh_rate()
				if refresh_rate < 0:
					refresh_rate = 60.0
				```
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** This method is implemented on Android, iOS, macOS, Linux (X11 and Wayland), and Windows. On other platforms, this method always returns `-1.0`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(140,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_get_pixel(self, position:'Vector2i'   ) -> typing.Union['Color']:
    r'''
				Returns color of the display pixel at the `position`.
				**Note:** This method is implemented on Linux (X11, excluding XWayland), macOS, and Windows. On other platforms, this method always returns `Color`.
				**Note:** On macOS, this method requires the "Screen Recording" permission. If permission is not granted, this method returns a screenshot that will only contain the desktop wallpaper, the current application's window, and other related UI elements.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'






    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(141,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def screen_get_image(self, screen:'int' =-1  ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns a screenshot of the `screen`. Returns `null` if `screen` is invalid or the `DisplayServer` fails to capture screenshot.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** This method is implemented on Linux (X11, excluding XWayland), macOS, and Windows. On other platforms, this method always returns `null`.
				**Note:** On macOS, this method requires the "Screen Recording" permission. If permission is not granted, this method returns a screenshot that will not include other application windows or OS elements not related to the application.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(142,tuple([screen]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def screen_get_image_rect(self, rect:'Rect2i'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns a screenshot of the screen region defined by `rect`. Returns `null` if `rect` is outside screen bounds or the `DisplayServer` fails to capture screenshot.
				**Note:** This method is implemented on macOS and Windows. On other platforms, this method always returns `null`.
				**Note:** On macOS, this method requires the "Screen Recording" permission. If permission is not granted, this method returns a screenshot that will not include other application windows or OS elements not related to the application.
			'''

    assert(not rect is None)
    assert isinstance(rect, Rect2i), 'rect must be Rect2i'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(143,tuple([rect._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def screen_set_orientation(self, orientation:'int'  , screen:'int' =-1  ) -> None:
    r'''
				Sets the `screen`'s `orientation`. See also `screen_get_orientation`.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** This method is implemented on Android and iOS.
				**Note:** On iOS, this method has no effect if `ProjectSettings.display/window/handheld/orientation` is not set to `constant SCREEN_SENSOR`.
			'''

    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(screen, (int, float)), 'screen must be int or float'







    self._ptr.call_with_return(144,tuple([orientation, screen]))

  @functools.native_method
  def screen_get_orientation(self, screen:'int' =-1  ) -> typing.Union[int]:
    r'''
				Returns the `screen`'s current orientation. See also `screen_set_orientation`. Returns `constant SCREEN_LANDSCAPE` if `screen` is invalid.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** This method is implemented on Android and iOS. On other platforms, this method always returns `constant SCREEN_LANDSCAPE`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(145,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_set_keep_on(self, enable:'bool'   ) -> None:
    r'''
				Sets whether the screen should never be turned off by the operating system's power-saving measures. See also `screen_is_kept_on`.
			'''

    assert isinstance(enable, bool), 'enable must be bool'






    self._ptr.call_with_return(146,tuple([enable]))

  @functools.native_method
  def screen_is_kept_on(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the screen should never be turned off by the operating system's power-saving measures. See also `screen_set_keep_on`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(147,tuple([]))
    return _ret


  @functools.native_method
  def get_window_list(self) -> typing.Union['PackedInt32Array']:
    r'''
				Returns the list of Godot window IDs belonging to this process.
				**Note:** Native dialogs are not included in this list.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(148,tuple([]))
    return _ret


  @functools.native_method
  def get_window_at_screen_position(self, position:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns the ID of the window at the specified screen `position` (in pixels). On multi-monitor setups, the screen position is relative to the virtual desktop area. On multi-monitor setups with different screen resolutions or orientations, the origin may be located outside any display like this:
				`codeblock lang=text`
				* (0, 0)        +-------+
				                |       |
				+-------------+ |       |
				|             | |       |
				|             | |       |
				+-------------+ +-------+
				```
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'






    _ret = 0
    _ret = self._ptr.call_with_return(149,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def window_get_native_handle(self, handle_type:'int'  , window_id:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns internal structure pointers for use in plugins.
				**Note:** This method is implemented on Android, Linux (X11/Wayland), macOS, and Windows.
			'''

    assert isinstance(handle_type, (int, float)), 'handle_type must be int or float'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(150,tuple([handle_type, window_id]))
    return _ret


  @functools.native_method
  def window_get_active_popup(self) -> typing.Union[int]:
    r'''
				Returns ID of the active popup window, or `constant INVALID_WINDOW_ID` if there is none.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(151,tuple([]))
    return _ret


  @functools.native_method
  def window_set_popup_safe_rect(self, window:'int'   , rect:'Rect2i'   ) -> None:
    r'''
				Sets the bounding box of control, or menu item that was used to open the popup window, in the screen coordinate system. Clicking this area will not auto-close this popup.
			'''

    assert isinstance(window, (int, float)), 'window must be int or float'
    assert(not rect is None)
    assert isinstance(rect, Rect2i), 'rect must be Rect2i'







    self._ptr.call_with_return(152,tuple([window, rect._ptr]))

  @functools.native_method
  def window_get_popup_safe_rect(self, window:'int'   ) -> typing.Union['Rect2i']:
    r'''
				Returns the bounding box of control, or menu item that was used to open the popup window, in the screen coordinate system.
			'''

    assert isinstance(window, (int, float)), 'window must be int or float'






    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(153,tuple([window]))
    return _ret


  @functools.native_method
  def window_set_title(self, title:'str'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the title of the given window to `title`.
				**Note:** It's recommended to change this value using `Window.title` instead.
				**Note:** Avoid changing the window title every frame, as this can cause performance issues on certain window managers. Try to change the window title only a few times per second at most.
			'''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'




    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)


    self._ptr.call_with_return(154,tuple([py_string_title._ptr, window_id]))

  @functools.native_method
  def window_get_title_size(self, title:'str'   , window_id:'int' =0  ) -> typing.Union['Vector2i']:
    r'''
				Returns the estimated window title bar size (including text and window buttons) for the window specified by `window_id` (in pixels). This method does not change the window title.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'




    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)


    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(155,tuple([py_string_title._ptr, window_id]))
    return _ret


  @functools.native_method
  def window_set_mouse_passthrough(self, region:'PackedVector2Array'   , window_id:'int' =0  ) -> None:
    r'''
				Sets a polygonal region of the window which accepts mouse events. Mouse events outside the region will be passed through.
				Passing an empty array will disable passthrough support (all mouse events will be intercepted by the window, which is the default behavior).
				
				```gdscript
				# Set region, using Path2D node.
				DisplayServer.window_set_mouse_passthrough($Path2D.curve.get_baked_points())

				# Set region, using Polygon2D node.
				DisplayServer.window_set_mouse_passthrough($Polygon2D.polygon)

				# Reset region to default.
				DisplayServer.window_set_mouse_passthrough(``)
				```
				
				
				**Note:** On Windows, the portion of a window that lies outside the region is not drawn, while on Linux (X11) and macOS it is.
				**Note:** This method is implemented on Linux (X11), macOS and Windows.
			'''

    assert(not region is None)
    assert isinstance(region, PackedVector2Array), 'region must be PackedVector2Array'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(156,tuple([region._ptr, window_id]))

  @functools.native_method
  def window_get_current_screen(self, window_id:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the screen the window specified by `window_id` is currently positioned on. If the screen overlaps multiple displays, the screen where the window's center is located is returned. See also `window_set_current_screen`. Returns `constant INVALID_SCREEN` if `window_id` is invalid.
				**Note:** This method is implemented on Linux/X11, macOS, and Windows. On other platforms, this method always returns `0`.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(157,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_set_current_screen(self, screen:'int'   , window_id:'int' =0  ) -> None:
    r'''
				Moves the window specified by `window_id` to the specified `screen`. See also `window_get_current_screen`.
				**Note:** One of the following constants can be used as `screen`: `constant SCREEN_OF_MAIN_WINDOW`, `constant SCREEN_PRIMARY`, `constant SCREEN_WITH_MOUSE_FOCUS`, or `constant SCREEN_WITH_KEYBOARD_FOCUS`.
				**Note:** This method is implemented on Linux/X11, macOS, and Windows.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(158,tuple([screen, window_id]))

  @functools.native_method
  def window_get_position(self, window_id:'int' =0  ) -> typing.Union['Vector2i']:
    r'''
				Returns the position of the client area of the given window on the screen.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(159,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_get_position_with_decorations(self, window_id:'int' =0  ) -> typing.Union['Vector2i']:
    r'''
				Returns the position of the given window on the screen including the borders drawn by the operating system. See also `window_get_position`.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(160,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_set_position(self, position:'Vector2i'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the position of the given window to `position`. On multi-monitor setups, the screen position is relative to the virtual desktop area. On multi-monitor setups with different screen resolutions or orientations, the origin may be located outside any display like this:
				`codeblock lang=text`
				* (0, 0)        +-------+
				                |       |
				+-------------+ |       |
				|             | |       |
				|             | |       |
				+-------------+ +-------+
				```
				See also `window_get_position` and `window_set_size`.
				**Note:** It's recommended to change this value using `Window.position` instead.
				**Note:** On Linux (Wayland): this method is a no-op.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(161,tuple([position._ptr, window_id]))

  @functools.native_method
  def window_get_size(self, window_id:'int' =0  ) -> typing.Union['Vector2i']:
    r'''
				Returns the size of the window specified by `window_id` (in pixels), excluding the borders drawn by the operating system. This is also called the "client area". See also `window_get_size_with_decorations`, `window_set_size` and `window_get_position`.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(162,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_set_size(self, size:'Vector2i'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the size of the given window to `size` (in pixels). See also `window_get_size` and `window_get_position`.
				**Note:** It's recommended to change this value using `Window.size` instead.
			'''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(163,tuple([size._ptr, window_id]))

  @functools.native_method
  def window_set_rect_changed_callback(self, callback:'Callable'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the `callback` that will be called when the window specified by `window_id` is moved or resized.
				**Warning:** Advanced users only! Adding such a callback to a `Window` node will override its default implementation, which can introduce bugs.
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(164,tuple([callback._ptr, window_id]))

  @functools.native_method
  def window_set_window_event_callback(self, callback:'Callable'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the `callback` that will be called when an event occurs in the window specified by `window_id`.
				**Warning:** Advanced users only! Adding such a callback to a `Window` node will override its default implementation, which can introduce bugs.
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(165,tuple([callback._ptr, window_id]))

  @functools.native_method
  def window_set_input_event_callback(self, callback:'Callable'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the `callback` that should be called when any `InputEvent` is sent to the window specified by `window_id`.
				**Warning:** Advanced users only! Adding such a callback to a `Window` node will override its default implementation, which can introduce bugs.
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(166,tuple([callback._ptr, window_id]))

  @functools.native_method
  def window_set_input_text_callback(self, callback:'Callable'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the `callback` that should be called when text is entered using the virtual keyboard to the window specified by `window_id`.
				**Warning:** Advanced users only! Adding such a callback to a `Window` node will override its default implementation, which can introduce bugs.
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(167,tuple([callback._ptr, window_id]))

  @functools.native_method
  def window_set_drop_files_callback(self, callback:'Callable'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the `callback` that should be called when files are dropped from the operating system's file manager to the window specified by `window_id`. `callback` should take one `PackedStringArray` argument, which is the list of dropped files.
				**Warning:** Advanced users only! Adding such a callback to a `Window` node will override its default implementation, which can introduce bugs.
				**Note:** This method is implemented on Windows, macOS, Linux (X11/Wayland), and Web.
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(168,tuple([callback._ptr, window_id]))

  @functools.native_method
  def window_get_attached_instance_id(self, window_id:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the `Object.get_instance_id` of the `Window` the `window_id` is attached to.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(169,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_get_max_size(self, window_id:'int' =0  ) -> typing.Union['Vector2i']:
    r'''
				Returns the window's maximum size (in pixels). See also `window_set_max_size`.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(170,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_set_max_size(self, max_size:'Vector2i'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the maximum size of the window specified by `window_id` in pixels. Normally, the user will not be able to drag the window to make it larger than the specified size. See also `window_get_max_size`.
				**Note:** It's recommended to change this value using `Window.max_size` instead.
				**Note:** Using third-party tools, it is possible for users to disable window geometry restrictions and therefore bypass this limit.
			'''

    assert(not max_size is None)
    assert isinstance(max_size, Vector2i), 'max_size must be Vector2i'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(171,tuple([max_size._ptr, window_id]))

  @functools.native_method
  def window_get_min_size(self, window_id:'int' =0  ) -> typing.Union['Vector2i']:
    r'''
				Returns the window's minimum size (in pixels). See also `window_set_min_size`.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(172,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_set_min_size(self, min_size:'Vector2i'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the minimum size for the given window to `min_size` in pixels. Normally, the user will not be able to drag the window to make it smaller than the specified size. See also `window_get_min_size`.
				**Note:** It's recommended to change this value using `Window.min_size` instead.
				**Note:** By default, the main window has a minimum size of `Vector2i(64, 64)`. This prevents issues that can arise when the window is resized to a near-zero size.
				**Note:** Using third-party tools, it is possible for users to disable window geometry restrictions and therefore bypass this limit.
			'''

    assert(not min_size is None)
    assert isinstance(min_size, Vector2i), 'min_size must be Vector2i'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(173,tuple([min_size._ptr, window_id]))

  @functools.native_method
  def window_get_size_with_decorations(self, window_id:'int' =0  ) -> typing.Union['Vector2i']:
    r'''
				Returns the size of the window specified by `window_id` (in pixels), including the borders drawn by the operating system. See also `window_get_size`.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(174,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_get_mode(self, window_id:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the mode of the given window.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(175,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_set_mode(self, mode:'int'  , window_id:'int' =0  ) -> None:
    r'''
				Sets window mode for the given window to `mode`.
				**Note:** On Android, setting it to `constant WINDOW_MODE_FULLSCREEN` or `constant WINDOW_MODE_EXCLUSIVE_FULLSCREEN` will enable immersive mode.
				**Note:** Setting the window to full screen forcibly sets the borderless flag to `true`, so make sure to set it back to `false` when not wanted.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(176,tuple([mode, window_id]))

  @functools.native_method
  def window_set_flag(self, flag:'int'  , enabled:'bool'   , window_id:'int' =0  ) -> None:
    r'''
				Enables or disables the given window's given `flag`.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'








    self._ptr.call_with_return(177,tuple([flag, enabled, window_id]))

  @functools.native_method
  def window_get_flag(self, flag:'int'  , window_id:'int' =0  ) -> typing.Union[bool]:
    r'''
				Returns the current value of the given window's `flag`.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(178,tuple([flag, window_id]))
    return _ret


  @functools.native_method
  def window_set_window_buttons_offset(self, offset:'Vector2i'   , window_id:'int' =0  ) -> None:
    r'''
				When `constant WINDOW_FLAG_EXTEND_TO_TITLE` flag is set, set offset to the center of the first titlebar button.
				**Note:** This flag is implemented only on macOS.
			'''

    assert(not offset is None)
    assert isinstance(offset, Vector2i), 'offset must be Vector2i'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(179,tuple([offset._ptr, window_id]))

  @functools.native_method
  def window_get_safe_title_margins(self, window_id:'int' =0  ) -> typing.Union['Vector3i']:
    r'''
				Returns left margins (`x`), right margins (`y`) and height (`z`) of the title that are safe to use (contains no buttons or other elements) when `constant WINDOW_FLAG_EXTEND_TO_TITLE` flag is set.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(180,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_request_attention(self, window_id:'int' =0  ) -> None:
    r'''
				Makes the window specified by `window_id` request attention, which is materialized by the window title and taskbar entry blinking until the window is focused. This usually has no visible effect if the window is currently focused. The exact behavior varies depending on the operating system.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    self._ptr.call_with_return(181,tuple([window_id]))

  @functools.native_method
  def window_move_to_foreground(self, window_id:'int' =0  ) -> None:
    r'''
				Moves the window specified by `window_id` to the foreground, so that it is visible over other windows.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    self._ptr.call_with_return(182,tuple([window_id]))

  @functools.native_method
  def window_is_focused(self, window_id:'int' =0  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the window specified by `window_id` is focused.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(183,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_can_draw(self, window_id:'int' =0  ) -> typing.Union[bool]:
    r'''
				Returns `true` if anything can be drawn in the window specified by `window_id`, `false` otherwise. Using the `--disable-render-loop` command line argument or a headless build will return `false`.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(184,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_set_transient(self, window_id:'int'   , parent_window_id:'int'   ) -> None:
    r'''
				Sets window transient parent. Transient window will be destroyed with its transient parent and will return focus to their parent when closed. The transient window is displayed on top of a non-exclusive full-screen parent window. Transient windows can't enter full-screen mode.
				**Note:** It's recommended to change this value using `Window.transient` instead.
				**Note:** The behavior might be different depending on the platform.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'
    assert isinstance(parent_window_id, (int, float)), 'parent_window_id must be int or float'







    self._ptr.call_with_return(185,tuple([window_id, parent_window_id]))

  @functools.native_method
  def window_set_exclusive(self, window_id:'int'   , exclusive:'bool'   ) -> None:
    r'''
				If set to `true`, this window will always stay on top of its parent window, parent window will ignore input while this window is opened.
				**Note:** On macOS, exclusive windows are confined to the same space (virtual desktop or screen) as the parent window.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'
    assert isinstance(exclusive, bool), 'exclusive must be bool'







    self._ptr.call_with_return(186,tuple([window_id, exclusive]))

  @functools.native_method
  def window_set_ime_active(self, active:'bool'   , window_id:'int' =0  ) -> None:
    r'''
				Sets whether `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` should be enabled for the window specified by `window_id`. See also `window_set_ime_position`.
			'''

    assert isinstance(active, bool), 'active must be bool'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(187,tuple([active, window_id]))

  @functools.native_method
  def window_set_ime_position(self, position:'Vector2i'   , window_id:'int' =0  ) -> None:
    r'''
				Sets the position of the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` popup for the specified `window_id`. Only effective if `window_set_ime_active` was set to `true` for the specified `window_id`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(188,tuple([position._ptr, window_id]))

  @functools.native_method
  def window_set_vsync_mode(self, vsync_mode:'int'  , window_id:'int' =0  ) -> None:
    r'''
				Sets the V-Sync mode of the given window. See also `ProjectSettings.display/window/vsync/vsync_mode`.
				Depending on the platform and used renderer, the engine will fall back to `constant VSYNC_ENABLED` if the desired mode is not supported.
				**Note:** V-Sync modes other than `constant VSYNC_ENABLED` are only supported in the Forward+ and Mobile rendering methods, not Compatibility.
			'''

    assert isinstance(vsync_mode, (int, float)), 'vsync_mode must be int or float'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(189,tuple([vsync_mode, window_id]))

  @functools.native_method
  def window_get_vsync_mode(self, window_id:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the V-Sync mode of the given window.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(190,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_is_maximize_allowed(self, window_id:'int' =0  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given window can be maximized (the maximize button is enabled).
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(191,tuple([window_id]))
    return _ret


  @functools.native_method
  def window_maximize_on_title_dbl_click(self) -> typing.Union[bool]:
    r'''
				Returns `true`, if double-click on a window title should maximize it.
				**Note:** This method is implemented only on macOS.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))
    return _ret


  @functools.native_method
  def window_minimize_on_title_dbl_click(self) -> typing.Union[bool]:
    r'''
				Returns `true`, if double-click on a window title should minimize it.
				**Note:** This method is implemented only on macOS.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(193,tuple([]))
    return _ret


  @functools.native_method
  def window_start_drag(self, window_id:'int' =0  ) -> None:
    r'''
				Starts an interactive drag operation on the window with the given `window_id`, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's title bar. Using this method allows the window to participate in space switching, tiling, and other system features.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS, and Windows.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    self._ptr.call_with_return(194,tuple([window_id]))

  @functools.native_method
  def window_start_resize(self, edge:'int'  , window_id:'int' =0  ) -> None:
    r'''
				Starts an interactive resize operation on the window with the given `window_id`, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's edge.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS, and Windows.
			'''

    assert isinstance(edge, (int, float)), 'edge must be int or float'
    assert isinstance(window_id, (int, float)), 'window_id must be int or float'







    self._ptr.call_with_return(195,tuple([edge, window_id]))

  @functools.native_method
  def accessibility_should_increase_contrast(self) -> typing.Union[int]:
    r'''
				Returns `1` if a high-contrast user interface theme should be used, `0` otherwise. Returns `-1` if status is unknown.
				**Note:** This method is implemented on Linux (X11/Wayland, GNOME), macOS, and Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(196,tuple([]))
    return _ret


  @functools.native_method
  def accessibility_should_reduce_animation(self) -> typing.Union[int]:
    r'''
				Returns `1` if flashing, blinking, and other moving content that can cause seizures in users with photosensitive epilepsy should be disabled, `0` otherwise. Returns `-1` if status is unknown.
				**Note:** This method is implemented on macOS and Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(197,tuple([]))
    return _ret


  @functools.native_method
  def accessibility_should_reduce_transparency(self) -> typing.Union[int]:
    r'''
				Returns `1` if background images, transparency, and other features that can reduce the contrast between the foreground and background should be disabled, `0` otherwise. Returns `-1` if status is unknown.
				**Note:** This method is implemented on macOS and Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(198,tuple([]))
    return _ret


  @functools.native_method
  def accessibility_screen_reader_active(self) -> typing.Union[int]:
    r'''
				Returns `1` if a screen reader, Braille display or other assistive app is active, `0` otherwise. Returns `-1` if status is unknown.
				**Note:** This method is implemented on Linux, macOS, and Windows.
				**Note:** Accessibility debugging tools, such as Accessibility Insights for Windows, macOS Accessibility Inspector, or AT-SPI Browser do not count as assistive apps and will not affect this value. To test your app with these tools, set `ProjectSettings.accessibility/general/accessibility_support` to `1`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(199,tuple([]))
    return _ret


  @functools.native_method
  def accessibility_create_element(self, window_id:'int'   , role:'int'  ) -> typing.Union['RID']:
    r'''
				Creates a new, empty accessibility element resource.
				**Note:** An accessibility element is created and freed automatically for each `Node`. In general, this function should not be called manually.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'
    assert isinstance(role, (int, float)), 'role must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(200,tuple([window_id, role]))
    return _ret


  @functools.native_method
  def accessibility_create_sub_element(self, parent_rid:'RID'   , role:'int'  , insert_pos:'int' =-1  ) -> typing.Union['RID']:
    r'''
				Creates a new, empty accessibility sub-element resource. Sub-elements can be used to provide accessibility information for objects which are not `Node`s, such as list items, table cells, or menu items. Sub-elements are freed automatically when the parent element is freed, or can be freed early using the `accessibility_free_element` method.
			'''

    assert(not parent_rid is None)
    assert isinstance(parent_rid, RID), 'parent_rid must be RID'
    assert isinstance(role, (int, float)), 'role must be int or float'
    assert isinstance(insert_pos, (int, float)), 'insert_pos must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(201,tuple([parent_rid._ptr, role, insert_pos]))
    return _ret


  @functools.native_method
  def accessibility_create_sub_text_edit_elements(self, parent_rid:'RID'   , shaped_text:'RID'   , min_height:'float'   , insert_pos:'int' =-1  ) -> typing.Union['RID']:
    r'''
				Creates a new, empty accessibility sub-element from the shaped text buffer. Sub-elements are freed automatically when the parent element is freed, or can be freed early using the `accessibility_free_element` method.
			'''

    assert(not parent_rid is None)
    assert isinstance(parent_rid, RID), 'parent_rid must be RID'
    assert(not shaped_text is None)
    assert isinstance(shaped_text, RID), 'shaped_text must be RID'
    assert isinstance(min_height, (int, float)), 'min_height must be int or float'
    assert isinstance(insert_pos, (int, float)), 'insert_pos must be int or float'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(202,tuple([parent_rid._ptr, shaped_text._ptr, min_height, insert_pos]))
    return _ret


  @functools.native_method
  def accessibility_has_element(self, id:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `id` is a valid accessibility element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(203,tuple([id._ptr]))
    return _ret


  @functools.native_method
  def accessibility_free_element(self, id:'RID'   ) -> None:
    r'''
				Frees an object created by `accessibility_create_element`, `accessibility_create_sub_element`, or `accessibility_create_sub_text_edit_elements`.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'






    self._ptr.call_with_return(204,tuple([id._ptr]))

  @functools.native_method
  def accessibility_element_set_meta(self, id:'RID'   , meta:'object'   ) -> None:
    r'''
				Sets the metadata of the accessibility element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    







    self._ptr.call_with_return(205,tuple([id._ptr, meta]))

  @functools.native_method
  def accessibility_element_get_meta(self, id:'RID'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata of the accessibility element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'






    _ret = None
    _ret = self._ptr.call_with_return(206,tuple([id._ptr]))
    return _ret


  @functools.native_method
  def accessibility_set_window_rect(self, window_id:'int'   , rect_out:'Rect2'   , rect_in:'Rect2'   ) -> None:
    r'''
				Sets window outer (with decorations) and inner (without decorations) bounds for assistive apps.
				**Note:** This method is implemented on Linux, macOS, and Windows.
				**Note:** Advanced users only! `Window` objects call this method automatically.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'
    assert(not rect_out is None)
    assert isinstance(rect_out, Rect2), 'rect_out must be Rect2'
    assert(not rect_in is None)
    assert isinstance(rect_in, Rect2), 'rect_in must be Rect2'








    self._ptr.call_with_return(207,tuple([window_id, rect_out._ptr, rect_in._ptr]))

  @functools.native_method
  def accessibility_set_window_focused(self, window_id:'int'   , focused:'bool'   ) -> None:
    r'''
				Sets the window focused state for assistive apps.
				**Note:** This method is implemented on Linux, macOS, and Windows.
				**Note:** Advanced users only! `Window` objects call this method automatically.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'
    assert isinstance(focused, bool), 'focused must be bool'







    self._ptr.call_with_return(208,tuple([window_id, focused]))

  @functools.native_method
  def accessibility_update_set_focus(self, id:'RID'   ) -> None:
    r'''
				Sets currently focused element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'






    self._ptr.call_with_return(209,tuple([id._ptr]))

  @functools.native_method
  def accessibility_get_window_root(self, window_id:'int'   ) -> typing.Union['RID']:
    r'''
				Returns the main accessibility element of the OS native window.
			'''

    assert isinstance(window_id, (int, float)), 'window_id must be int or float'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(210,tuple([window_id]))
    return _ret


  @functools.native_method
  def accessibility_update_set_role(self, id:'RID'   , role:'int'  ) -> None:
    r'''
				Sets element accessibility role.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(role, (int, float)), 'role must be int or float'







    self._ptr.call_with_return(211,tuple([id._ptr, role]))

  @functools.native_method
  def accessibility_update_set_name(self, id:'RID'   , name:'str'   ) -> None:
    r'''
				Sets element accessibility name.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(212,tuple([id._ptr, py_string_name._ptr]))

  @functools.native_method
  def accessibility_update_set_extra_info(self, id:'RID'   , name:'str'   ) -> None:
    r'''
				Sets element accessibility extra information added to the element name.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(213,tuple([id._ptr, py_string_name._ptr]))

  @functools.native_method
  def accessibility_update_set_description(self, id:'RID'   , description:'str'   ) -> None:
    r'''
				Sets element accessibility description.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'





    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(214,tuple([id._ptr, py_string_description._ptr]))

  @functools.native_method
  def accessibility_update_set_value(self, id:'RID'   , value:'str'   ) -> None:
    r'''
				Sets element text value.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    self._ptr.call_with_return(215,tuple([id._ptr, py_string_value._ptr]))

  @functools.native_method
  def accessibility_update_set_tooltip(self, id:'RID'   , tooltip:'str'   ) -> None:
    r'''
				Sets tooltip text.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'





    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(216,tuple([id._ptr, py_string_tooltip._ptr]))

  @functools.native_method
  def accessibility_update_set_bounds(self, id:'RID'   , p_rect:'Rect2'   ) -> None:
    r'''
				Sets element bounding box, relative to the node position.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not p_rect is None)
    assert isinstance(p_rect, Rect2), 'p_rect must be Rect2'







    self._ptr.call_with_return(217,tuple([id._ptr, p_rect._ptr]))

  @functools.native_method
  def accessibility_update_set_transform(self, id:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets element 2D transform.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(218,tuple([id._ptr, transform._ptr]))

  @functools.native_method
  def accessibility_update_add_child(self, id:'RID'   , child_id:'RID'   ) -> None:
    r'''
				Adds a child accessibility element.
				**Note:** `Node` children and sub-elements are added to the child list automatically.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not child_id is None)
    assert isinstance(child_id, RID), 'child_id must be RID'







    self._ptr.call_with_return(219,tuple([id._ptr, child_id._ptr]))

  @functools.native_method
  def accessibility_update_add_related_controls(self, id:'RID'   , related_id:'RID'   ) -> None:
    r'''
				Adds an element that is controlled by this element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not related_id is None)
    assert isinstance(related_id, RID), 'related_id must be RID'







    self._ptr.call_with_return(220,tuple([id._ptr, related_id._ptr]))

  @functools.native_method
  def accessibility_update_add_related_details(self, id:'RID'   , related_id:'RID'   ) -> None:
    r'''
				Adds an element that details this element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not related_id is None)
    assert isinstance(related_id, RID), 'related_id must be RID'







    self._ptr.call_with_return(221,tuple([id._ptr, related_id._ptr]))

  @functools.native_method
  def accessibility_update_add_related_described_by(self, id:'RID'   , related_id:'RID'   ) -> None:
    r'''
				Adds an element that describes this element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not related_id is None)
    assert isinstance(related_id, RID), 'related_id must be RID'







    self._ptr.call_with_return(222,tuple([id._ptr, related_id._ptr]))

  @functools.native_method
  def accessibility_update_add_related_flow_to(self, id:'RID'   , related_id:'RID'   ) -> None:
    r'''
				Adds an element that this element flow into.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not related_id is None)
    assert isinstance(related_id, RID), 'related_id must be RID'







    self._ptr.call_with_return(223,tuple([id._ptr, related_id._ptr]))

  @functools.native_method
  def accessibility_update_add_related_labeled_by(self, id:'RID'   , related_id:'RID'   ) -> None:
    r'''
				Adds an element that labels this element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not related_id is None)
    assert isinstance(related_id, RID), 'related_id must be RID'







    self._ptr.call_with_return(224,tuple([id._ptr, related_id._ptr]))

  @functools.native_method
  def accessibility_update_add_related_radio_group(self, id:'RID'   , related_id:'RID'   ) -> None:
    r'''
				Adds an element that is part of the same radio group.
				**Note:** This method should be called on each element of the group, using all other elements as `related_id`.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not related_id is None)
    assert isinstance(related_id, RID), 'related_id must be RID'







    self._ptr.call_with_return(225,tuple([id._ptr, related_id._ptr]))

  @functools.native_method
  def accessibility_update_set_active_descendant(self, id:'RID'   , other_id:'RID'   ) -> None:
    r'''
				Adds an element that is an active descendant of this element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not other_id is None)
    assert isinstance(other_id, RID), 'other_id must be RID'







    self._ptr.call_with_return(226,tuple([id._ptr, other_id._ptr]))

  @functools.native_method
  def accessibility_update_set_next_on_line(self, id:'RID'   , other_id:'RID'   ) -> None:
    r'''
				Sets next element on the line.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not other_id is None)
    assert isinstance(other_id, RID), 'other_id must be RID'







    self._ptr.call_with_return(227,tuple([id._ptr, other_id._ptr]))

  @functools.native_method
  def accessibility_update_set_previous_on_line(self, id:'RID'   , other_id:'RID'   ) -> None:
    r'''
				Sets previous element on the line.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not other_id is None)
    assert isinstance(other_id, RID), 'other_id must be RID'







    self._ptr.call_with_return(228,tuple([id._ptr, other_id._ptr]))

  @functools.native_method
  def accessibility_update_set_member_of(self, id:'RID'   , group_id:'RID'   ) -> None:
    r'''
				Sets the element to be a member of the group.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not group_id is None)
    assert isinstance(group_id, RID), 'group_id must be RID'







    self._ptr.call_with_return(229,tuple([id._ptr, group_id._ptr]))

  @functools.native_method
  def accessibility_update_set_in_page_link_target(self, id:'RID'   , other_id:'RID'   ) -> None:
    r'''
				Sets target element for the link.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not other_id is None)
    assert isinstance(other_id, RID), 'other_id must be RID'







    self._ptr.call_with_return(230,tuple([id._ptr, other_id._ptr]))

  @functools.native_method
  def accessibility_update_set_error_message(self, id:'RID'   , other_id:'RID'   ) -> None:
    r'''
				Sets an element which contains an error message for this element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not other_id is None)
    assert isinstance(other_id, RID), 'other_id must be RID'







    self._ptr.call_with_return(231,tuple([id._ptr, other_id._ptr]))

  @functools.native_method
  def accessibility_update_set_live(self, id:'RID'   , live:'int'  ) -> None:
    r'''
				Sets the priority of the live region updates.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(live, (int, float)), 'live must be int or float'







    self._ptr.call_with_return(232,tuple([id._ptr, live]))

  @functools.native_method
  def accessibility_update_add_action(self, id:'RID'   , action:'int'  , callable:'Callable'   ) -> None:
    r'''
				Adds a callback for the accessibility action (action which can be performed by using a special screen reader command or buttons on the Braille display), and marks this action as supported. The action callback receives one `Variant` argument, which value depends on action type.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(action, (int, float)), 'action must be int or float'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'








    self._ptr.call_with_return(233,tuple([id._ptr, action, callable._ptr]))

  @functools.native_method
  def accessibility_update_add_custom_action(self, id:'RID'   , action_id:'int'   , action_description:'str'   ) -> None:
    r'''
				Adds support for a custom accessibility action. `action_id` is passed as an argument to the callback of `constant ACTION_CUSTOM` action.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(action_id, (int, float)), 'action_id must be int or float'
    assert(not action_description is None)
    assert isinstance(action_description, (str, String)), 'action_description must be str or String'






    assert(isinstance(action_description, (str, String)))
    py_string_action_description = action_description if isinstance(action_description, StringName) else c_utils.py_string_to_string(action_description)

    self._ptr.call_with_return(234,tuple([id._ptr, action_id, py_string_action_description._ptr]))

  @functools.native_method
  def accessibility_update_set_table_row_count(self, id:'RID'   , count:'int'   ) -> None:
    r'''
				Sets number of rows in the table.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(count, (int, float)), 'count must be int or float'







    self._ptr.call_with_return(235,tuple([id._ptr, count]))

  @functools.native_method
  def accessibility_update_set_table_column_count(self, id:'RID'   , count:'int'   ) -> None:
    r'''
				Sets number of columns in the table.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(count, (int, float)), 'count must be int or float'







    self._ptr.call_with_return(236,tuple([id._ptr, count]))

  @functools.native_method
  def accessibility_update_set_table_row_index(self, id:'RID'   , index:'int'   ) -> None:
    r'''
				Sets position of the row in the table.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(237,tuple([id._ptr, index]))

  @functools.native_method
  def accessibility_update_set_table_column_index(self, id:'RID'   , index:'int'   ) -> None:
    r'''
				Sets position of the column.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(238,tuple([id._ptr, index]))

  @functools.native_method
  def accessibility_update_set_table_cell_position(self, id:'RID'   , row_index:'int'   , column_index:'int'   ) -> None:
    r'''
				Sets cell position in the table.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(row_index, (int, float)), 'row_index must be int or float'
    assert isinstance(column_index, (int, float)), 'column_index must be int or float'








    self._ptr.call_with_return(239,tuple([id._ptr, row_index, column_index]))

  @functools.native_method
  def accessibility_update_set_table_cell_span(self, id:'RID'   , row_span:'int'   , column_span:'int'   ) -> None:
    r'''
				Sets cell row/column span.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(row_span, (int, float)), 'row_span must be int or float'
    assert isinstance(column_span, (int, float)), 'column_span must be int or float'








    self._ptr.call_with_return(240,tuple([id._ptr, row_span, column_span]))

  @functools.native_method
  def accessibility_update_set_list_item_count(self, id:'RID'   , size:'int'   ) -> None:
    r'''
				Sets number of items in the list.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'







    self._ptr.call_with_return(241,tuple([id._ptr, size]))

  @functools.native_method
  def accessibility_update_set_list_item_index(self, id:'RID'   , index:'int'   ) -> None:
    r'''
				Sets the position of the element in the list.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(242,tuple([id._ptr, index]))

  @functools.native_method
  def accessibility_update_set_list_item_level(self, id:'RID'   , level:'int'   ) -> None:
    r'''
				Sets the hierarchical level of the element in the list.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(level, (int, float)), 'level must be int or float'







    self._ptr.call_with_return(243,tuple([id._ptr, level]))

  @functools.native_method
  def accessibility_update_set_list_item_selected(self, id:'RID'   , selected:'bool'   ) -> None:
    r'''
				Sets list/tree item selected status.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(selected, bool), 'selected must be bool'







    self._ptr.call_with_return(244,tuple([id._ptr, selected]))

  @functools.native_method
  def accessibility_update_set_list_item_expanded(self, id:'RID'   , expanded:'bool'   ) -> None:
    r'''
				Sets list/tree item expanded status.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(expanded, bool), 'expanded must be bool'







    self._ptr.call_with_return(245,tuple([id._ptr, expanded]))

  @functools.native_method
  def accessibility_update_set_popup_type(self, id:'RID'   , popup:'int'  ) -> None:
    r'''
				Sets popup type for popup buttons.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(popup, (int, float)), 'popup must be int or float'







    self._ptr.call_with_return(246,tuple([id._ptr, popup]))

  @functools.native_method
  def accessibility_update_set_checked(self, id:'RID'   , checekd:'bool'   ) -> None:
    r'''
				Sets element checked state.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(checekd, bool), 'checekd must be bool'







    self._ptr.call_with_return(247,tuple([id._ptr, checekd]))

  @functools.native_method
  def accessibility_update_set_num_value(self, id:'RID'   , position:'float'   ) -> None:
    r'''
				Sets numeric value.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(position, (int, float)), 'position must be int or float'







    self._ptr.call_with_return(248,tuple([id._ptr, position]))

  @functools.native_method
  def accessibility_update_set_num_range(self, id:'RID'   , min:'float'   , max:'float'   ) -> None:
    r'''
				Sets numeric value range.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    self._ptr.call_with_return(249,tuple([id._ptr, min, max]))

  @functools.native_method
  def accessibility_update_set_num_step(self, id:'RID'   , step:'float'   ) -> None:
    r'''
				Sets numeric value step.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(step, (int, float)), 'step must be int or float'







    self._ptr.call_with_return(250,tuple([id._ptr, step]))

  @functools.native_method
  def accessibility_update_set_num_jump(self, id:'RID'   , jump:'float'   ) -> None:
    r'''
				Sets numeric value jump.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(jump, (int, float)), 'jump must be int or float'







    self._ptr.call_with_return(251,tuple([id._ptr, jump]))

  @functools.native_method
  def accessibility_update_set_scroll_x(self, id:'RID'   , position:'float'   ) -> None:
    r'''
				Sets scroll bar x position.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(position, (int, float)), 'position must be int or float'







    self._ptr.call_with_return(252,tuple([id._ptr, position]))

  @functools.native_method
  def accessibility_update_set_scroll_x_range(self, id:'RID'   , min:'float'   , max:'float'   ) -> None:
    r'''
				Sets scroll bar x range.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    self._ptr.call_with_return(253,tuple([id._ptr, min, max]))

  @functools.native_method
  def accessibility_update_set_scroll_y(self, id:'RID'   , position:'float'   ) -> None:
    r'''
				Sets scroll bar y position.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(position, (int, float)), 'position must be int or float'







    self._ptr.call_with_return(254,tuple([id._ptr, position]))

  @functools.native_method
  def accessibility_update_set_scroll_y_range(self, id:'RID'   , min:'float'   , max:'float'   ) -> None:
    r'''
				Sets scroll bar y range.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    self._ptr.call_with_return(255,tuple([id._ptr, min, max]))

  @functools.native_method
  def accessibility_update_set_text_decorations(self, id:'RID'   , underline:'bool'   , strikethrough:'bool'   , overline:'bool'   ) -> None:
    r'''
				Sets text underline/overline/strikethrough.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(underline, bool), 'underline must be bool'
    assert isinstance(strikethrough, bool), 'strikethrough must be bool'
    assert isinstance(overline, bool), 'overline must be bool'









    self._ptr.call_with_return(256,tuple([id._ptr, underline, strikethrough, overline]))

  @functools.native_method
  def accessibility_update_set_text_align(self, id:'RID'   , align:'int'  ) -> None:
    r'''
				Sets element text alignment.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(align, (int, float)), 'align must be int or float'







    self._ptr.call_with_return(257,tuple([id._ptr, align]))

  @functools.native_method
  def accessibility_update_set_text_selection(self, id:'RID'   , text_start_id:'RID'   , start_char:'int'   , text_end_id:'RID'   , end_char:'int'   ) -> None:
    r'''
				Sets text selection to the text field. `text_start_id` and `text_end_id` should be elements created by `accessibility_create_sub_text_edit_elements`. Character offsets are relative to the corresponding element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not text_start_id is None)
    assert isinstance(text_start_id, RID), 'text_start_id must be RID'
    assert isinstance(start_char, (int, float)), 'start_char must be int or float'
    assert(not text_end_id is None)
    assert isinstance(text_end_id, RID), 'text_end_id must be RID'
    assert isinstance(end_char, (int, float)), 'end_char must be int or float'










    self._ptr.call_with_return(258,tuple([id._ptr, text_start_id._ptr, start_char, text_end_id._ptr, end_char]))

  @functools.native_method
  def accessibility_update_set_flag(self, id:'RID'   , flag:'int'  , value:'bool'   ) -> None:
    r'''
				Sets element flag.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(259,tuple([id._ptr, flag, value]))

  @functools.native_method
  def accessibility_update_set_classname(self, id:'RID'   , classname:'str'   ) -> None:
    r'''
				Sets element class name.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not classname is None)
    assert isinstance(classname, (str, String)), 'classname must be str or String'





    assert(isinstance(classname, (str, String)))
    py_string_classname = classname if isinstance(classname, StringName) else c_utils.py_string_to_string(classname)

    self._ptr.call_with_return(260,tuple([id._ptr, py_string_classname._ptr]))

  @functools.native_method
  def accessibility_update_set_placeholder(self, id:'RID'   , placeholder:'str'   ) -> None:
    r'''
				Sets placeholder text.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not placeholder is None)
    assert isinstance(placeholder, (str, String)), 'placeholder must be str or String'





    assert(isinstance(placeholder, (str, String)))
    py_string_placeholder = placeholder if isinstance(placeholder, StringName) else c_utils.py_string_to_string(placeholder)

    self._ptr.call_with_return(261,tuple([id._ptr, py_string_placeholder._ptr]))

  @functools.native_method
  def accessibility_update_set_language(self, id:'RID'   , language:'str'   ) -> None:
    r'''
				Sets element text language.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(262,tuple([id._ptr, py_string_language._ptr]))

  @functools.native_method
  def accessibility_update_set_text_orientation(self, id:'RID'   , vertical:'bool'   ) -> None:
    r'''
				Sets text orientation.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(vertical, bool), 'vertical must be bool'







    self._ptr.call_with_return(263,tuple([id._ptr, vertical]))

  @functools.native_method
  def accessibility_update_set_list_orientation(self, id:'RID'   , vertical:'bool'   ) -> None:
    r'''
				Sets the orientation of the list elements.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert isinstance(vertical, bool), 'vertical must be bool'







    self._ptr.call_with_return(264,tuple([id._ptr, vertical]))

  @functools.native_method
  def accessibility_update_set_shortcut(self, id:'RID'   , shortcut:'str'   ) -> None:
    r'''
				Sets the list of keyboard shortcuts used by element.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not shortcut is None)
    assert isinstance(shortcut, (str, String)), 'shortcut must be str or String'





    assert(isinstance(shortcut, (str, String)))
    py_string_shortcut = shortcut if isinstance(shortcut, StringName) else c_utils.py_string_to_string(shortcut)

    self._ptr.call_with_return(265,tuple([id._ptr, py_string_shortcut._ptr]))

  @functools.native_method
  def accessibility_update_set_url(self, id:'RID'   , url:'str'   ) -> None:
    r'''
				Sets link URL.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not url is None)
    assert isinstance(url, (str, String)), 'url must be str or String'





    assert(isinstance(url, (str, String)))
    py_string_url = url if isinstance(url, StringName) else c_utils.py_string_to_string(url)

    self._ptr.call_with_return(266,tuple([id._ptr, py_string_url._ptr]))

  @functools.native_method
  def accessibility_update_set_role_description(self, id:'RID'   , description:'str'   ) -> None:
    r'''
				Sets element accessibility role description text.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'





    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(267,tuple([id._ptr, py_string_description._ptr]))

  @functools.native_method
  def accessibility_update_set_state_description(self, id:'RID'   , description:'str'   ) -> None:
    r'''
				Sets human-readable description of the current checked state.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'





    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(268,tuple([id._ptr, py_string_description._ptr]))

  @functools.native_method
  def accessibility_update_set_color_value(self, id:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets element color value.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(269,tuple([id._ptr, color._ptr]))

  @functools.native_method
  def accessibility_update_set_background_color(self, id:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets element background color.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(270,tuple([id._ptr, color._ptr]))

  @functools.native_method
  def accessibility_update_set_foreground_color(self, id:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets element foreground color.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(271,tuple([id._ptr, color._ptr]))

  @functools.native_method
  def ime_get_selection(self) -> typing.Union['Vector2i']:
    r'''
				Returns the text selection in the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` composition string, with the `Vector2i`'s `x` component being the caret position and `y` being the length of the selection.
				**Note:** This method is implemented only on macOS.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(272,tuple([]))
    return _ret


  @functools.native_method
  def ime_get_text(self) -> typing.Union[str]:
    r'''
				Returns the composition string contained within the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` window.
				**Note:** This method is implemented only on macOS.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(273,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def virtual_keyboard_show(self, existing_text:'str'   , position:'Rect2' = None  , type:'int'  =0, max_length:'int' =-1  , cursor_start:'int' =-1  , cursor_end:'int' =-1  ) -> None:
    r'''
				Shows the virtual keyboard if the platform has one.
				`existing_text` parameter is useful for implementing your own `LineEdit` or `TextEdit`, as it tells the virtual keyboard what text has already been typed (the virtual keyboard uses it for auto-correct and predictions).
				`position` parameter is the screen space `Rect2` of the edited text.
				`type` parameter allows configuring which type of virtual keyboard to show.
				`max_length` limits the number of characters that can be entered if different from `-1`.
				`cursor_start` can optionally define the current text cursor position if `cursor_end` is not set.
				`cursor_start` and `cursor_end` can optionally define the current text selection.
				**Note:** This method is implemented on Android, iOS and Web.
			'''
    if position is None:
      position = Rect2.new0()

    if position is None:
      position = Rect2.new0()


    assert(not existing_text is None)
    assert isinstance(existing_text, (str, String)), 'existing_text must be str or String'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(max_length, (int, float)), 'max_length must be int or float'
    assert isinstance(cursor_start, (int, float)), 'cursor_start must be int or float'
    assert isinstance(cursor_end, (int, float)), 'cursor_end must be int or float'




    assert(isinstance(existing_text, (str, String)))
    py_string_existing_text = existing_text if isinstance(existing_text, StringName) else c_utils.py_string_to_string(existing_text)






    self._ptr.call_with_return(274,tuple([py_string_existing_text._ptr, position._ptr, type, max_length, cursor_start, cursor_end]))

  @functools.native_method
  def virtual_keyboard_hide(self) -> None:
    r'''
				Hides the virtual keyboard if it is shown, does nothing otherwise.
			'''




    self._ptr.call_with_return(275,tuple([]))

  @functools.native_method
  def virtual_keyboard_get_height(self) -> typing.Union[int]:
    r'''
				Returns the on-screen keyboard's height in pixels. Returns 0 if there is no keyboard or if it is currently hidden.
				**Note:** On Android 7 and 8, the keyboard height may return 0 the first time the keyboard is opened in non-immersive mode. This behavior does not occur in immersive mode.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(276,tuple([]))
    return _ret


  @functools.native_method
  def has_hardware_keyboard(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a hardware keyboard is connected.
				**Note:** This method is implemented on Android and iOS. On other platforms, this method always returns `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))
    return _ret


  @functools.native_method
  def set_hardware_keyboard_connection_change_callback(self, callable:'Callable'   ) -> None:
    r'''
				Sets the `callable` that should be called when hardware keyboard is connected/disconnected. `callable` should accept a single `bool` parameter indicating whether the keyboard is connected (true) or disconnected (false).
				**Note:** This method is only implemented on Android.
			'''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'






    self._ptr.call_with_return(278,tuple([callable._ptr]))

  @functools.native_method
  def cursor_set_shape(self, shape:'int'  ) -> None:
    r'''
				Sets the default mouse cursor shape. The cursor's appearance will vary depending on the user's operating system and mouse cursor theme. See also `cursor_get_shape` and `cursor_set_custom_image`.
			'''

    assert isinstance(shape, (int, float)), 'shape must be int or float'






    self._ptr.call_with_return(279,tuple([shape]))

  @functools.native_method
  def cursor_get_shape(self) -> typing.Union[int]:
    r'''
				Returns the default mouse cursor shape set by `cursor_set_shape`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(280,tuple([]))
    return _ret


  @functools.native_method
  def cursor_set_custom_image(self, cursor:'py4godot_resource.Resource'   , shape:'int'  =0, hotspot:'Vector2' = None  ) -> None:
    r'''
				Sets a custom mouse cursor image for the given `shape`. This means the user's operating system and mouse cursor theme will no longer influence the mouse cursor's appearance.
				`cursor` can be either a `Texture2D` or an `Image`, and it should not be larger than 256×256 to display correctly. Optionally, `hotspot` can be set to offset the image's position relative to the click point. By default, `hotspot` is set to the top-left corner of the image. See also `cursor_set_shape`.
			'''

    if hotspot is None:
      hotspot = Vector2.new0()

    if hotspot is None:
      hotspot = Vector2.new0()

    assert(not cursor is None)
    assert isinstance(cursor, get_class('Resource')), 'cursor must be Resource'
    assert isinstance(shape, (int, float)), 'shape must be int or float'








    self._ptr.call_with_return(281,tuple([cursor._ptr, shape, hotspot._ptr]))

  @functools.native_method
  def get_swap_cancel_ok(self) -> typing.Union[bool]:
    r'''
				Returns `true` if positions of **OK** and **Cancel** buttons are swapped in dialogs. This is enabled by default on Windows to follow interface conventions, and be toggled by changing `ProjectSettings.gui/common/swap_cancel_ok`.
				**Note:** This doesn't affect native dialogs such as the ones spawned by `DisplayServer.dialog_show`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(282,tuple([]))
    return _ret


  @functools.native_method
  def enable_for_stealing_focus(self, process_id:'int'   ) -> None:
    r'''
				Allows the `process_id` PID to steal focus from this window. In other words, this disables the operating system's focus stealing protection for the specified PID.
				**Note:** This method is implemented only on Windows.
			'''

    assert isinstance(process_id, (int, float)), 'process_id must be int or float'






    self._ptr.call_with_return(283,tuple([process_id]))

  @functools.native_method
  def dialog_show(self, title:'str'   , description:'str'   , buttons:'PackedStringArray'   , callback:'Callable'   ) -> typing.Union[int]:
    r'''
				Shows a text dialog which uses the operating system's native look-and-feel. `callback` should accept a single `int` parameter which corresponds to the index of the pressed button.
				**Note:** This method is implemented if the display server has the `constant FEATURE_NATIVE_DIALOG` feature. Supported platforms include macOS, Windows, and Android.
			'''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'
    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'
    assert(not buttons is None)
    assert isinstance(buttons, PackedStringArray), 'buttons must be PackedStringArray'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'




    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)
    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)



    _ret:int
    _ret = self._ptr.call_with_return(284,tuple([py_string_title._ptr, py_string_description._ptr, buttons._ptr, callback._ptr]))
    return _ret


  @functools.native_method
  def dialog_input_text(self, title:'str'   , description:'str'   , existing_text:'str'   , callback:'Callable'   ) -> typing.Union[int]:
    r'''
				Shows a text input dialog which uses the operating system's native look-and-feel. `callback` should accept a single `String` parameter which contains the text field's contents.
				**Note:** This method is implemented if the display server has the `constant FEATURE_NATIVE_DIALOG_INPUT` feature. Supported platforms include macOS, Windows, and Android.
			'''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'
    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'
    assert(not existing_text is None)
    assert isinstance(existing_text, (str, String)), 'existing_text must be str or String'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'




    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)
    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)
    assert(isinstance(existing_text, (str, String)))
    py_string_existing_text = existing_text if isinstance(existing_text, StringName) else c_utils.py_string_to_string(existing_text)


    _ret:int
    _ret = self._ptr.call_with_return(285,tuple([py_string_title._ptr, py_string_description._ptr, py_string_existing_text._ptr, callback._ptr]))
    return _ret


  @functools.native_method
  def file_dialog_show(self, title:'str'   , current_directory:'str'   , filename:'str'   , show_hidden:'bool'   , mode:'int'  , filters:'PackedStringArray'   , callback:'Callable'   , parent_window_id:'int' =0  ) -> typing.Union[int]:
    r'''
				Displays OS native dialog for selecting files or directories in the file system.
				Each filter string in the `filters` array should be formatted like this: `*.png,*.jpg,*.jpeg;Image Files;image/png,image/jpeg`. The description text of the filter is optional and can be omitted. It is recommended to set both file extension and MIME type. See also `FileDialog.filters`.
				Callbacks have the following arguments: `status: bool, selected_paths: PackedStringArray, selected_filter_index: int`. **On Android,** the third callback argument (`selected_filter_index`) is always `0`.
				**Note:** This method is implemented if the display server has the `constant FEATURE_NATIVE_DIALOG_FILE` feature. Supported platforms include Linux (X11/Wayland), Windows, macOS, and Android (API level 29+).
				**Note:** `current_directory` might be ignored.
				**Note:** Embedded file dialog and Windows file dialog support only file extensions, while Android, Linux, and macOS file dialogs also support MIME types.
				**Note:** On Android and Linux, `show_hidden` is ignored.
				**Note:** On Android and macOS, native file dialogs have no title.
				**Note:** On macOS, sandboxed apps will save security-scoped bookmarks to retain access to the opened folders across multiple sessions. Use `OS.get_granted_permissions` to get a list of saved bookmarks.
			'''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'
    assert(not current_directory is None)
    assert isinstance(current_directory, (str, String)), 'current_directory must be str or String'
    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'
    assert isinstance(show_hidden, bool), 'show_hidden must be bool'
    assert isinstance(mode, (int, float)), 'mode must be int or float'
    assert(not filters is None)
    assert isinstance(filters, PackedStringArray), 'filters must be PackedStringArray'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(parent_window_id, (int, float)), 'parent_window_id must be int or float'




    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)
    assert(isinstance(current_directory, (str, String)))
    py_string_current_directory = current_directory if isinstance(current_directory, StringName) else c_utils.py_string_to_string(current_directory)
    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)






    _ret:int
    _ret = self._ptr.call_with_return(286,tuple([py_string_title._ptr, py_string_current_directory._ptr, py_string_filename._ptr, show_hidden, mode, filters._ptr, callback._ptr, parent_window_id]))
    return _ret


  @functools.native_method
  def file_dialog_with_options_show(self, title:'str'   , current_directory:'str'   , root:'str'   , filename:'str'   , show_hidden:'bool'   , mode:'int'  , filters:'PackedStringArray'   , options:'py4godot_dictionarytypedarray.DictionaryTypedArray'   , callback:'Callable'   , parent_window_id:'int' =0  ) -> typing.Union[int]:
    r'''
				Displays OS native dialog for selecting files or directories in the file system with additional user selectable options.
				Each filter string in the `filters` array should be formatted like this: `*.png,*.jpg,*.jpeg;Image Files;image/png,image/jpeg`. The description text of the filter is optional and can be omitted. It is recommended to set both file extension and MIME type. See also `FileDialog.filters`.
				`options` is array of `Dictionary`s with the following keys:
				- `"name"` - option's name `String`.
				- `"values"` - `PackedStringArray` of values. If empty, boolean option (check box) is used.
				- `"default"` - default selected option index (`int`) or default boolean value (`bool`).
				Callbacks have the following arguments: `status: bool, selected_paths: PackedStringArray, selected_filter_index: int, selected_option: Dictionary`.
				**Note:** This method is implemented if the display server has the `constant FEATURE_NATIVE_DIALOG_FILE_EXTRA` feature. Supported platforms include Linux (X11/Wayland), Windows, and macOS.
				**Note:** `current_directory` might be ignored.
				**Note:** Embedded file dialog and Windows file dialog support only file extensions, while Android, Linux, and macOS file dialogs also support MIME types.
				**Note:** On Linux (X11), `show_hidden` is ignored.
				**Note:** On macOS, native file dialogs have no title.
				**Note:** On macOS, sandboxed apps will save security-scoped bookmarks to retain access to the opened folders across multiple sessions. Use `OS.get_granted_permissions` to get a list of saved bookmarks.
			'''

    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'
    assert(not current_directory is None)
    assert isinstance(current_directory, (str, String)), 'current_directory must be str or String'
    assert(not root is None)
    assert isinstance(root, (str, String)), 'root must be str or String'
    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'
    assert isinstance(show_hidden, bool), 'show_hidden must be bool'
    assert isinstance(mode, (int, float)), 'mode must be int or float'
    assert(not filters is None)
    assert isinstance(filters, PackedStringArray), 'filters must be PackedStringArray'
    assert isinstance(options, get_class('DictionaryTypedArray')), 'options must be DictionaryTypedArray'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(parent_window_id, (int, float)), 'parent_window_id must be int or float'




    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)
    assert(isinstance(current_directory, (str, String)))
    py_string_current_directory = current_directory if isinstance(current_directory, StringName) else c_utils.py_string_to_string(current_directory)
    assert(isinstance(root, (str, String)))
    py_string_root = root if isinstance(root, StringName) else c_utils.py_string_to_string(root)
    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)







    _ret:int
    _ret = self._ptr.call_with_return(287,tuple([py_string_title._ptr, py_string_current_directory._ptr, py_string_root._ptr, py_string_filename._ptr, show_hidden, mode, filters._ptr, options._ptr, callback._ptr, parent_window_id]))
    return _ret


  @functools.native_method
  def beep(self) -> None:
    r'''
				Plays the beep sound from the operative system, if possible. Because it comes from the OS, the beep sound will be audible even if the application is muted. It may also be disabled for the entire OS by the user.
				**Note:** This method is implemented on macOS, Linux (X11/Wayland), and Windows.
			'''




    self._ptr.call_with_return(288,tuple([]))

  @functools.native_method
  def keyboard_get_layout_count(self) -> typing.Union[int]:
    r'''
				Returns the number of keyboard layouts.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS and Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([]))
    return _ret


  @functools.native_method
  def keyboard_get_current_layout(self) -> typing.Union[int]:
    r'''
				Returns active keyboard layout index.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS, and Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(290,tuple([]))
    return _ret


  @functools.native_method
  def keyboard_set_current_layout(self, index:'int'   ) -> None:
    r'''
				Sets the active keyboard layout.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS and Windows.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(291,tuple([index]))

  @functools.native_method
  def keyboard_get_layout_language(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the ISO-639/BCP-47 language code of the keyboard layout at position `index`.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS and Windows.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(292,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def keyboard_get_layout_name(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the localized name of the keyboard layout at position `index`.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS and Windows.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(293,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def keyboard_get_keycode_from_physical(self, keycode:'int'  ) -> typing.Union[int]:
    r'''
				Converts a physical (US QWERTY) `keycode` to one in the active keyboard layout.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS and Windows.
			'''

    assert isinstance(keycode, (int, float)), 'keycode must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(294,tuple([keycode]))
    return _ret


  @functools.native_method
  def keyboard_get_label_from_physical(self, keycode:'int'  ) -> typing.Union[int]:
    r'''
				Converts a physical (US QWERTY) `keycode` to localized label printed on the key in the active keyboard layout.
				**Note:** This method is implemented on Linux (X11/Wayland), macOS and Windows.
			'''

    assert isinstance(keycode, (int, float)), 'keycode must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(295,tuple([keycode]))
    return _ret


  @functools.native_method
  def show_emoji_and_symbol_picker(self) -> None:
    r'''
				Opens system emoji and symbol picker.
				**Note:** This method is implemented on macOS and Windows.
			'''




    self._ptr.call_with_return(296,tuple([]))

  @functools.native_method
  def color_picker(self, callback:'Callable'   ) -> typing.Union[bool]:
    r'''
				Displays OS native color picker.
				Callbacks have the following arguments: `status: bool, color: Color`.
				**Note:** This method is implemented if the display server has the `constant FEATURE_NATIVE_COLOR_PICKER` feature.
				**Note:** This method is only implemented on Linux (X11/Wayland).
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'






    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([callback._ptr]))
    return _ret


  @functools.native_method
  def process_events(self) -> None:
    r'''
				Perform window manager processing, including input flushing. See also `force_process_and_drop_events`, `Input.flush_buffered_events` and `Input.use_accumulated_input`.
			'''




    self._ptr.call_with_return(298,tuple([]))

  @functools.native_method
  def force_process_and_drop_events(self) -> None:
    r'''
				Forces window manager processing while ignoring all `InputEvent`s. See also `process_events`.
				**Note:** This method is implemented on Windows and macOS.
			'''




    self._ptr.call_with_return(299,tuple([]))

  @functools.native_method
  def set_native_icon(self, filename:'str'   ) -> None:
    r'''
				Sets the window icon (usually displayed in the top-left corner) in the operating system's _native_ format. The file at `filename` must be in `.ico` format on Windows or `.icns` on macOS. By using specially crafted `.ico` or `.icns` icons, `set_native_icon` allows specifying different icons depending on the size the icon is displayed at. This size is determined by the operating system and user preferences (including the display scale factor). To use icons in other formats, use `set_icon` instead.
				**Note:** Requires support for `constant FEATURE_NATIVE_ICON`.
			'''

    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'




    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)

    self._ptr.call_with_return(300,tuple([py_string_filename._ptr]))

  @functools.native_method
  def set_icon(self, image:'py4godot_image.Image'   ) -> None:
    r'''
				Sets the window icon (usually displayed in the top-left corner) with an `Image`. To use icons in the operating system's native format, use `set_native_icon` instead.
				**Note:** Requires support for `constant FEATURE_ICON`.
			'''

    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'






    self._ptr.call_with_return(301,tuple([image._ptr]))

  @functools.native_method
  def create_status_indicator(self, icon:'py4godot_texture2d.Texture2D'   , tooltip:'str'   , callback:'Callable'   ) -> typing.Union[int]:
    r'''
				Creates a new application status indicator with the specified icon, tooltip, and activation callback.
				`callback` should take two arguments: the pressed mouse button (one of the `enum MouseButton` constants) and the click position in screen coordinates (a `Vector2i`).
			'''

    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'





    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)


    _ret = 0
    _ret = self._ptr.call_with_return(302,tuple([icon._ptr, py_string_tooltip._ptr, callback._ptr]))
    return _ret


  @functools.native_method
  def status_indicator_set_icon(self, id:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the application status indicator icon.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'







    self._ptr.call_with_return(303,tuple([id, icon._ptr]))

  @functools.native_method
  def status_indicator_set_tooltip(self, id:'int'   , tooltip:'str'   ) -> None:
    r'''
				Sets the application status indicator tooltip.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'





    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(304,tuple([id, py_string_tooltip._ptr]))

  @functools.native_method
  def status_indicator_set_menu(self, id:'int'   , menu_rid:'RID'   ) -> None:
    r'''
				Sets the application status indicator native popup menu.
				**Note:** On macOS, the menu is activated by any mouse button. Its activation callback is _not_ triggered.
				**Note:** On Windows, the menu is activated by the right mouse button, selecting the status icon and pressing `kbd`Shift + F10`/kbd`, or the applications key. The menu's activation callback for the other mouse buttons is still triggered.
				**Note:** Native popup is only supported if `NativeMenu` supports the `constant NativeMenu.FEATURE_POPUP_MENU` feature.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not menu_rid is None)
    assert isinstance(menu_rid, RID), 'menu_rid must be RID'







    self._ptr.call_with_return(305,tuple([id, menu_rid._ptr]))

  @functools.native_method
  def status_indicator_set_callback(self, id:'int'   , callback:'Callable'   ) -> None:
    r'''
				Sets the application status indicator activation callback. `callback` should take two arguments: `int` mouse button index (one of `enum MouseButton` values) and `Vector2i` click position in screen coordinates.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'







    self._ptr.call_with_return(306,tuple([id, callback._ptr]))

  @functools.native_method
  def status_indicator_get_rect(self, id:'int'   ) -> typing.Union['Rect2']:
    r'''
				Returns the rectangle for the given status indicator `id` in screen coordinates. If the status indicator is not visible, returns an empty `Rect2`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(307,tuple([id]))
    return _ret


  @functools.native_method
  def delete_status_indicator(self, id:'int'   ) -> None:
    r'''
				Removes the application status indicator.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    self._ptr.call_with_return(308,tuple([id]))

  @functools.native_method
  def tablet_get_driver_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of available tablet drivers.
				**Note:** This method is implemented only on Windows.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(309,tuple([]))
    return _ret


  @functools.native_method
  def tablet_get_driver_name(self, idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the tablet driver name for the given index.
				**Note:** This method is implemented only on Windows.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(310,tuple([idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def tablet_get_current_driver(self) -> typing.Union[str]:
    r'''
				Returns current active tablet driver name.
				**Note:** This method is implemented only on Windows.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(311,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def tablet_set_current_driver(self, name:'str'   ) -> None:
    r'''
				Set active tablet driver name.
				Supported drivers:
				- `winink`: Windows Ink API, default.
				- `wintab`: Wacom Wintab API (compatible device driver required).
				- `dummy`: Dummy driver, tablet input is disabled.
				**Note:** This method is implemented only on Windows.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(312,tuple([py_string_name._ptr]))

  @functools.native_method
  def is_window_transparency_available(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the window background can be made transparent. This method returns `false` if `ProjectSettings.display/window/per_pixel_transparency/allowed` is set to `false`, or if transparency is not supported by the renderer or OS compositor.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(313,tuple([]))
    return _ret


  @functools.native_method
  def register_additional_output(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Registers an `Object` which represents an additional output that will be rendered too, beyond normal windows. The `Object` is only used as an identifier, which can be later passed to `unregister_additional_output`.
				This can be used to prevent Godot from skipping rendering when no normal windows are visible.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'






    self._ptr.call_with_return(314,tuple([object_._ptr]))

  @functools.native_method
  def unregister_additional_output(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Unregisters an `Object` representing an additional output, that was registered via `register_additional_output`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'






    self._ptr.call_with_return(315,tuple([object_._ptr]))

  @functools.native_method
  def has_additional_outputs(self) -> typing.Union[bool]:
    r'''
				Returns `true` if any additional outputs have been registered via `register_additional_output`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(316,tuple([]))
    return _ret



register_cast_function('DisplayServer', DisplayServer.cast)
register_class('DisplayServer', DisplayServer)
