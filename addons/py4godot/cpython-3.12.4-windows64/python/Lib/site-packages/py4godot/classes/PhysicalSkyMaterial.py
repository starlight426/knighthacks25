# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.Material as py4godot_material 
from py4godot.wrappers.wrappers import CPPPhysicalSkyMaterialWrapper


class PhysicalSkyMaterial(py4godot_material.Material):
  r'''
		The `PhysicalSkyMaterial` uses the Preetham analytic daylight model to draw a sky based on physical properties. This results in a substantially more realistic sky than the `ProceduralSkyMaterial`, but it is slightly slower and less flexible.
		The `PhysicalSkyMaterial` only supports one sun. The color, energy, and direction of the sun are taken from the first `DirectionalLight3D` in the scene tree.
	'''

  @staticmethod
  def constructor():
    class_ = PhysicalSkyMaterial.construct_without_init()
    class_._ptr = constructor(588,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PhysicalSkyMaterial.construct_without_init()
    class_._ptr = constructor(588,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPhysicalSkyMaterialWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(588,0, ())


  def generate_wrapper(self):
    return CPPPhysicalSkyMaterialWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PhysicalSkyMaterial.__new__(PhysicalSkyMaterial)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PhysicalSkyMaterial'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicalSkyMaterial.construct_without_init()
    cls._ptr = CPPPhysicalSkyMaterialWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicalSkyMaterial.construct_without_init()
    cls._ptr = CPPPhysicalSkyMaterialWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def rayleigh_coefficient(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_rayleigh_coefficient()
    return _ret
  @rayleigh_coefficient.setter
  def rayleigh_coefficient(self,  value:'float'):
    self.set_rayleigh_coefficient(value)
  @property
  def rayleigh_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_rayleigh_color()
    return _ret
  @rayleigh_color.setter
  def rayleigh_color(self,  value:'Color'):
    self.set_rayleigh_color(value)
  @property
  def mie_coefficient(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_mie_coefficient()
    return _ret
  @mie_coefficient.setter
  def mie_coefficient(self,  value:'float'):
    self.set_mie_coefficient(value)
  @property
  def mie_eccentricity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_mie_eccentricity()
    return _ret
  @mie_eccentricity.setter
  def mie_eccentricity(self,  value:'float'):
    self.set_mie_eccentricity(value)
  @property
  def mie_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_mie_color()
    return _ret
  @mie_color.setter
  def mie_color(self,  value:'Color'):
    self.set_mie_color(value)
  @property
  def turbidity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_turbidity()
    return _ret
  @turbidity.setter
  def turbidity(self,  value:'float'):
    self.set_turbidity(value)
  @property
  def sun_disk_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sun_disk_scale()
    return _ret
  @sun_disk_scale.setter
  def sun_disk_scale(self,  value:'float'):
    self.set_sun_disk_scale(value)
  @property
  def ground_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_ground_color()
    return _ret
  @ground_color.setter
  def ground_color(self,  value:'Color'):
    self.set_ground_color(value)
  @property
  def energy_multiplier(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_energy_multiplier()
    return _ret
  @energy_multiplier.setter
  def energy_multiplier(self,  value:'float'):
    self.set_energy_multiplier(value)
  @property
  def use_debanding(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_debanding()
    return _ret
  @use_debanding.setter
  def use_debanding(self,  value:'bool'):
    self.set_use_debanding(value)
  @property
  def night_sky(self) -> typing.Any:
    r''''''
    _ret = self. get_night_sky()
    return _ret
  @night_sky.setter
  def night_sky(self,  value:'py4godot_object.Object'):
    self.set_night_sky(value)
  @functools.native_method
  def set_rayleigh_coefficient(self, rayleigh:'float'   ) -> None:
    r''''''

    assert isinstance(rayleigh, (int, float)), 'rayleigh must be int or float'

    self.py__rayleigh_coefficient = rayleigh






    self._ptr.call_with_return(87,tuple([rayleigh]))

  @functools.native_method
  def get_rayleigh_coefficient(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_rayleigh_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__rayleigh_color = color






    self._ptr.call_with_return(89,tuple([color._ptr]))

  @functools.native_method
  def get_rayleigh_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_mie_coefficient(self, mie:'float'   ) -> None:
    r''''''

    assert isinstance(mie, (int, float)), 'mie must be int or float'

    self.py__mie_coefficient = mie






    self._ptr.call_with_return(91,tuple([mie]))

  @functools.native_method
  def get_mie_coefficient(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_mie_eccentricity(self, eccentricity:'float'   ) -> None:
    r''''''

    assert isinstance(eccentricity, (int, float)), 'eccentricity must be int or float'

    self.py__mie_eccentricity = eccentricity






    self._ptr.call_with_return(93,tuple([eccentricity]))

  @functools.native_method
  def get_mie_eccentricity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_mie_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__mie_color = color






    self._ptr.call_with_return(95,tuple([color._ptr]))

  @functools.native_method
  def get_mie_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([]))

    return _ret


  @functools.native_method
  def set_turbidity(self, turbidity:'float'   ) -> None:
    r''''''

    assert isinstance(turbidity, (int, float)), 'turbidity must be int or float'

    self.py__turbidity = turbidity






    self._ptr.call_with_return(97,tuple([turbidity]))

  @functools.native_method
  def get_turbidity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_sun_disk_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'

    self.py__sun_disk_scale = scale






    self._ptr.call_with_return(99,tuple([scale]))

  @functools.native_method
  def get_sun_disk_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_ground_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'

    self.py__ground_color = color






    self._ptr.call_with_return(101,tuple([color._ptr]))

  @functools.native_method
  def get_ground_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def set_energy_multiplier(self, multiplier:'float'   ) -> None:
    r''''''

    assert isinstance(multiplier, (int, float)), 'multiplier must be int or float'

    self.py__energy_multiplier = multiplier






    self._ptr.call_with_return(103,tuple([multiplier]))

  @functools.native_method
  def get_energy_multiplier(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([]))

    return _ret


  @functools.native_method
  def set_use_debanding(self, use_debanding:'bool'   ) -> None:
    r''''''

    assert isinstance(use_debanding, bool), 'use_debanding must be bool'

    self.py__use_debanding = use_debanding






    self._ptr.call_with_return(105,tuple([use_debanding]))

  @functools.native_method
  def get_use_debanding(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([]))

    return _ret


  @functools.native_method
  def set_night_sky(self, night_sky:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not night_sky is None)
    assert isinstance(night_sky, get_class('Texture2D')), 'night_sky must be Texture2D'

    self.py__night_sky = night_sky






    self._ptr.call_with_return(107,tuple([night_sky._ptr]))

  @functools.native_method
  def get_night_sky(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('PhysicalSkyMaterial', PhysicalSkyMaterial.cast)
register_class('PhysicalSkyMaterial', PhysicalSkyMaterial)
