# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
from py4godot.wrappers.wrappers import CPPEditorCommandPaletteWrapper


class EditorCommandPalette(py4godot_confirmationdialog.ConfirmationDialog):
  r'''
		Object that holds all the available Commands and their shortcuts text. These Commands can be accessed through **Editor > Command Palette** menu.
		Command key names use slash delimiters to distinguish sections, for example: `"example/command1"` then `example` will be the section name.
		
		```gdscript
		var command_palette = EditorInterface.get_command_palette()
		# external_command is a function that will be called with the command is executed.
		var command_callable = Callable(self, "external_command").bind(arguments)
		command_palette.add_command("command", "test/command",command_callable)
		```
		
		
		**Note:** This class shouldn't be instantiated directly. Instead, access the singleton using `EditorInterface.get_command_palette`.
	'''

  @staticmethod
  def constructor():
    class_ = EditorCommandPalette.construct_without_init()
    class_._ptr = constructor(266,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorCommandPalette.construct_without_init()
    class_._ptr = constructor(266,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorCommandPaletteWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(266,0, ())


  def generate_wrapper(self):
    return CPPEditorCommandPaletteWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorCommandPalette.__new__(EditorCommandPalette)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorCommandPalette'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorCommandPalette.construct_without_init()
    cls._ptr = CPPEditorCommandPaletteWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorCommandPalette.construct_without_init()
    cls._ptr = CPPEditorCommandPaletteWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def add_command(self, command_name:'str'   , key_name:'str'   , binded_callable:'Callable'   , shortcut_text:'str' ="None"  ) -> None:
    r'''
				Adds a custom command to EditorCommandPalette.
				- `command_name`: `String` (Name of the **Command**. This is displayed to the user.)
				- `key_name`: `String` (Name of the key for a particular **Command**. This is used to uniquely identify the **Command**.)
				- `binded_callable`: `Callable` (Callable of the **Command**. This will be executed when the **Command** is selected.)
				- `shortcut_text`: `String` (Shortcut text of the **Command** if available.)
			'''
    if shortcut_text is None:
      shortcut_text = String.new0()
    if shortcut_text is None:
      shortcut_text = String.new0()

    assert(not command_name is None)
    assert isinstance(command_name, (str, String)), 'command_name must be str or String'
    assert(not key_name is None)
    assert isinstance(key_name, (str, String)), 'key_name must be str or String'
    assert(not binded_callable is None)
    assert isinstance(binded_callable, Callable), 'binded_callable must be Callable'




    assert(isinstance(command_name, (str, String)))
    py_string_command_name = command_name if isinstance(command_name, StringName) else c_utils.py_string_to_string(command_name)
    assert(isinstance(key_name, (str, String)))
    py_string_key_name = key_name if isinstance(key_name, StringName) else c_utils.py_string_to_string(key_name)

    assert(isinstance(shortcut_text, (str, String)))
    py_string_shortcut_text = shortcut_text if isinstance(shortcut_text, StringName) else c_utils.py_string_to_string(shortcut_text)

    self._ptr.call_with_return(453,tuple([py_string_command_name._ptr, py_string_key_name._ptr, binded_callable._ptr, py_string_shortcut_text._ptr]))

  @functools.native_method
  def remove_command(self, key_name:'str'   ) -> None:
    r'''
				Removes the custom command from EditorCommandPalette.
				- `key_name`: `String` (Name of the key for a particular **Command**.)
			'''

    assert(not key_name is None)
    assert isinstance(key_name, (str, String)), 'key_name must be str or String'




    assert(isinstance(key_name, (str, String)))
    py_string_key_name = key_name if isinstance(key_name, StringName) else c_utils.py_string_to_string(key_name)

    self._ptr.call_with_return(454,tuple([py_string_key_name._ptr]))


register_cast_function('EditorCommandPalette', EditorCommandPalette.cast)
register_class('EditorCommandPalette', EditorCommandPalette)
