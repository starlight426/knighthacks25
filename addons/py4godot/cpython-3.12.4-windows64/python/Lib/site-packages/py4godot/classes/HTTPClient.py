# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.StreamPeerBuffer as py4godot_streampeerbuffer 
  import py4godot.classes.TLSOptions as py4godot_tlsoptions 
  import py4godot.classes.StreamPeerExtension as py4godot_streampeerextension 
  import py4godot.classes.StreamPeer as py4godot_streampeer 
  import py4godot.classes.StreamPeerTCP as py4godot_streampeertcp 
  import py4godot.classes.StreamPeerTLS as py4godot_streampeertls 
  import py4godot.classes.StreamPeerGZIP as py4godot_streampeergzip 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPHTTPClientWrapper

class Method:
  METHOD_GET = 0
  METHOD_HEAD = 1
  METHOD_POST = 2
  METHOD_PUT = 3
  METHOD_DELETE = 4
  METHOD_OPTIONS = 5
  METHOD_TRACE = 6
  METHOD_CONNECT = 7
  METHOD_PATCH = 8
  METHOD_MAX = 9
class Status:
  STATUS_DISCONNECTED = 0
  STATUS_RESOLVING = 1
  STATUS_CANT_RESOLVE = 2
  STATUS_CONNECTING = 3
  STATUS_CANT_CONNECT = 4
  STATUS_CONNECTED = 5
  STATUS_REQUESTING = 6
  STATUS_BODY = 7
  STATUS_CONNECTION_ERROR = 8
  STATUS_TLS_HANDSHAKE_ERROR = 9
class ResponseCode:
  RESPONSE_CONTINUE = 100
  RESPONSE_SWITCHING_PROTOCOLS = 101
  RESPONSE_PROCESSING = 102
  RESPONSE_OK = 200
  RESPONSE_CREATED = 201
  RESPONSE_ACCEPTED = 202
  RESPONSE_NON_AUTHORITATIVE_INFORMATION = 203
  RESPONSE_NO_CONTENT = 204
  RESPONSE_RESET_CONTENT = 205
  RESPONSE_PARTIAL_CONTENT = 206
  RESPONSE_MULTI_STATUS = 207
  RESPONSE_ALREADY_REPORTED = 208
  RESPONSE_IM_USED = 226
  RESPONSE_MULTIPLE_CHOICES = 300
  RESPONSE_MOVED_PERMANENTLY = 301
  RESPONSE_FOUND = 302
  RESPONSE_SEE_OTHER = 303
  RESPONSE_NOT_MODIFIED = 304
  RESPONSE_USE_PROXY = 305
  RESPONSE_SWITCH_PROXY = 306
  RESPONSE_TEMPORARY_REDIRECT = 307
  RESPONSE_PERMANENT_REDIRECT = 308
  RESPONSE_BAD_REQUEST = 400
  RESPONSE_UNAUTHORIZED = 401
  RESPONSE_PAYMENT_REQUIRED = 402
  RESPONSE_FORBIDDEN = 403
  RESPONSE_NOT_FOUND = 404
  RESPONSE_METHOD_NOT_ALLOWED = 405
  RESPONSE_NOT_ACCEPTABLE = 406
  RESPONSE_PROXY_AUTHENTICATION_REQUIRED = 407
  RESPONSE_REQUEST_TIMEOUT = 408
  RESPONSE_CONFLICT = 409
  RESPONSE_GONE = 410
  RESPONSE_LENGTH_REQUIRED = 411
  RESPONSE_PRECONDITION_FAILED = 412
  RESPONSE_REQUEST_ENTITY_TOO_LARGE = 413
  RESPONSE_REQUEST_URI_TOO_LONG = 414
  RESPONSE_UNSUPPORTED_MEDIA_TYPE = 415
  RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE = 416
  RESPONSE_EXPECTATION_FAILED = 417
  RESPONSE_IM_A_TEAPOT = 418
  RESPONSE_MISDIRECTED_REQUEST = 421
  RESPONSE_UNPROCESSABLE_ENTITY = 422
  RESPONSE_LOCKED = 423
  RESPONSE_FAILED_DEPENDENCY = 424
  RESPONSE_UPGRADE_REQUIRED = 426
  RESPONSE_PRECONDITION_REQUIRED = 428
  RESPONSE_TOO_MANY_REQUESTS = 429
  RESPONSE_REQUEST_HEADER_FIELDS_TOO_LARGE = 431
  RESPONSE_UNAVAILABLE_FOR_LEGAL_REASONS = 451
  RESPONSE_INTERNAL_SERVER_ERROR = 500
  RESPONSE_NOT_IMPLEMENTED = 501
  RESPONSE_BAD_GATEWAY = 502
  RESPONSE_SERVICE_UNAVAILABLE = 503
  RESPONSE_GATEWAY_TIMEOUT = 504
  RESPONSE_HTTP_VERSION_NOT_SUPPORTED = 505
  RESPONSE_VARIANT_ALSO_NEGOTIATES = 506
  RESPONSE_INSUFFICIENT_STORAGE = 507
  RESPONSE_LOOP_DETECTED = 508
  RESPONSE_NOT_EXTENDED = 510
  RESPONSE_NETWORK_AUTH_REQUIRED = 511


class HTTPClient(py4godot_refcounted.RefCounted):
  r'''
		Hyper-text transfer protocol client (sometimes called "User Agent"). Used to make HTTP requests to download web content, upload files and other data or to communicate with various services, among other use cases.
		See the `HTTPRequest` node for a higher-level alternative.
		**Note:** This client only needs to connect to a host once (see `connect_to_host`) to send multiple requests. Because of this, methods that take URLs usually take just the part after the host instead of the full URL, as the client is already connected to a host. See `request` for a full example and to get started.
		An `HTTPClient` should be reused between multiple requests or to connect to different hosts instead of creating one client per request. Supports Transport Layer Security (TLS), including server certificate verification. HTTP status codes in the 2xx range indicate success, 3xx redirection (i.e. "try again, but over here"), 4xx something was wrong with the request, and 5xx something went wrong on the server's side.
		For more information on HTTP, see `url=https://developer.mozilla.org/en-US/docs/Web/HTTP`MDN's documentation on HTTP`/url` (or read `url=https://tools.ietf.org/html/rfc2616`RFC 2616`/url` to get it straight from the source).
		**Note:** When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
		**Note:** It's recommended to use transport encryption (TLS) and to avoid sending sensitive information (such as login credentials) in HTTP GET URL parameters. Consider using HTTP POST requests or HTTP headers for such information instead.
		**Note:** When performing HTTP requests from a project exported to Web, keep in mind the remote server may not allow requests from foreign origins due to `url=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS`CORS`/url`. If you host the server in question, you should modify its backend to allow requests from foreign origins by adding the `Access-Control-Allow-Origin: *` HTTP header.
		**Note:** TLS support is currently limited to TLSv1.2 and TLSv1.3. Attempting to connect to a server that only supports older (insecure) TLS versions will return an error.
		**Warning:** TLS certificate revocation and certificate pinning are currently not supported. Revoked certificates are accepted as long as they are otherwise valid. If this is a concern, you may want to use automatically managed certificates with a short validity period.
	'''

  @staticmethod
  def constructor():
    class_ = HTTPClient.construct_without_init()
    class_._ptr = constructor(397,0, ())
    return class_
  @staticmethod
  def new():
    class_ = HTTPClient.construct_without_init()
    class_._ptr = constructor(397,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPHTTPClientWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(397,0, ())


  def generate_wrapper(self):
    return CPPHTTPClientWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = HTTPClient.__new__(HTTPClient)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'HTTPClient'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = HTTPClient.construct_without_init()
    cls._ptr = CPPHTTPClientWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = HTTPClient.construct_without_init()
    cls._ptr = CPPHTTPClientWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def blocking_mode_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_blocking_mode_enabled()
    return _ret
  @blocking_mode_enabled.setter
  def blocking_mode_enabled(self,  value:'bool'):
    self.set_blocking_mode(value)
  @property
  def connection(self) -> typing.Any:
    r''''''
    _ret = self. get_connection()
    return _ret
  @connection.setter
  def connection(self,  value:'py4godot_object.Object'):
    self.set_connection(value)
  @property
  def read_chunk_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_read_chunk_size()
    return _ret
  @read_chunk_size.setter
  def read_chunk_size(self,  value:'int'):
    self.set_read_chunk_size(value)
  @functools.native_method
  def connect_to_host(self, host:'str'   , port:'int' =-1  , tls_options:'py4godot_tlsoptions.TLSOptions' = None  ) -> typing.Union[int]:
    r'''
				Connects to a host. This needs to be done before any requests are sent.
				If no `port` is specified (or `-1` is used), it is automatically set to 80 for HTTP and 443 for HTTPS. You can pass the optional `tls_options` parameter to customize the trusted certification authorities, or the common name verification when using HTTPS. See `TLSOptions.client` and `TLSOptions.client_unsafe`.
			'''
    if tls_options is None:
      tls_options = c_utils.empty_object
    if tls_options is None:
      tls_options = c_utils.empty_object

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(port, (int, float)), 'port must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)



    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([py_string_host._ptr, port, tls_options._ptr]))
    return _ret


  @functools.native_method
  def set_connection(self, connection:'py4godot_streampeer.StreamPeer'   ) -> None:
    r''''''

    assert(not connection is None)
    assert isinstance(connection, get_class('StreamPeer')), 'connection must be StreamPeer'

    self.py__connection = connection






    self._ptr.call_with_return(54,tuple([connection._ptr]))

  @functools.native_method
  def get_connection(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: StreamPeer
    _ret._ptr = self._ptr.call_with_return(55,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def request_raw(self, method:'int'  , url:'str'   , headers:'PackedStringArray'   , body:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Sends a raw HTTP request to the connected host with the given `method`.
				The URL parameter is usually just the part after the host, so for `https://example.com/index.php`, it is `/index.php`. When sending requests to an HTTP proxy server, it should be an absolute URL. For `constant HTTPClient.METHOD_OPTIONS` requests, `*` is also allowed. For `constant HTTPClient.METHOD_CONNECT` requests, it should be the authority component (`host:port`).
				`headers` are HTTP request headers.
				Sends the body data raw, as a byte array and does not encode it in any way.
			'''

    assert isinstance(method, (int, float)), 'method must be int or float'
    assert(not url is None)
    assert isinstance(url, (str, String)), 'url must be str or String'
    assert(not headers is None)
    assert isinstance(headers, PackedStringArray), 'headers must be PackedStringArray'
    assert(not body is None)
    assert isinstance(body, PackedByteArray), 'body must be PackedByteArray'





    assert(isinstance(url, (str, String)))
    py_string_url = url if isinstance(url, StringName) else c_utils.py_string_to_string(url)



    _ret:int
    _ret = self._ptr.call_with_return(56,tuple([method, py_string_url._ptr, headers._ptr, body._ptr]))
    return _ret


  @functools.native_method
  def request(self, method:'int'  , url:'str'   , headers:'PackedStringArray'   , body:'str' =""  ) -> typing.Union[int]:
    r'''
				Sends an HTTP request to the connected host with the given `method`.
				The URL parameter is usually just the part after the host, so for `https://example.com/index.php`, it is `/index.php`. When sending requests to an HTTP proxy server, it should be an absolute URL. For `constant HTTPClient.METHOD_OPTIONS` requests, `*` is also allowed. For `constant HTTPClient.METHOD_CONNECT` requests, it should be the authority component (`host:port`).
				`headers` are HTTP request headers.
				To create a POST request with query strings to push to the server, do:
				
				```gdscript
				var fields = { "username": "user", "password": "pass" }
				var query_string = http_client.query_string_from_dict(fields)
				var headers = `"Content-Type: application/x-www-form-urlencoded", "Content-Length: " + str(query_string.length())`
				var result = http_client.request(http_client.METHOD_POST, "/index.php", headers, query_string)
				```
				
				
				**Note:** The `body` parameter is ignored if `method` is `constant HTTPClient.METHOD_GET`. This is because GET methods can't contain request data. As a workaround, you can pass request data as a query string in the URL. See `String.uri_encode` for an example.
			'''
    if body is None:
      body = String.new0()
    if body is None:
      body = String.new0()

    assert isinstance(method, (int, float)), 'method must be int or float'
    assert(not url is None)
    assert isinstance(url, (str, String)), 'url must be str or String'
    assert(not headers is None)
    assert isinstance(headers, PackedStringArray), 'headers must be PackedStringArray'





    assert(isinstance(url, (str, String)))
    py_string_url = url if isinstance(url, StringName) else c_utils.py_string_to_string(url)

    assert(isinstance(body, (str, String)))
    py_string_body = body if isinstance(body, StringName) else c_utils.py_string_to_string(body)

    _ret:int
    _ret = self._ptr.call_with_return(57,tuple([method, py_string_url._ptr, headers._ptr, py_string_body._ptr]))
    return _ret


  @functools.native_method
  def close(self) -> None:
    r'''
				Closes the current connection, allowing reuse of this `HTTPClient`.
			'''




    self._ptr.call_with_return(58,tuple([]))

  @functools.native_method
  def has_response(self) -> typing.Union[bool]:
    r'''
				If `true`, this `HTTPClient` has a response available.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([]))
    return _ret


  @functools.native_method
  def is_response_chunked(self) -> typing.Union[bool]:
    r'''
				If `true`, this `HTTPClient` has a response that is chunked.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([]))
    return _ret


  @functools.native_method
  def get_response_code(self) -> typing.Union[int]:
    r'''
				Returns the response's HTTP status code.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([]))
    return _ret


  @functools.native_method
  def get_response_headers(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the response headers.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))
    return _ret


  @functools.native_method
  def get_response_headers_as_dictionary(self) -> typing.Union['Dictionary']:
    r'''
				Returns all response headers as a `Dictionary`. Each entry is composed by the header name, and a `String` containing the values separated by `"; "`. The casing is kept the same as the headers were received.
				```gdscript
				{
					"content-length": 12,
					"Content-Type": "application/json; charset=UTF-8",
				}
				```
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([]))
    return _ret


  @functools.native_method
  def get_response_body_length(self) -> typing.Union[int]:
    r'''
				Returns the response's body length.
				**Note:** Some Web servers may not send a body length. In this case, the value returned will be `-1`. If using chunked transfer encoding, the body length will also be `-1`.
				**Note:** This function always returns `-1` on the Web platform due to browsers limitations.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([]))
    return _ret


  @functools.native_method
  def read_response_body_chunk(self) -> typing.Union['PackedByteArray']:
    r'''
				Reads one chunk from the response.
			'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(65,tuple([]))
    return _ret


  @functools.native_method
  def set_read_chunk_size(self, bytes:'int'   ) -> None:
    r''''''

    assert isinstance(bytes, (int, float)), 'bytes must be int or float'

    self.py__read_chunk_size = bytes






    self._ptr.call_with_return(66,tuple([bytes]))

  @functools.native_method
  def get_read_chunk_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([]))

    return _ret


  @functools.native_method
  def set_blocking_mode(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__blocking_mode_enabled = enabled






    self._ptr.call_with_return(68,tuple([enabled]))

  @functools.native_method
  def is_blocking_mode_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))

    return _ret


  @functools.native_method
  def get_status(self) -> typing.Union[int]:
    r'''
				Returns a `enum Status` constant. Need to call `poll` in order to get status updates.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def poll(self) -> typing.Union[int]:
    r'''
				This needs to be called in order to have any request processed. Check results with `get_status`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(71,tuple([]))
    return _ret


  @functools.native_method
  def set_http_proxy(self, host:'str'   , port:'int'   ) -> None:
    r'''
				Sets the proxy server for HTTP requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			'''

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(port, (int, float)), 'port must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)


    self._ptr.call_with_return(72,tuple([py_string_host._ptr, port]))

  @functools.native_method
  def set_https_proxy(self, host:'str'   , port:'int'   ) -> None:
    r'''
				Sets the proxy server for HTTPS requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			'''

    assert(not host is None)
    assert isinstance(host, (str, String)), 'host must be str or String'
    assert isinstance(port, (int, float)), 'port must be int or float'




    assert(isinstance(host, (str, String)))
    py_string_host = host if isinstance(host, StringName) else c_utils.py_string_to_string(host)


    self._ptr.call_with_return(73,tuple([py_string_host._ptr, port]))

  @functools.native_method
  def query_string_from_dict(self, fields:'Dictionary'   ) -> typing.Union[str]:
    r'''
				Generates a GET/POST application/x-www-form-urlencoded style query string from a provided dictionary, e.g.:
				
				```gdscript
				var fields = { "username": "user", "password": "pass" }
				var query_string = http_client.query_string_from_dict(fields)
				# Returns "username=user&password=pass"
				```
				
				
				Furthermore, if a key has a `null` value, only the key itself is added, without equal sign and value. If the value is an array, for each value in it a pair with the same key is added.
				
				```gdscript
				var fields = { "single": 123, "not_valued": null, "multiple": `22, 33, 44` }
				var query_string = http_client.query_string_from_dict(fields)
				# Returns "single=123&not_valued&multiple=22&multiple=33&multiple=44"
				```
				
				
			'''

    assert(not fields is None)
    assert isinstance(fields, Dictionary), 'fields must be Dictionary'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([fields._ptr]))
    return utils.gd_string_to_py_string(_ret)



register_cast_function('HTTPClient', HTTPClient.cast)
register_class('HTTPClient', HTTPClient)
