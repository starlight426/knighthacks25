# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TileSetSource as py4godot_tilesetsource 
  import py4godot.classes.PhysicsMaterial as py4godot_physicsmaterial 
  import py4godot.classes.TileMapPattern as py4godot_tilemappattern 
  import py4godot.classes.TileSetScenesCollectionSource as py4godot_tilesetscenescollectionsource 
  import py4godot.classes.TileSetAtlasSource as py4godot_tilesetatlassource 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPTileSetWrapper

class TileShape:
  TILE_SHAPE_SQUARE = 0
  TILE_SHAPE_ISOMETRIC = 1
  TILE_SHAPE_HALF_OFFSET_SQUARE = 2
  TILE_SHAPE_HEXAGON = 3
class TileLayout:
  TILE_LAYOUT_STACKED = 0
  TILE_LAYOUT_STACKED_OFFSET = 1
  TILE_LAYOUT_STAIRS_RIGHT = 2
  TILE_LAYOUT_STAIRS_DOWN = 3
  TILE_LAYOUT_DIAMOND_RIGHT = 4
  TILE_LAYOUT_DIAMOND_DOWN = 5
class TileOffsetAxis:
  TILE_OFFSET_AXIS_HORIZONTAL = 0
  TILE_OFFSET_AXIS_VERTICAL = 1
class CellNeighbor:
  CELL_NEIGHBOR_RIGHT_SIDE = 0
  CELL_NEIGHBOR_RIGHT_CORNER = 1
  CELL_NEIGHBOR_BOTTOM_RIGHT_SIDE = 2
  CELL_NEIGHBOR_BOTTOM_RIGHT_CORNER = 3
  CELL_NEIGHBOR_BOTTOM_SIDE = 4
  CELL_NEIGHBOR_BOTTOM_CORNER = 5
  CELL_NEIGHBOR_BOTTOM_LEFT_SIDE = 6
  CELL_NEIGHBOR_BOTTOM_LEFT_CORNER = 7
  CELL_NEIGHBOR_LEFT_SIDE = 8
  CELL_NEIGHBOR_LEFT_CORNER = 9
  CELL_NEIGHBOR_TOP_LEFT_SIDE = 10
  CELL_NEIGHBOR_TOP_LEFT_CORNER = 11
  CELL_NEIGHBOR_TOP_SIDE = 12
  CELL_NEIGHBOR_TOP_CORNER = 13
  CELL_NEIGHBOR_TOP_RIGHT_SIDE = 14
  CELL_NEIGHBOR_TOP_RIGHT_CORNER = 15
class TerrainMode:
  TERRAIN_MODE_MATCH_CORNERS_AND_SIDES = 0
  TERRAIN_MODE_MATCH_CORNERS = 1
  TERRAIN_MODE_MATCH_SIDES = 2


class TileSet(py4godot_resource.Resource):
  r'''
		A TileSet is a library of tiles for a `TileMapLayer`. A TileSet handles a list of `TileSetSource`, each of them storing a set of tiles.
		Tiles can either be from a `TileSetAtlasSource`, which renders tiles out of a texture with support for physics, navigation, etc., or from a `TileSetScenesCollectionSource`, which exposes scene-based tiles.
		Tiles are referenced by using three IDs: their source ID, their atlas coordinates ID, and their alternative tile ID.
		A TileSet can be configured so that its tiles expose more or fewer properties. To do so, the TileSet resources use property layers, which you can add or remove depending on your needs.
		For example, adding a physics layer allows giving collision shapes to your tiles. Each layer has dedicated properties (physics layer and mask), so you may add several TileSet physics layers for each type of collision you need.
		See the functions to add new layers for more information.
	'''

  @staticmethod
  def constructor():
    class_ = TileSet.construct_without_init()
    class_._ptr = constructor(838,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TileSet.construct_without_init()
    class_._ptr = constructor(838,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTileSetWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(838,0, ())


  def generate_wrapper(self):
    return CPPTileSetWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TileSet.__new__(TileSet)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TileSet'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileSet.construct_without_init()
    cls._ptr = CPPTileSetWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileSet.construct_without_init()
    cls._ptr = CPPTileSetWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def tile_shape(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tile_shape()
    return _ret
  @tile_shape.setter
  def tile_shape(self,  value:'int'):
    self.set_tile_shape(value)
  @property
  def tile_layout(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tile_layout()
    return _ret
  @tile_layout.setter
  def tile_layout(self,  value:'int'):
    self.set_tile_layout(value)
  @property
  def tile_offset_axis(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tile_offset_axis()
    return _ret
  @tile_offset_axis.setter
  def tile_offset_axis(self,  value:'int'):
    self.set_tile_offset_axis(value)
  @property
  def tile_size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_tile_size()
    return _ret
  @tile_size.setter
  def tile_size(self,  value:'Vector2i'):
    self.set_tile_size(value)
  @property
  def uv_clipping(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_uv_clipping()
    return _ret
  @uv_clipping.setter
  def uv_clipping(self,  value:'bool'):
    self.set_uv_clipping(value)
  @functools.native_method
  def get_next_source_id(self) -> typing.Union[int]:
    r'''
				Returns a new unused source ID. This generated ID is the same that a call to `add_source` would return.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([]))
    return _ret


  @functools.native_method
  def add_source(self, source:'py4godot_tilesetsource.TileSetSource'   , atlas_source_id_override:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a `TileSetSource` to the TileSet. If `atlas_source_id_override` is not -1, also set its source ID. Otherwise, a unique identifier is automatically generated.
				The function returns the added source ID or -1 if the source could not be added.
				**Warning:** A source cannot belong to two TileSets at the same time. If the added source was attached to another `TileSet`, it will be removed from that one.
			'''

    assert(not source is None)
    assert isinstance(source, get_class('TileSetSource')), 'source must be TileSetSource'
    assert isinstance(atlas_source_id_override, (int, float)), 'atlas_source_id_override must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([source._ptr, atlas_source_id_override]))
    return _ret


  @functools.native_method
  def remove_source(self, source_id:'int'   ) -> None:
    r'''
				Removes the source with the given source ID.
			'''

    assert isinstance(source_id, (int, float)), 'source_id must be int or float'






    self._ptr.call_with_return(79,tuple([source_id]))

  @functools.native_method
  def set_source_id(self, source_id:'int'   , new_source_id:'int'   ) -> None:
    r'''
				Changes a source's ID.
			'''

    assert isinstance(source_id, (int, float)), 'source_id must be int or float'
    assert isinstance(new_source_id, (int, float)), 'new_source_id must be int or float'







    self._ptr.call_with_return(80,tuple([source_id, new_source_id]))

  @functools.native_method
  def get_source_count(self) -> typing.Union[int]:
    r'''
				Returns the number of `TileSetSource` in this TileSet.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def get_source_id(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the source ID for source with index `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([index]))
    return _ret


  @functools.native_method
  def has_source(self, source_id:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if this TileSet has a source for the given source ID.
			'''

    assert isinstance(source_id, (int, float)), 'source_id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([source_id]))
    return _ret


  @functools.native_method
  def get_source(self, source_id:'int'   ) -> typing.Union['py4godot_tilesetsource.TileSetSource','py4godot_tilesetscenescollectionsource.TileSetScenesCollectionSource','py4godot_tilesetatlassource.TileSetAtlasSource']:
    r'''
				Returns the `TileSetSource` with ID `source_id`.
			'''

    assert isinstance(source_id, (int, float)), 'source_id must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TileSetSource
    _ret._ptr = self._ptr.call_with_return(84,tuple([source_id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_tile_shape(self, shape:'int'  ) -> None:
    r''''''

    assert isinstance(shape, (int, float)), 'shape must be int or float'

    self.py__tile_shape = shape






    self._ptr.call_with_return(85,tuple([shape]))

  @functools.native_method
  def get_tile_shape(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(86,tuple([]))

    return _ret


  @functools.native_method
  def set_tile_layout(self, layout:'int'  ) -> None:
    r''''''

    assert isinstance(layout, (int, float)), 'layout must be int or float'

    self.py__tile_layout = layout






    self._ptr.call_with_return(87,tuple([layout]))

  @functools.native_method
  def get_tile_layout(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_tile_offset_axis(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'

    self.py__tile_offset_axis = alignment






    self._ptr.call_with_return(89,tuple([alignment]))

  @functools.native_method
  def get_tile_offset_axis(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_tile_size(self, size:'Vector2i'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'

    self.py__tile_size = size






    self._ptr.call_with_return(91,tuple([size._ptr]))

  @functools.native_method
  def get_tile_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_uv_clipping(self, uv_clipping:'bool'   ) -> None:
    r''''''

    assert isinstance(uv_clipping, bool), 'uv_clipping must be bool'

    self.py__uv_clipping = uv_clipping






    self._ptr.call_with_return(93,tuple([uv_clipping]))

  @functools.native_method
  def is_uv_clipping(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def get_occlusion_layers_count(self) -> typing.Union[int]:
    r'''
				Returns the occlusion layers count.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def add_occlusion_layer(self, to_position:'int' =-1  ) -> None:
    r'''
				Adds an occlusion layer to the TileSet at the given position `to_position` in the array. If `to_position` is -1, adds it at the end of the array.
				Occlusion layers allow assigning occlusion polygons to atlas tiles.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'






    self._ptr.call_with_return(96,tuple([to_position]))

  @functools.native_method
  def move_occlusion_layer(self, layer_index:'int'   , to_position:'int'   ) -> None:
    r'''
				Moves the occlusion layer at index `layer_index` to the given position `to_position` in the array. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(97,tuple([layer_index, to_position]))

  @functools.native_method
  def remove_occlusion_layer(self, layer_index:'int'   ) -> None:
    r'''
				Removes the occlusion layer at index `layer_index`. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    self._ptr.call_with_return(98,tuple([layer_index]))

  @functools.native_method
  def set_occlusion_layer_light_mask(self, layer_index:'int'   , light_mask:'int'   ) -> None:
    r'''
				Sets the occlusion layer (as in the rendering server) for occluders in the given TileSet occlusion layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(light_mask, (int, float)), 'light_mask must be int or float'







    self._ptr.call_with_return(99,tuple([layer_index, light_mask]))

  @functools.native_method
  def get_occlusion_layer_light_mask(self, layer_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the light mask of the occlusion layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([layer_index]))
    return _ret


  @functools.native_method
  def set_occlusion_layer_sdf_collision(self, layer_index:'int'   , sdf_collision:'bool'   ) -> None:
    r'''
				Enables or disables SDF collision for occluders in the given TileSet occlusion layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(sdf_collision, bool), 'sdf_collision must be bool'







    self._ptr.call_with_return(101,tuple([layer_index, sdf_collision]))

  @functools.native_method
  def get_occlusion_layer_sdf_collision(self, layer_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if the occluders from this layer use `sdf_collision`.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([layer_index]))
    return _ret


  @functools.native_method
  def get_physics_layers_count(self) -> typing.Union[int]:
    r'''
				Returns the physics layers count.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def add_physics_layer(self, to_position:'int' =-1  ) -> None:
    r'''
				Adds a physics layer to the TileSet at the given position `to_position` in the array. If `to_position` is -1, adds it at the end of the array.
				Physics layers allow assigning collision polygons to atlas tiles.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'






    self._ptr.call_with_return(104,tuple([to_position]))

  @functools.native_method
  def move_physics_layer(self, layer_index:'int'   , to_position:'int'   ) -> None:
    r'''
				Moves the physics layer at index `layer_index` to the given position `to_position` in the array. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(105,tuple([layer_index, to_position]))

  @functools.native_method
  def remove_physics_layer(self, layer_index:'int'   ) -> None:
    r'''
				Removes the physics layer at index `layer_index`. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    self._ptr.call_with_return(106,tuple([layer_index]))

  @functools.native_method
  def set_physics_layer_collision_layer(self, layer_index:'int'   , layer:'int'   ) -> None:
    r'''
				Sets the collision layer (as in the physics server) for bodies in the given TileSet physics layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(layer, (int, float)), 'layer must be int or float'







    self._ptr.call_with_return(107,tuple([layer_index, layer]))

  @functools.native_method
  def get_physics_layer_collision_layer(self, layer_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the collision layer (as in the physics server) bodies on the given TileSet's physics layer are in.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(108,tuple([layer_index]))
    return _ret


  @functools.native_method
  def set_physics_layer_collision_mask(self, layer_index:'int'   , mask:'int'   ) -> None:
    r'''
				Sets the collision mask for bodies in the given TileSet physics layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(109,tuple([layer_index, mask]))

  @functools.native_method
  def get_physics_layer_collision_mask(self, layer_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the collision mask of bodies on the given TileSet's physics layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([layer_index]))
    return _ret


  @functools.native_method
  def set_physics_layer_collision_priority(self, layer_index:'int'   , priority:'float'   ) -> None:
    r'''
				Sets the collision priority for bodies in the given TileSet physics layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(priority, (int, float)), 'priority must be int or float'







    self._ptr.call_with_return(111,tuple([layer_index, priority]))

  @functools.native_method
  def get_physics_layer_collision_priority(self, layer_index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the collision priority of bodies on the given TileSet's physics layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([layer_index]))
    return _ret


  @functools.native_method
  def set_physics_layer_physics_material(self, layer_index:'int'   , physics_material:'py4godot_physicsmaterial.PhysicsMaterial'   ) -> None:
    r'''
				Sets the physics material for bodies in the given TileSet physics layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert(not physics_material is None)
    assert isinstance(physics_material, get_class('PhysicsMaterial')), 'physics_material must be PhysicsMaterial'







    self._ptr.call_with_return(113,tuple([layer_index, physics_material._ptr]))

  @functools.native_method
  def get_physics_layer_physics_material(self, layer_index:'int'   ) -> typing.Union['py4godot_physicsmaterial.PhysicsMaterial']:
    r'''
				Returns the physics material of bodies on the given TileSet's physics layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PhysicsMaterial
    _ret._ptr = self._ptr.call_with_return(114,tuple([layer_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_terrain_sets_count(self) -> typing.Union[int]:
    r'''
				Returns the terrain sets count.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(115,tuple([]))
    return _ret


  @functools.native_method
  def add_terrain_set(self, to_position:'int' =-1  ) -> None:
    r'''
				Adds a new terrain set at the given position `to_position` in the array. If `to_position` is -1, adds it at the end of the array.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'






    self._ptr.call_with_return(116,tuple([to_position]))

  @functools.native_method
  def move_terrain_set(self, terrain_set:'int'   , to_position:'int'   ) -> None:
    r'''
				Moves the terrain set at index `terrain_set` to the given position `to_position` in the array. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(117,tuple([terrain_set, to_position]))

  @functools.native_method
  def remove_terrain_set(self, terrain_set:'int'   ) -> None:
    r'''
				Removes the terrain set at index `terrain_set`. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'






    self._ptr.call_with_return(118,tuple([terrain_set]))

  @functools.native_method
  def set_terrain_set_mode(self, terrain_set:'int'   , mode:'int'  ) -> None:
    r'''
				Sets a terrain mode. Each mode determines which bits of a tile shape is used to match the neighboring tiles' terrains.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(119,tuple([terrain_set, mode]))

  @functools.native_method
  def get_terrain_set_mode(self, terrain_set:'int'   ) -> typing.Union[int]:
    r'''
				Returns a terrain set mode.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(120,tuple([terrain_set]))
    return _ret


  @functools.native_method
  def get_terrains_count(self, terrain_set:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of terrains in the given terrain set.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([terrain_set]))
    return _ret


  @functools.native_method
  def add_terrain(self, terrain_set:'int'   , to_position:'int' =-1  ) -> None:
    r'''
				Adds a new terrain to the given terrain set `terrain_set` at the given position `to_position` in the array. If `to_position` is -1, adds it at the end of the array.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(122,tuple([terrain_set, to_position]))

  @functools.native_method
  def move_terrain(self, terrain_set:'int'   , terrain_index:'int'   , to_position:'int'   ) -> None:
    r'''
				Moves the terrain at index `terrain_index` for terrain set `terrain_set` to the given position `to_position` in the array. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain_index, (int, float)), 'terrain_index must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'








    self._ptr.call_with_return(123,tuple([terrain_set, terrain_index, to_position]))

  @functools.native_method
  def remove_terrain(self, terrain_set:'int'   , terrain_index:'int'   ) -> None:
    r'''
				Removes the terrain at index `terrain_index` in the given terrain set `terrain_set`. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain_index, (int, float)), 'terrain_index must be int or float'







    self._ptr.call_with_return(124,tuple([terrain_set, terrain_index]))

  @functools.native_method
  def set_terrain_name(self, terrain_set:'int'   , terrain_index:'int'   , name:'str'   ) -> None:
    r'''
				Sets a terrain's name.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain_index, (int, float)), 'terrain_index must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(125,tuple([terrain_set, terrain_index, py_string_name._ptr]))

  @functools.native_method
  def get_terrain_name(self, terrain_set:'int'   , terrain_index:'int'   ) -> typing.Union[str]:
    r'''
				Returns a terrain's name.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain_index, (int, float)), 'terrain_index must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(126,tuple([terrain_set, terrain_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_terrain_color(self, terrain_set:'int'   , terrain_index:'int'   , color:'Color'   ) -> None:
    r'''
				Sets a terrain's color. This color is used for identifying the different terrains in the TileSet editor.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain_index, (int, float)), 'terrain_index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(127,tuple([terrain_set, terrain_index, color._ptr]))

  @functools.native_method
  def get_terrain_color(self, terrain_set:'int'   , terrain_index:'int'   ) -> typing.Union['Color']:
    r'''
				Returns a terrain's color.
			'''

    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain_index, (int, float)), 'terrain_index must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(128,tuple([terrain_set, terrain_index]))
    return _ret


  @functools.native_method
  def get_navigation_layers_count(self) -> typing.Union[int]:
    r'''
				Returns the navigation layers count.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(129,tuple([]))
    return _ret


  @functools.native_method
  def add_navigation_layer(self, to_position:'int' =-1  ) -> None:
    r'''
				Adds a navigation layer to the TileSet at the given position `to_position` in the array. If `to_position` is -1, adds it at the end of the array.
				Navigation layers allow assigning a navigable area to atlas tiles.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'






    self._ptr.call_with_return(130,tuple([to_position]))

  @functools.native_method
  def move_navigation_layer(self, layer_index:'int'   , to_position:'int'   ) -> None:
    r'''
				Moves the navigation layer at index `layer_index` to the given position `to_position` in the array. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(131,tuple([layer_index, to_position]))

  @functools.native_method
  def remove_navigation_layer(self, layer_index:'int'   ) -> None:
    r'''
				Removes the navigation layer at index `layer_index`. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    self._ptr.call_with_return(132,tuple([layer_index]))

  @functools.native_method
  def set_navigation_layer_layers(self, layer_index:'int'   , layers:'int'   ) -> None:
    r'''
				Sets the navigation layers (as in the navigation server) for navigation regions in the given TileSet navigation layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(layers, (int, float)), 'layers must be int or float'







    self._ptr.call_with_return(133,tuple([layer_index, layers]))

  @functools.native_method
  def get_navigation_layer_layers(self, layer_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the navigation layers (as in the Navigation server) of the given TileSet navigation layer.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(134,tuple([layer_index]))
    return _ret


  @functools.native_method
  def set_navigation_layer_layer_value(self, layer_index:'int'   , layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified navigation layer of the TileSet navigation data layer identified by the given `layer_index`, given a navigation_layers `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(135,tuple([layer_index, layer_number, value]))

  @functools.native_method
  def get_navigation_layer_layer_value(self, layer_index:'int'   , layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified navigation layer of the TileSet navigation data layer identified by the given `layer_index` is enabled, given a navigation_layers `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(136,tuple([layer_index, layer_number]))
    return _ret


  @functools.native_method
  def get_custom_data_layers_count(self) -> typing.Union[int]:
    r'''
				Returns the custom data layers count.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(137,tuple([]))
    return _ret


  @functools.native_method
  def add_custom_data_layer(self, to_position:'int' =-1  ) -> None:
    r'''
				Adds a custom data layer to the TileSet at the given position `to_position` in the array. If `to_position` is -1, adds it at the end of the array.
				Custom data layers allow assigning custom properties to atlas tiles.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'






    self._ptr.call_with_return(138,tuple([to_position]))

  @functools.native_method
  def move_custom_data_layer(self, layer_index:'int'   , to_position:'int'   ) -> None:
    r'''
				Moves the custom data layer at index `layer_index` to the given position `to_position` in the array. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(139,tuple([layer_index, to_position]))

  @functools.native_method
  def remove_custom_data_layer(self, layer_index:'int'   ) -> None:
    r'''
				Removes the custom data layer at index `layer_index`. Also updates the atlas tiles accordingly.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    self._ptr.call_with_return(140,tuple([layer_index]))

  @functools.native_method
  def get_custom_data_layer_by_name(self, layer_name:'str'   ) -> typing.Union[int]:
    r'''
				Returns the index of the custom data layer identified by the given name.
			'''

    assert(not layer_name is None)
    assert isinstance(layer_name, (str, String)), 'layer_name must be str or String'




    assert(isinstance(layer_name, (str, String)))
    py_string_layer_name = layer_name if isinstance(layer_name, StringName) else c_utils.py_string_to_string(layer_name)

    _ret = 0
    _ret = self._ptr.call_with_return(141,tuple([py_string_layer_name._ptr]))
    return _ret


  @functools.native_method
  def set_custom_data_layer_name(self, layer_index:'int'   , layer_name:'str'   ) -> None:
    r'''
				Sets the name of the custom data layer identified by the given index. Names are identifiers of the layer therefore if the name is already taken it will fail and raise an error.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert(not layer_name is None)
    assert isinstance(layer_name, (str, String)), 'layer_name must be str or String'





    assert(isinstance(layer_name, (str, String)))
    py_string_layer_name = layer_name if isinstance(layer_name, StringName) else c_utils.py_string_to_string(layer_name)

    self._ptr.call_with_return(142,tuple([layer_index, py_string_layer_name._ptr]))

  @functools.native_method
  def has_custom_data_layer_by_name(self, layer_name:'str'   ) -> typing.Union[bool]:
    r'''
				Returns if there is a custom data layer named `layer_name`.
			'''

    assert(not layer_name is None)
    assert isinstance(layer_name, (str, String)), 'layer_name must be str or String'




    assert(isinstance(layer_name, (str, String)))
    py_string_layer_name = layer_name if isinstance(layer_name, StringName) else c_utils.py_string_to_string(layer_name)

    _ret = 0
    _ret = self._ptr.call_with_return(143,tuple([py_string_layer_name._ptr]))
    return _ret


  @functools.native_method
  def get_custom_data_layer_name(self, layer_index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the custom data layer identified by the given index.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(144,tuple([layer_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_custom_data_layer_type(self, layer_index:'int'   , layer_type:'int'  ) -> None:
    r'''
				Sets the type of the custom data layer identified by the given index.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'
    assert isinstance(layer_type, (int, float)), 'layer_type must be int or float'







    self._ptr.call_with_return(145,tuple([layer_index, layer_type]))

  @functools.native_method
  def get_custom_data_layer_type(self, layer_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the type of the custom data layer identified by the given index.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'






    _ret:int
    _ret = self._ptr.call_with_return(146,tuple([layer_index]))
    return _ret


  @functools.native_method
  def set_source_level_tile_proxy(self, source_from:'int'   , source_to:'int'   ) -> None:
    r'''
				Creates a source-level proxy for the given source ID. A proxy will map set of tile identifiers to another set of identifiers. Both the atlas coordinates ID and the alternative tile ID are kept the same when using source-level proxies.
				Proxied tiles can be automatically replaced in TileMapLayer nodes using the editor.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert isinstance(source_to, (int, float)), 'source_to must be int or float'







    self._ptr.call_with_return(147,tuple([source_from, source_to]))

  @functools.native_method
  def get_source_level_tile_proxy(self, source_from:'int'   ) -> typing.Union[int]:
    r'''
				Returns the source-level proxy for the given source identifier.
				If the TileSet has no proxy for the given identifier, returns -1.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(148,tuple([source_from]))
    return _ret


  @functools.native_method
  def has_source_level_tile_proxy(self, source_from:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if there is a source-level proxy for the given source ID.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(149,tuple([source_from]))
    return _ret


  @functools.native_method
  def remove_source_level_tile_proxy(self, source_from:'int'   ) -> None:
    r'''
				Removes a source-level tile proxy.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'






    self._ptr.call_with_return(150,tuple([source_from]))

  @functools.native_method
  def set_coords_level_tile_proxy(self, p_source_from:'int'   , coords_from:'Vector2i'   , source_to:'int'   , coords_to:'Vector2i'   ) -> None:
    r'''
				Creates a coordinates-level proxy for the given identifiers. A proxy will map set of tile identifiers to another set of identifiers. The alternative tile ID is kept the same when using coordinates-level proxies.
				Proxied tiles can be automatically replaced in TileMapLayer nodes using the editor.
			'''

    assert isinstance(p_source_from, (int, float)), 'p_source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'
    assert isinstance(source_to, (int, float)), 'source_to must be int or float'
    assert(not coords_to is None)
    assert isinstance(coords_to, Vector2i), 'coords_to must be Vector2i'









    self._ptr.call_with_return(151,tuple([p_source_from, coords_from._ptr, source_to, coords_to._ptr]))

  @functools.native_method
  def get_coords_level_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   ) -> typing.Union['Array']:
    r'''
				Returns the coordinate-level proxy for the given identifiers. The returned array contains the two target identifiers of the proxy (source ID and atlas coordinates ID).
				If the TileSet has no proxy for the given identifiers, returns an empty Array.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(152,tuple([source_from, coords_from._ptr]))
    return _ret


  @functools.native_method
  def has_coords_level_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   ) -> typing.Union[bool]:
    r'''
				Returns if there is a coodinates-level proxy for the given identifiers.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(153,tuple([source_from, coords_from._ptr]))
    return _ret


  @functools.native_method
  def remove_coords_level_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   ) -> None:
    r'''
				Removes a coordinates-level proxy for the given identifiers.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'







    self._ptr.call_with_return(154,tuple([source_from, coords_from._ptr]))

  @functools.native_method
  def set_alternative_level_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   , alternative_from:'int'   , source_to:'int'   , coords_to:'Vector2i'   , alternative_to:'int'   ) -> None:
    r'''
				Create an alternative-level proxy for the given identifiers. A proxy will map set of tile identifiers to another set of identifiers.
				Proxied tiles can be automatically replaced in TileMapLayer nodes using the editor.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'
    assert isinstance(alternative_from, (int, float)), 'alternative_from must be int or float'
    assert isinstance(source_to, (int, float)), 'source_to must be int or float'
    assert(not coords_to is None)
    assert isinstance(coords_to, Vector2i), 'coords_to must be Vector2i'
    assert isinstance(alternative_to, (int, float)), 'alternative_to must be int or float'











    self._ptr.call_with_return(155,tuple([source_from, coords_from._ptr, alternative_from, source_to, coords_to._ptr, alternative_to]))

  @functools.native_method
  def get_alternative_level_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   , alternative_from:'int'   ) -> typing.Union['Array']:
    r'''
				Returns the alternative-level proxy for the given identifiers. The returned array contains the three proxie's target identifiers (source ID, atlas coords ID and alternative tile ID).
				If the TileSet has no proxy for the given identifiers, returns an empty Array.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'
    assert isinstance(alternative_from, (int, float)), 'alternative_from must be int or float'








    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(156,tuple([source_from, coords_from._ptr, alternative_from]))
    return _ret


  @functools.native_method
  def has_alternative_level_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   , alternative_from:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if there is an alternative-level proxy for the given identifiers.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'
    assert isinstance(alternative_from, (int, float)), 'alternative_from must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(157,tuple([source_from, coords_from._ptr, alternative_from]))
    return _ret


  @functools.native_method
  def remove_alternative_level_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   , alternative_from:'int'   ) -> None:
    r'''
				Removes an alternative-level proxy for the given identifiers.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'
    assert isinstance(alternative_from, (int, float)), 'alternative_from must be int or float'








    self._ptr.call_with_return(158,tuple([source_from, coords_from._ptr, alternative_from]))

  @functools.native_method
  def map_tile_proxy(self, source_from:'int'   , coords_from:'Vector2i'   , alternative_from:'int'   ) -> typing.Union['Array']:
    r'''
				According to the configured proxies, maps the provided identifiers to a new set of identifiers. The source ID, atlas coordinates ID and alternative tile ID are returned as a 3 elements Array.
				This function first look for matching alternative-level proxies, then coordinates-level proxies, then source-level proxies.
				If no proxy corresponding to provided identifiers are found, returns the same values the ones used as arguments.
			'''

    assert isinstance(source_from, (int, float)), 'source_from must be int or float'
    assert(not coords_from is None)
    assert isinstance(coords_from, Vector2i), 'coords_from must be Vector2i'
    assert isinstance(alternative_from, (int, float)), 'alternative_from must be int or float'








    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(159,tuple([source_from, coords_from._ptr, alternative_from]))
    return _ret


  @functools.native_method
  def cleanup_invalid_tile_proxies(self) -> None:
    r'''
				Clears tile proxies pointing to invalid tiles.
			'''




    self._ptr.call_with_return(160,tuple([]))

  @functools.native_method
  def clear_tile_proxies(self) -> None:
    r'''
				Clears all tile proxies.
			'''




    self._ptr.call_with_return(161,tuple([]))

  @functools.native_method
  def add_pattern(self, pattern:'py4godot_tilemappattern.TileMapPattern'   , index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a `TileMapPattern` to be stored in the TileSet resource. If provided, insert it at the given `index`.
			'''

    assert(not pattern is None)
    assert isinstance(pattern, get_class('TileMapPattern')), 'pattern must be TileMapPattern'
    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(162,tuple([pattern._ptr, index]))
    return _ret


  @functools.native_method
  def get_pattern(self, index:'int' =-1  ) -> typing.Union['py4godot_tilemappattern.TileMapPattern']:
    r'''
				Returns the `TileMapPattern` at the given `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TileMapPattern
    _ret._ptr = self._ptr.call_with_return(163,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def remove_pattern(self, index:'int'   ) -> None:
    r'''
				Remove the `TileMapPattern` at the given index.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(164,tuple([index]))

  @functools.native_method
  def get_patterns_count(self) -> typing.Union[int]:
    r'''
				Returns the number of `TileMapPattern` this tile set handles.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(165,tuple([]))
    return _ret



register_cast_function('TileSet', TileSet.cast)
register_class('TileSet', TileSet)
