# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PacketPeerDTLS as py4godot_packetpeerdtls 
  import py4godot.classes.PacketPeerUDP as py4godot_packetpeerudp 
  import py4godot.classes.TLSOptions as py4godot_tlsoptions 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPDTLSServerWrapper


class DTLSServer(py4godot_refcounted.RefCounted):
  r'''
		This class is used to store the state of a DTLS server. Upon `setup` it converts connected `PacketPeerUDP` to `PacketPeerDTLS` accepting them via `take_connection` as DTLS clients. Under the hood, this class is used to store the DTLS state and cookies of the server. The reason of why the state and cookies are needed is outside of the scope of this documentation.
		Below a small example of how to use it:
		
		```gdscript
		# server_node.gd
		extends Node

		var dtls = DTLSServer.new()
		var server = UDPServer.new()
		var peers = ``

		func _ready():
			server.listen(4242)
			var key = load("key.key") # Your private key.
			var cert = load("cert.crt") # Your X509 certificate.
			dtls.setup(TlsOptions.server(key, cert))

		func _process(delta):
			while server.is_connection_available():
				var peer = server.take_connection()
				var dtls_peer = dtls.take_connection(peer)
				if dtls_peer.get_status() != PacketPeerDTLS.STATUS_HANDSHAKING:
					continue # It is normal that 50% of the connections fails due to cookie exchange.
				print("Peer connected!")
				peers.append(dtls_peer)

			for p in peers:
				p.poll() # Must poll to update the state.
				if p.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
					while p.get_available_packet_count() > 0:
						print("Received message from client: %s" % p.get_packet().get_string_from_utf8())
						p.put_packet("Hello DTLS client".to_utf8_buffer())
		```
		
		
		
		```gdscript
		# client_node.gd
		extends Node

		var dtls = PacketPeerDTLS.new()
		var udp = PacketPeerUDP.new()
		var connected = false

		func _ready():
			udp.connect_to_host("127.0.0.1", 4242)
			dtls.connect_to_peer(udp, false) # Use true in production for certificate validation!

		func _process(delta):
			dtls.poll()
			if dtls.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
				if !connected:
					# Try to contact server
					dtls.put_packet("The answer is... 42!".to_utf8_buffer())
				while dtls.get_available_packet_count() > 0:
					print("Connected: %s" % dtls.get_packet().get_string_from_utf8())
					connected = true
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = DTLSServer.construct_without_init()
    class_._ptr = constructor(256,0, ())
    return class_
  @staticmethod
  def new():
    class_ = DTLSServer.construct_without_init()
    class_._ptr = constructor(256,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPDTLSServerWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(256,0, ())


  def generate_wrapper(self):
    return CPPDTLSServerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = DTLSServer.__new__(DTLSServer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'DTLSServer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = DTLSServer.construct_without_init()
    cls._ptr = CPPDTLSServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = DTLSServer.construct_without_init()
    cls._ptr = CPPDTLSServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def setup(self, server_options:'py4godot_tlsoptions.TLSOptions'   ) -> typing.Union[int]:
    r'''
				Setup the DTLS server to use the given `server_options`. See `TLSOptions.server`.
			'''

    assert(not server_options is None)
    assert isinstance(server_options, get_class('TLSOptions')), 'server_options must be TLSOptions'






    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([server_options._ptr]))
    return _ret


  @functools.native_method
  def take_connection(self, udp_peer:'py4godot_packetpeerudp.PacketPeerUDP'   ) -> typing.Union['py4godot_packetpeerdtls.PacketPeerDTLS']:
    r'''
				Try to initiate the DTLS handshake with the given `udp_peer` which must be already connected (see `PacketPeerUDP.connect_to_host`).
				**Note:** You must check that the state of the return PacketPeerUDP is `constant PacketPeerDTLS.STATUS_HANDSHAKING`, as it is normal that 50% of the new connections will be invalid due to cookie exchange.
			'''

    assert(not udp_peer is None)
    assert isinstance(udp_peer, get_class('PacketPeerUDP')), 'udp_peer must be PacketPeerUDP'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PacketPeerDTLS
    _ret._ptr = self._ptr.call_with_return(54,tuple([udp_peer._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('DTLSServer', DTLSServer.cast)
register_class('DTLSServer', DTLSServer)
