# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.Control as py4godot_control 
import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
from py4godot.wrappers.wrappers import CPPEditorFileDialogWrapper

class FileMode:
  FILE_MODE_OPEN_FILE = 0
  FILE_MODE_OPEN_FILES = 1
  FILE_MODE_OPEN_DIR = 2
  FILE_MODE_OPEN_ANY = 3
  FILE_MODE_SAVE_FILE = 4
class Access:
  ACCESS_RESOURCES = 0
  ACCESS_USERDATA = 1
  ACCESS_FILESYSTEM = 2
class DisplayMode:
  DISPLAY_THUMBNAILS = 0
  DISPLAY_LIST = 1


class EditorFileDialog(py4godot_confirmationdialog.ConfirmationDialog):
  r'''
		`EditorFileDialog` is an enhanced version of `FileDialog` available only to editor plugins. Additional features include list of favorited/recent files and the ability to see files as thumbnails grid instead of list.
		Unlike `FileDialog`, `EditorFileDialog` does not have a property for using native dialogs. Instead, native dialogs can be enabled globally via the `EditorSettings.interface/editor/use_native_file_dialogs` editor setting. They are also enabled automatically when running in sandbox (e.g. on macOS).
	'''

  @staticmethod
  def constructor():
    class_ = EditorFileDialog.construct_without_init()
    class_._ptr = constructor(284,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorFileDialog.construct_without_init()
    class_._ptr = constructor(284,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorFileDialogWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(284,0, ())


  def generate_wrapper(self):
    return CPPEditorFileDialogWrapper()
  def init_signals(self):
    super().init_signals()
    file_selected_name = utils.py_string_to_string_name("file_selected")
    self.file_selected = signals.BuiltinSignal(self, file_selected_name)
    files_selected_name = utils.py_string_to_string_name("files_selected")
    self.files_selected = signals.BuiltinSignal(self, files_selected_name)
    dir_selected_name = utils.py_string_to_string_name("dir_selected")
    self.dir_selected = signals.BuiltinSignal(self, dir_selected_name)
    filename_filter_changed_name = utils.py_string_to_string_name("filename_filter_changed")
    self.filename_filter_changed = signals.BuiltinSignal(self, filename_filter_changed_name)

  @staticmethod
  def construct_without_init():
    cls = EditorFileDialog.__new__(EditorFileDialog)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorFileDialog'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorFileDialog.construct_without_init()
    cls._ptr = CPPEditorFileDialogWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorFileDialog.construct_without_init()
    cls._ptr = CPPEditorFileDialogWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def access(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_access()
    return _ret
  @access.setter
  def access(self,  value:'int'):
    self.set_access(value)
  @property
  def display_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_display_mode()
    return _ret
  @display_mode.setter
  def display_mode(self,  value:'int'):
    self.set_display_mode(value)
  @property
  def file_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_file_mode()
    return _ret
  @file_mode.setter
  def file_mode(self,  value:'int'):
    self.set_file_mode(value)
  @property
  def current_dir(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_current_dir()
    return _ret
  @current_dir.setter
  def current_dir(self,  value:'str'):
    self.set_current_dir(value)
  @property
  def current_file(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_current_file()
    return _ret
  @current_file.setter
  def current_file(self,  value:'str'):
    self.set_current_file(value)
  @property
  def current_path(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_current_path()
    return _ret
  @current_path.setter
  def current_path(self,  value:'str'):
    self.set_current_path(value)
  @property
  def filters(self) -> typing.Union['PackedStringArray']:
    r''''''
    _ret = self. get_filters()
    return _ret
  @filters.setter
  def filters(self,  value:'PackedStringArray'):
    self.set_filters(value)
  @property
  def option_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_option_count()
    return _ret
  @option_count.setter
  def option_count(self,  value:'int'):
    self.set_option_count(value)
  @property
  def show_hidden_files(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_hidden_files()
    return _ret
  @show_hidden_files.setter
  def show_hidden_files(self,  value:'bool'):
    self.set_show_hidden_files(value)
  @property
  def disable_overwrite_warning(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_overwrite_warning_disabled()
    return _ret
  @disable_overwrite_warning.setter
  def disable_overwrite_warning(self,  value:'bool'):
    self.set_disable_overwrite_warning(value)
  @functools.native_method
  def clear_filters(self) -> None:
    r'''
				Removes all filters except for "All Files (*.*)".
			'''




    self._ptr.call_with_return(453,tuple([]))

  @functools.native_method
  def add_filter(self, filter:'str'   , description:'str' =""  ) -> None:
    r'''
				Adds a comma-separated file name `filter` option to the `EditorFileDialog` with an optional `description`, which restricts what files can be picked.
				A `filter` should be of the form `"filename.extension"`, where filename and extension can be `*` to match any string. Filters starting with `.` (i.e. empty filenames) are not allowed.
				For example, a `filter` of `"*.tscn, *.scn"` and a `description` of `"Scenes"` results in filter text "Scenes (*.tscn, *.scn)".
			'''
    if description is None:
      description = String.new0()
    if description is None:
      description = String.new0()

    assert(not filter is None)
    assert isinstance(filter, (str, String)), 'filter must be str or String'




    assert(isinstance(filter, (str, String)))
    py_string_filter = filter if isinstance(filter, StringName) else c_utils.py_string_to_string(filter)
    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(454,tuple([py_string_filter._ptr, py_string_description._ptr]))

  @functools.native_method
  def set_filters(self, filters:'PackedStringArray'   ) -> None:
    r''''''

    assert(not filters is None)
    assert isinstance(filters, PackedStringArray), 'filters must be PackedStringArray'

    self.py__filters = filters






    self._ptr.call_with_return(455,tuple([filters._ptr]))

  @functools.native_method
  def get_filters(self) -> typing.Union['PackedStringArray']:
    r''''''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(456,tuple([]))

    return _ret


  @functools.native_method
  def get_option_name(self, option:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(457,tuple([option]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_option_values(self, option:'int'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array of values of the `OptionButton` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'






    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(458,tuple([option]))
    return _ret


  @functools.native_method
  def get_option_default(self, option:'int'   ) -> typing.Union[int]:
    r'''
				Returns the default value index of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(459,tuple([option]))
    return _ret


  @functools.native_method
  def set_option_name(self, option:'int'   , name:'str'   ) -> None:
    r'''
				Sets the name of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(460,tuple([option, py_string_name._ptr]))

  @functools.native_method
  def set_option_values(self, option:'int'   , values:'PackedStringArray'   ) -> None:
    r'''
				Sets the option values of the `OptionButton` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'
    assert(not values is None)
    assert isinstance(values, PackedStringArray), 'values must be PackedStringArray'







    self._ptr.call_with_return(461,tuple([option, values._ptr]))

  @functools.native_method
  def set_option_default(self, option:'int'   , default_value_index:'int'   ) -> None:
    r'''
				Sets the default value index of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'
    assert isinstance(default_value_index, (int, float)), 'default_value_index must be int or float'







    self._ptr.call_with_return(462,tuple([option, default_value_index]))

  @functools.native_method
  def set_option_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'

    self.py__option_count = count






    self._ptr.call_with_return(463,tuple([count]))

  @functools.native_method
  def get_option_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(464,tuple([]))

    return _ret


  @functools.native_method
  def add_option(self, name:'str'   , values:'PackedStringArray'   , default_value_index:'int'   ) -> None:
    r'''
				Adds an additional `OptionButton` to the file dialog. If `values` is empty, a `CheckBox` is added instead.
				`default_value_index` should be an index of the value in the `values`. If `values` is empty it should be either `1` (checked), or `0` (unchecked).
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not values is None)
    assert isinstance(values, PackedStringArray), 'values must be PackedStringArray'
    assert isinstance(default_value_index, (int, float)), 'default_value_index must be int or float'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)



    self._ptr.call_with_return(465,tuple([py_string_name._ptr, values._ptr, default_value_index]))

  @functools.native_method
  def get_selected_options(self) -> typing.Union['Dictionary']:
    r'''
				Returns a `Dictionary` with the selected values of the additional `OptionButton`s and/or `CheckBox`es. `Dictionary` keys are names and values are selected value indices.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(466,tuple([]))
    return _ret


  @functools.native_method
  def clear_filename_filter(self) -> None:
    r'''
				Clear the filter for file names.
			'''




    self._ptr.call_with_return(467,tuple([]))

  @functools.native_method
  def set_filename_filter(self, filter:'str'   ) -> None:
    r'''
				Sets the value of the filter for file names.
			'''

    assert(not filter is None)
    assert isinstance(filter, (str, String)), 'filter must be str or String'




    assert(isinstance(filter, (str, String)))
    py_string_filter = filter if isinstance(filter, StringName) else c_utils.py_string_to_string(filter)

    self._ptr.call_with_return(468,tuple([py_string_filter._ptr]))

  @functools.native_method
  def get_filename_filter(self) -> typing.Union[str]:
    r'''
				Returns the value of the filter for file names.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(469,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_dir(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(470,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_file(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(471,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_path(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(472,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_current_dir(self, dir:'str'   ) -> None:
    r''''''

    assert(not dir is None)
    assert isinstance(dir, (str, String)), 'dir must be str or String'

    self.py__current_dir = dir



    assert(isinstance(dir, (str, String)))
    py_string_dir = dir if isinstance(dir, StringName) else c_utils.py_string_to_string(dir)

    py__string_dir = utils.py_string_to_string(dir)
    py__string_dir.shouldBeDeleted = False


    self._ptr.call_with_return(473,tuple([py__string_dir._ptr]))

  @functools.native_method
  def set_current_file(self, file:'str'   ) -> None:
    r''''''

    assert(not file is None)
    assert isinstance(file, (str, String)), 'file must be str or String'

    self.py__current_file = file



    assert(isinstance(file, (str, String)))
    py_string_file = file if isinstance(file, StringName) else c_utils.py_string_to_string(file)

    py__string_file = utils.py_string_to_string(file)
    py__string_file.shouldBeDeleted = False


    self._ptr.call_with_return(474,tuple([py__string_file._ptr]))

  @functools.native_method
  def set_current_path(self, path:'str'   ) -> None:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'

    self.py__current_path = path



    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    py__string_path = utils.py_string_to_string(path)
    py__string_path.shouldBeDeleted = False


    self._ptr.call_with_return(475,tuple([py__string_path._ptr]))

  @functools.native_method
  def set_file_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__file_mode = mode






    self._ptr.call_with_return(476,tuple([mode]))

  @functools.native_method
  def get_file_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(477,tuple([]))

    return _ret


  @functools.native_method
  def get_vbox(self) -> typing.Union['py4godot_filesystemdock.FileSystemDock','py4godot_vboxcontainer.VBoxContainer','py4godot_colorpicker.ColorPicker','py4godot_scripteditorbase.ScriptEditorBase']:
    r'''
				Returns the `VBoxContainer` used to display the file system.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VBoxContainer
    _ret._ptr = self._ptr.call_with_return(478,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_line_edit(self) -> typing.Union['py4godot_lineedit.LineEdit']:
    r'''
				Returns the LineEdit for the selected file.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: LineEdit
    _ret._ptr = self._ptr.call_with_return(479,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_access(self, access:'int'  ) -> None:
    r''''''

    assert isinstance(access, (int, float)), 'access must be int or float'

    self.py__access = access






    self._ptr.call_with_return(480,tuple([access]))

  @functools.native_method
  def get_access(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(481,tuple([]))

    return _ret


  @functools.native_method
  def set_show_hidden_files(self, show:'bool'   ) -> None:
    r''''''

    assert isinstance(show, bool), 'show must be bool'

    self.py__show_hidden_files = show






    self._ptr.call_with_return(482,tuple([show]))

  @functools.native_method
  def is_showing_hidden_files(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(483,tuple([]))

    return _ret


  @functools.native_method
  def set_display_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'

    self.py__display_mode = mode






    self._ptr.call_with_return(484,tuple([mode]))

  @functools.native_method
  def get_display_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(485,tuple([]))

    return _ret


  @functools.native_method
  def set_disable_overwrite_warning(self, disable:'bool'   ) -> None:
    r''''''

    assert isinstance(disable, bool), 'disable must be bool'

    self.py__disable_overwrite_warning = disable






    self._ptr.call_with_return(486,tuple([disable]))

  @functools.native_method
  def is_overwrite_warning_disabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(487,tuple([]))

    return _ret


  @functools.native_method
  def add_side_menu(self, menu:'py4godot_control.Control'   , title:'str' =""  ) -> None:
    r'''
				Adds the given `menu` to the side of the file dialog with the given `title` text on top. Only one side menu is allowed.
			'''
    if title is None:
      title = String.new0()
    if title is None:
      title = String.new0()

    assert(not menu is None)
    assert isinstance(menu, get_class('Control')), 'menu must be Control'





    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)

    self._ptr.call_with_return(488,tuple([menu._ptr, py_string_title._ptr]))

  @functools.native_method
  def popup_file_dialog(self) -> None:
    r'''
				Shows the `EditorFileDialog` at the default size and position for file dialogs in the editor, and selects the file name if there is a current file.
			'''




    self._ptr.call_with_return(489,tuple([]))

  @functools.native_method
  def invalidate(self) -> None:
    r'''
				Notify the `EditorFileDialog` that its view of the data is no longer accurate. Updates the view contents on next view update.
			'''




    self._ptr.call_with_return(490,tuple([]))


register_cast_function('EditorFileDialog', EditorFileDialog.cast)
register_class('EditorFileDialog', EditorFileDialog)
