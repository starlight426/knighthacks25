# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.Font as py4godot_font 
from py4godot.wrappers.wrappers import CPPFontFileWrapper


class FontFile(py4godot_font.Font):
  r'''
		`FontFile` contains a set of glyphs to represent Unicode characters imported from a font file, as well as a cache of rasterized glyphs, and a set of fallback `Font`s to use.
		Use `FontVariation` to access specific OpenType variation of the font, create simulated bold / slanted version, and draw lines of text.
		For more complex text processing, use `FontVariation` in conjunction with `TextLine` or `TextParagraph`.
		Supported font formats:
		- Dynamic font importer: TrueType (.ttf), TrueType collection (.ttc), OpenType (.otf), OpenType collection (.otc), WOFF (.woff), WOFF2 (.woff2), Type 1 (.pfb, .pfm).
		- Bitmap font importer: AngelCode BMFont (.fnt, .font), text and binary (version 3) format variants.
		- Monospace image font importer: All supported image formats.
		**Note:** A character is a symbol that represents an item (letter, digit etc.) in an abstract way.
		**Note:** A glyph is a bitmap or a shape used to draw one or more characters in a context-dependent manner. Glyph indices are bound to the specific font data source.
		**Note:** If none of the font data sources contain glyphs for a character used in a string, the character in question will be replaced with a box displaying its hexadecimal code.
		
		```gdscript
		var f = load("res://BarlowCondensed-Bold.ttf")
		$Label.add_theme_font_override("font", f)
		$Label.add_theme_font_size_override("font_size", 64)
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = FontFile.construct_without_init()
    class_._ptr = constructor(338,0, ())
    return class_
  @staticmethod
  def new():
    class_ = FontFile.construct_without_init()
    class_._ptr = constructor(338,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPFontFileWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(338,0, ())


  def generate_wrapper(self):
    return CPPFontFileWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = FontFile.__new__(FontFile)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'FontFile'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = FontFile.construct_without_init()
    cls._ptr = CPPFontFileWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = FontFile.construct_without_init()
    cls._ptr = CPPFontFileWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def data(self) -> typing.Union['PackedByteArray']:
    r''''''
    _ret = self. get_data()
    return _ret
  @data.setter
  def data(self,  value:'PackedByteArray'):
    self.set_data(value)
  @property
  def generate_mipmaps(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_generate_mipmaps()
    return _ret
  @generate_mipmaps.setter
  def generate_mipmaps(self,  value:'bool'):
    self.set_generate_mipmaps(value)
  @property
  def disable_embedded_bitmaps(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_disable_embedded_bitmaps()
    return _ret
  @disable_embedded_bitmaps.setter
  def disable_embedded_bitmaps(self,  value:'bool'):
    self.set_disable_embedded_bitmaps(value)
  @property
  def antialiasing(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_antialiasing()
    return _ret
  @antialiasing.setter
  def antialiasing(self,  value:'int'):
    self.set_antialiasing(value)
  @property
  def font_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_font_name()
    return _ret
  @font_name.setter
  def font_name(self,  value:'str'):
    self.set_font_name(value)
  @property
  def style_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_font_style_name()
    return _ret
  @style_name.setter
  def style_name(self,  value:'str'):
    self.set_font_style_name(value)
  @property
  def font_style(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_font_style()
    return _ret
  @font_style.setter
  def font_style(self,  value:'int'):
    self.set_font_style(value)
  @property
  def font_weight(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_font_weight()
    return _ret
  @font_weight.setter
  def font_weight(self,  value:'int'):
    self.set_font_weight(value)
  @property
  def font_stretch(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_font_stretch()
    return _ret
  @font_stretch.setter
  def font_stretch(self,  value:'int'):
    self.set_font_stretch(value)
  @property
  def subpixel_positioning(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_subpixel_positioning()
    return _ret
  @subpixel_positioning.setter
  def subpixel_positioning(self,  value:'int'):
    self.set_subpixel_positioning(value)
  @property
  def keep_rounding_remainders(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_keep_rounding_remainders()
    return _ret
  @keep_rounding_remainders.setter
  def keep_rounding_remainders(self,  value:'bool'):
    self.set_keep_rounding_remainders(value)
  @property
  def multichannel_signed_distance_field(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_multichannel_signed_distance_field()
    return _ret
  @multichannel_signed_distance_field.setter
  def multichannel_signed_distance_field(self,  value:'bool'):
    self.set_multichannel_signed_distance_field(value)
  @property
  def msdf_pixel_range(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_msdf_pixel_range()
    return _ret
  @msdf_pixel_range.setter
  def msdf_pixel_range(self,  value:'int'):
    self.set_msdf_pixel_range(value)
  @property
  def msdf_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_msdf_size()
    return _ret
  @msdf_size.setter
  def msdf_size(self,  value:'int'):
    self.set_msdf_size(value)
  @property
  def allow_system_fallback(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_allow_system_fallback()
    return _ret
  @allow_system_fallback.setter
  def allow_system_fallback(self,  value:'bool'):
    self.set_allow_system_fallback(value)
  @property
  def force_autohinter(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_force_autohinter()
    return _ret
  @force_autohinter.setter
  def force_autohinter(self,  value:'bool'):
    self.set_force_autohinter(value)
  @property
  def modulate_color_glyphs(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_modulate_color_glyphs()
    return _ret
  @modulate_color_glyphs.setter
  def modulate_color_glyphs(self,  value:'bool'):
    self.set_modulate_color_glyphs(value)
  @property
  def hinting(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_hinting()
    return _ret
  @hinting.setter
  def hinting(self,  value:'int'):
    self.set_hinting(value)
  @property
  def fixed_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_fixed_size()
    return _ret
  @fixed_size.setter
  def fixed_size(self,  value:'int'):
    self.set_fixed_size(value)
  @property
  def fixed_size_scale_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_fixed_size_scale_mode()
    return _ret
  @fixed_size_scale_mode.setter
  def fixed_size_scale_mode(self,  value:'int'):
    self.set_fixed_size_scale_mode(value)
  @property
  def opentype_feature_overrides(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_opentype_feature_overrides()
    return _ret
  @opentype_feature_overrides.setter
  def opentype_feature_overrides(self,  value:'Dictionary'):
    self.set_opentype_feature_overrides(value)
  @property
  def oversampling(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_oversampling()
    return _ret
  @oversampling.setter
  def oversampling(self,  value:'float'):
    self.set_oversampling(value)
  @functools.native_method
  def load_bitmap_font(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Loads an AngelCode BMFont (.fnt, .font) bitmap font from file `path`.
				**Warning:** This method should only be used in the editor or in cases when you need to load external fonts at run-time, such as fonts located at the `user://` directory.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(111,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def load_dynamic_font(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Loads a TrueType (.ttf), OpenType (.otf), WOFF (.woff), WOFF2 (.woff2) or Type 1 (.pfb, .pfm) dynamic font from file `path`.
				**Warning:** This method should only be used in the editor or in cases when you need to load external fonts at run-time, such as fonts located at the `user://` directory.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(112,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def set_data(self, data:'PackedByteArray'   ) -> None:
    r''''''

    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'

    self.py__data = data






    self._ptr.call_with_return(113,tuple([data._ptr]))

  @functools.native_method
  def get_data(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(114,tuple([]))

    return _ret


  @functools.native_method
  def set_font_name(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'

    self.py__font_name = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(115,tuple([py__string_name._ptr]))

  @functools.native_method
  def set_font_style_name(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'

    self.py__style_name = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(116,tuple([py__string_name._ptr]))

  @functools.native_method
  def set_font_style(self, style:'int'   ) -> None:
    r''''''

    assert isinstance(style, (int, float)), 'style must be int or float'

    self.py__font_style = style






    self._ptr.call_with_return(117,tuple([style]))

  @functools.native_method
  def set_font_weight(self, weight:'int'   ) -> None:
    r''''''

    assert isinstance(weight, (int, float)), 'weight must be int or float'

    self.py__font_weight = weight






    self._ptr.call_with_return(118,tuple([weight]))

  @functools.native_method
  def set_font_stretch(self, stretch:'int'   ) -> None:
    r''''''

    assert isinstance(stretch, (int, float)), 'stretch must be int or float'

    self.py__font_stretch = stretch






    self._ptr.call_with_return(119,tuple([stretch]))

  @functools.native_method
  def set_antialiasing(self, antialiasing:'int'  ) -> None:
    r''''''

    assert isinstance(antialiasing, (int, float)), 'antialiasing must be int or float'

    self.py__antialiasing = antialiasing






    self._ptr.call_with_return(120,tuple([antialiasing]))

  @functools.native_method
  def get_antialiasing(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(121,tuple([]))

    return _ret


  @functools.native_method
  def set_disable_embedded_bitmaps(self, disable_embedded_bitmaps:'bool'   ) -> None:
    r''''''

    assert isinstance(disable_embedded_bitmaps, bool), 'disable_embedded_bitmaps must be bool'

    self.py__disable_embedded_bitmaps = disable_embedded_bitmaps






    self._ptr.call_with_return(122,tuple([disable_embedded_bitmaps]))

  @functools.native_method
  def get_disable_embedded_bitmaps(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(123,tuple([]))

    return _ret


  @functools.native_method
  def set_generate_mipmaps(self, generate_mipmaps:'bool'   ) -> None:
    r''''''

    assert isinstance(generate_mipmaps, bool), 'generate_mipmaps must be bool'

    self.py__generate_mipmaps = generate_mipmaps






    self._ptr.call_with_return(124,tuple([generate_mipmaps]))

  @functools.native_method
  def get_generate_mipmaps(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(125,tuple([]))

    return _ret


  @functools.native_method
  def set_multichannel_signed_distance_field(self, msdf:'bool'   ) -> None:
    r''''''

    assert isinstance(msdf, bool), 'msdf must be bool'

    self.py__multichannel_signed_distance_field = msdf






    self._ptr.call_with_return(126,tuple([msdf]))

  @functools.native_method
  def is_multichannel_signed_distance_field(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(127,tuple([]))

    return _ret


  @functools.native_method
  def set_msdf_pixel_range(self, msdf_pixel_range:'int'   ) -> None:
    r''''''

    assert isinstance(msdf_pixel_range, (int, float)), 'msdf_pixel_range must be int or float'

    self.py__msdf_pixel_range = msdf_pixel_range






    self._ptr.call_with_return(128,tuple([msdf_pixel_range]))

  @functools.native_method
  def get_msdf_pixel_range(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(129,tuple([]))

    return _ret


  @functools.native_method
  def set_msdf_size(self, msdf_size:'int'   ) -> None:
    r''''''

    assert isinstance(msdf_size, (int, float)), 'msdf_size must be int or float'

    self.py__msdf_size = msdf_size






    self._ptr.call_with_return(130,tuple([msdf_size]))

  @functools.native_method
  def get_msdf_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(131,tuple([]))

    return _ret


  @functools.native_method
  def set_fixed_size(self, fixed_size:'int'   ) -> None:
    r''''''

    assert isinstance(fixed_size, (int, float)), 'fixed_size must be int or float'

    self.py__fixed_size = fixed_size






    self._ptr.call_with_return(132,tuple([fixed_size]))

  @functools.native_method
  def get_fixed_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(133,tuple([]))

    return _ret


  @functools.native_method
  def set_fixed_size_scale_mode(self, fixed_size_scale_mode:'int'  ) -> None:
    r''''''

    assert isinstance(fixed_size_scale_mode, (int, float)), 'fixed_size_scale_mode must be int or float'

    self.py__fixed_size_scale_mode = fixed_size_scale_mode






    self._ptr.call_with_return(134,tuple([fixed_size_scale_mode]))

  @functools.native_method
  def get_fixed_size_scale_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(135,tuple([]))

    return _ret


  @functools.native_method
  def set_allow_system_fallback(self, allow_system_fallback:'bool'   ) -> None:
    r''''''

    assert isinstance(allow_system_fallback, bool), 'allow_system_fallback must be bool'

    self.py__allow_system_fallback = allow_system_fallback






    self._ptr.call_with_return(136,tuple([allow_system_fallback]))

  @functools.native_method
  def is_allow_system_fallback(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(137,tuple([]))

    return _ret


  @functools.native_method
  def set_force_autohinter(self, force_autohinter:'bool'   ) -> None:
    r''''''

    assert isinstance(force_autohinter, bool), 'force_autohinter must be bool'

    self.py__force_autohinter = force_autohinter






    self._ptr.call_with_return(138,tuple([force_autohinter]))

  @functools.native_method
  def is_force_autohinter(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(139,tuple([]))

    return _ret


  @functools.native_method
  def set_modulate_color_glyphs(self, modulate:'bool'   ) -> None:
    r''''''

    assert isinstance(modulate, bool), 'modulate must be bool'

    self.py__modulate_color_glyphs = modulate






    self._ptr.call_with_return(140,tuple([modulate]))

  @functools.native_method
  def is_modulate_color_glyphs(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(141,tuple([]))

    return _ret


  @functools.native_method
  def set_hinting(self, hinting:'int'  ) -> None:
    r''''''

    assert isinstance(hinting, (int, float)), 'hinting must be int or float'

    self.py__hinting = hinting






    self._ptr.call_with_return(142,tuple([hinting]))

  @functools.native_method
  def get_hinting(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(143,tuple([]))

    return _ret


  @functools.native_method
  def set_subpixel_positioning(self, subpixel_positioning:'int'  ) -> None:
    r''''''

    assert isinstance(subpixel_positioning, (int, float)), 'subpixel_positioning must be int or float'

    self.py__subpixel_positioning = subpixel_positioning






    self._ptr.call_with_return(144,tuple([subpixel_positioning]))

  @functools.native_method
  def get_subpixel_positioning(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(145,tuple([]))

    return _ret


  @functools.native_method
  def set_keep_rounding_remainders(self, keep_rounding_remainders:'bool'   ) -> None:
    r''''''

    assert isinstance(keep_rounding_remainders, bool), 'keep_rounding_remainders must be bool'

    self.py__keep_rounding_remainders = keep_rounding_remainders






    self._ptr.call_with_return(146,tuple([keep_rounding_remainders]))

  @functools.native_method
  def get_keep_rounding_remainders(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(147,tuple([]))

    return _ret


  @functools.native_method
  def set_oversampling(self, oversampling:'float'   ) -> None:
    r''''''

    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'

    self.py__oversampling = oversampling






    self._ptr.call_with_return(148,tuple([oversampling]))

  @functools.native_method
  def get_oversampling(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(149,tuple([]))

    return _ret


  @functools.native_method
  def get_cache_count(self) -> typing.Union[int]:
    r'''
				Returns number of the font cache entries.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(150,tuple([]))
    return _ret


  @functools.native_method
  def clear_cache(self) -> None:
    r'''
				Removes all font cache entries.
			'''




    self._ptr.call_with_return(151,tuple([]))

  @functools.native_method
  def remove_cache(self, cache_index:'int'   ) -> None:
    r'''
				Removes specified font cache entry.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    self._ptr.call_with_return(152,tuple([cache_index]))

  @functools.native_method
  def get_size_cache_list(self, cache_index:'int'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns list of the font sizes in the cache. Each size is `Vector2i` with font size and outline size.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(153,tuple([cache_index]))
    return _ret


  @functools.native_method
  def clear_size_cache(self, cache_index:'int'   ) -> None:
    r'''
				Removes all font sizes from the cache entry.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    self._ptr.call_with_return(154,tuple([cache_index]))

  @functools.native_method
  def remove_size_cache(self, cache_index:'int'   , size:'Vector2i'   ) -> None:
    r'''
				Removes specified font size from the cache entry.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'







    self._ptr.call_with_return(155,tuple([cache_index, size._ptr]))

  @functools.native_method
  def set_variation_coordinates(self, cache_index:'int'   , variation_coordinates:'Dictionary'   ) -> None:
    r'''
				Sets variation coordinates for the specified font cache entry. See `Font.get_supported_variation_list` for more info.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not variation_coordinates is None)
    assert isinstance(variation_coordinates, Dictionary), 'variation_coordinates must be Dictionary'







    self._ptr.call_with_return(156,tuple([cache_index, variation_coordinates._ptr]))

  @functools.native_method
  def get_variation_coordinates(self, cache_index:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Returns variation coordinates for the specified font cache entry. See `Font.get_supported_variation_list` for more info.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(157,tuple([cache_index]))
    return _ret


  @functools.native_method
  def set_embolden(self, cache_index:'int'   , strength:'float'   ) -> None:
    r'''
				Sets embolden strength, if is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(strength, (int, float)), 'strength must be int or float'







    self._ptr.call_with_return(158,tuple([cache_index, strength]))

  @functools.native_method
  def get_embolden(self, cache_index:'int'   ) -> typing.Union[float]:
    r'''
				Returns embolden strength, if is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(159,tuple([cache_index]))
    return _ret


  @functools.native_method
  def set_transform(self, cache_index:'int'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets 2D transform, applied to the font outlines, can be used for slanting, flipping, and rotating glyphs.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(160,tuple([cache_index, transform._ptr]))

  @functools.native_method
  def get_transform(self, cache_index:'int'   ) -> typing.Union['Transform2D']:
    r'''
				Returns 2D transform, applied to the font outlines, can be used for slanting, flipping and rotating glyphs.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(161,tuple([cache_index]))
    return _ret


  @functools.native_method
  def set_extra_spacing(self, cache_index:'int'   , spacing:'int'  , value:'int'   ) -> None:
    r'''
				Sets the spacing for `spacing` to `value` in pixels (not relative to the font size).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(162,tuple([cache_index, spacing, value]))

  @functools.native_method
  def get_extra_spacing(self, cache_index:'int'   , spacing:'int'  ) -> typing.Union[int]:
    r'''
				Returns spacing for `spacing` in pixels (not relative to the font size).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(163,tuple([cache_index, spacing]))
    return _ret


  @functools.native_method
  def set_extra_baseline_offset(self, cache_index:'int'   , baseline_offset:'float'   ) -> None:
    r'''
				Sets extra baseline offset (as a fraction of font height).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(baseline_offset, (int, float)), 'baseline_offset must be int or float'







    self._ptr.call_with_return(164,tuple([cache_index, baseline_offset]))

  @functools.native_method
  def get_extra_baseline_offset(self, cache_index:'int'   ) -> typing.Union[float]:
    r'''
				Returns extra baseline offset (as a fraction of font height).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(165,tuple([cache_index]))
    return _ret


  @functools.native_method
  def set_face_index(self, cache_index:'int'   , face_index:'int'   ) -> None:
    r'''
				Sets an active face index in the TrueType / OpenType collection.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(face_index, (int, float)), 'face_index must be int or float'







    self._ptr.call_with_return(166,tuple([cache_index, face_index]))

  @functools.native_method
  def get_face_index(self, cache_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns an active face index in the TrueType / OpenType collection.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(167,tuple([cache_index]))
    return _ret


  @functools.native_method
  def set_cache_ascent(self, cache_index:'int'   , size:'int'   , ascent:'float'   ) -> None:
    r'''
				Sets the font ascent (number of pixels above the baseline).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(ascent, (int, float)), 'ascent must be int or float'








    self._ptr.call_with_return(168,tuple([cache_index, size, ascent]))

  @functools.native_method
  def get_cache_ascent(self, cache_index:'int'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns the font ascent (number of pixels above the baseline).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(169,tuple([cache_index, size]))
    return _ret


  @functools.native_method
  def set_cache_descent(self, cache_index:'int'   , size:'int'   , descent:'float'   ) -> None:
    r'''
				Sets the font descent (number of pixels below the baseline).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(descent, (int, float)), 'descent must be int or float'








    self._ptr.call_with_return(170,tuple([cache_index, size, descent]))

  @functools.native_method
  def get_cache_descent(self, cache_index:'int'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns the font descent (number of pixels below the baseline).
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(171,tuple([cache_index, size]))
    return _ret


  @functools.native_method
  def set_cache_underline_position(self, cache_index:'int'   , size:'int'   , underline_position:'float'   ) -> None:
    r'''
				Sets pixel offset of the underline below the baseline.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(underline_position, (int, float)), 'underline_position must be int or float'








    self._ptr.call_with_return(172,tuple([cache_index, size, underline_position]))

  @functools.native_method
  def get_cache_underline_position(self, cache_index:'int'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns pixel offset of the underline below the baseline.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(173,tuple([cache_index, size]))
    return _ret


  @functools.native_method
  def set_cache_underline_thickness(self, cache_index:'int'   , size:'int'   , underline_thickness:'float'   ) -> None:
    r'''
				Sets thickness of the underline in pixels.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(underline_thickness, (int, float)), 'underline_thickness must be int or float'








    self._ptr.call_with_return(174,tuple([cache_index, size, underline_thickness]))

  @functools.native_method
  def get_cache_underline_thickness(self, cache_index:'int'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns thickness of the underline in pixels.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(175,tuple([cache_index, size]))
    return _ret


  @functools.native_method
  def set_cache_scale(self, cache_index:'int'   , size:'int'   , scale:'float'   ) -> None:
    r'''
				Sets scaling factor of the color bitmap font.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(scale, (int, float)), 'scale must be int or float'








    self._ptr.call_with_return(176,tuple([cache_index, size, scale]))

  @functools.native_method
  def get_cache_scale(self, cache_index:'int'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns scaling factor of the color bitmap font.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(177,tuple([cache_index, size]))
    return _ret


  @functools.native_method
  def get_texture_count(self, cache_index:'int'   , size:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns number of textures used by font cache entry.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(178,tuple([cache_index, size._ptr]))
    return _ret


  @functools.native_method
  def clear_textures(self, cache_index:'int'   , size:'Vector2i'   ) -> None:
    r'''
				Removes all textures from font cache entry.
				**Note:** This function will not remove glyphs associated with the texture, use `remove_glyph` to remove them manually.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'







    self._ptr.call_with_return(179,tuple([cache_index, size._ptr]))

  @functools.native_method
  def remove_texture(self, cache_index:'int'   , size:'Vector2i'   , texture_index:'int'   ) -> None:
    r'''
				Removes specified texture from the cache entry.
				**Note:** This function will not remove glyphs associated with the texture. Remove them manually using `remove_glyph`.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'








    self._ptr.call_with_return(180,tuple([cache_index, size._ptr, texture_index]))

  @functools.native_method
  def set_texture_image(self, cache_index:'int'   , size:'Vector2i'   , texture_index:'int'   , image:'py4godot_image.Image'   ) -> None:
    r'''
				Sets font cache texture image.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'
    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'









    self._ptr.call_with_return(181,tuple([cache_index, size._ptr, texture_index, image._ptr]))

  @functools.native_method
  def get_texture_image(self, cache_index:'int'   , size:'Vector2i'   , texture_index:'int'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns a copy of the font cache texture image.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(182,tuple([cache_index, size._ptr, texture_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_texture_offsets(self, cache_index:'int'   , size:'Vector2i'   , texture_index:'int'   , offset:'PackedInt32Array'   ) -> None:
    r'''
				Sets array containing glyph packing data.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'
    assert(not offset is None)
    assert isinstance(offset, PackedInt32Array), 'offset must be PackedInt32Array'









    self._ptr.call_with_return(183,tuple([cache_index, size._ptr, texture_index, offset._ptr]))

  @functools.native_method
  def get_texture_offsets(self, cache_index:'int'   , size:'Vector2i'   , texture_index:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns a copy of the array containing glyph packing data.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'








    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(184,tuple([cache_index, size._ptr, texture_index]))
    return _ret


  @functools.native_method
  def get_glyph_list(self, cache_index:'int'   , size:'Vector2i'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns list of rendered glyphs in the cache entry.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(185,tuple([cache_index, size._ptr]))
    return _ret


  @functools.native_method
  def clear_glyphs(self, cache_index:'int'   , size:'Vector2i'   ) -> None:
    r'''
				Removes all rendered glyph information from the cache entry.
				**Note:** This function will not remove textures associated with the glyphs, use `remove_texture` to remove them manually.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'







    self._ptr.call_with_return(186,tuple([cache_index, size._ptr]))

  @functools.native_method
  def remove_glyph(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   ) -> None:
    r'''
				Removes specified rendered glyph information from the cache entry.
				**Note:** This function will not remove textures associated with the glyphs, use `remove_texture` to remove them manually.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'








    self._ptr.call_with_return(187,tuple([cache_index, size._ptr, glyph]))

  @functools.native_method
  def set_glyph_advance(self, cache_index:'int'   , size:'int'   , glyph:'int'   , advance:'Vector2'   ) -> None:
    r'''
				Sets glyph advance (offset of the next glyph).
				**Note:** Advance for glyphs outlines is the same as the base glyph advance and is not saved.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not advance is None)
    assert isinstance(advance, Vector2), 'advance must be Vector2'









    self._ptr.call_with_return(188,tuple([cache_index, size, glyph, advance._ptr]))

  @functools.native_method
  def get_glyph_advance(self, cache_index:'int'   , size:'int'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns glyph advance (offset of the next glyph).
				**Note:** Advance for glyphs outlines is the same as the base glyph advance and is not saved.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(189,tuple([cache_index, size, glyph]))
    return _ret


  @functools.native_method
  def set_glyph_offset(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   , offset:'Vector2'   ) -> None:
    r'''
				Sets glyph offset from the baseline.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'









    self._ptr.call_with_return(190,tuple([cache_index, size._ptr, glyph, offset._ptr]))

  @functools.native_method
  def get_glyph_offset(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns glyph offset from the baseline.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(191,tuple([cache_index, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def set_glyph_size(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   , gl_size:'Vector2'   ) -> None:
    r'''
				Sets glyph size.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not gl_size is None)
    assert isinstance(gl_size, Vector2), 'gl_size must be Vector2'









    self._ptr.call_with_return(192,tuple([cache_index, size._ptr, glyph, gl_size._ptr]))

  @functools.native_method
  def get_glyph_size(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns glyph size.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(193,tuple([cache_index, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def set_glyph_uv_rect(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   , uv_rect:'Rect2'   ) -> None:
    r'''
				Sets rectangle in the cache texture containing the glyph.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not uv_rect is None)
    assert isinstance(uv_rect, Rect2), 'uv_rect must be Rect2'









    self._ptr.call_with_return(194,tuple([cache_index, size._ptr, glyph, uv_rect._ptr]))

  @functools.native_method
  def get_glyph_uv_rect(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Rect2']:
    r'''
				Returns rectangle in the cache texture containing the glyph.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'








    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(195,tuple([cache_index, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def set_glyph_texture_idx(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   , texture_idx:'int'   ) -> None:
    r'''
				Sets index of the cache texture containing the glyph.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert isinstance(texture_idx, (int, float)), 'texture_idx must be int or float'









    self._ptr.call_with_return(196,tuple([cache_index, size._ptr, glyph, texture_idx]))

  @functools.native_method
  def get_glyph_texture_idx(self, cache_index:'int'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union[int]:
    r'''
				Returns index of the cache texture containing the glyph.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(197,tuple([cache_index, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def get_kerning_list(self, cache_index:'int'   , size:'int'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns list of the kerning overrides.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(198,tuple([cache_index, size]))
    return _ret


  @functools.native_method
  def clear_kerning_map(self, cache_index:'int'   , size:'int'   ) -> None:
    r'''
				Removes all kerning overrides.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'







    self._ptr.call_with_return(199,tuple([cache_index, size]))

  @functools.native_method
  def remove_kerning(self, cache_index:'int'   , size:'int'   , glyph_pair:'Vector2i'   ) -> None:
    r'''
				Removes kerning override for the pair of glyphs.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'








    self._ptr.call_with_return(200,tuple([cache_index, size, glyph_pair._ptr]))

  @functools.native_method
  def set_kerning(self, cache_index:'int'   , size:'int'   , glyph_pair:'Vector2i'   , kerning:'Vector2'   ) -> None:
    r'''
				Sets kerning for the pair of glyphs.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'
    assert(not kerning is None)
    assert isinstance(kerning, Vector2), 'kerning must be Vector2'









    self._ptr.call_with_return(201,tuple([cache_index, size, glyph_pair._ptr, kerning._ptr]))

  @functools.native_method
  def get_kerning(self, cache_index:'int'   , size:'int'   , glyph_pair:'Vector2i'   ) -> typing.Union['Vector2']:
    r'''
				Returns kerning for the pair of glyphs.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(202,tuple([cache_index, size, glyph_pair._ptr]))
    return _ret


  @functools.native_method
  def render_range(self, cache_index:'int'   , size:'Vector2i'   , start:'int'   , end:'int'   ) -> None:
    r'''
				Renders the range of characters to the font cache texture.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'









    self._ptr.call_with_return(203,tuple([cache_index, size._ptr, start, end]))

  @functools.native_method
  def render_glyph(self, cache_index:'int'   , size:'Vector2i'   , index:'int'   ) -> None:
    r'''
				Renders specified glyph to the font cache texture.
			'''

    assert isinstance(cache_index, (int, float)), 'cache_index must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(index, (int, float)), 'index must be int or float'








    self._ptr.call_with_return(204,tuple([cache_index, size._ptr, index]))

  @functools.native_method
  def set_language_support_override(self, language:'str'   , supported:'bool'   ) -> None:
    r'''
				Adds override for `Font.is_language_supported`.
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'
    assert isinstance(supported, bool), 'supported must be bool'




    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    self._ptr.call_with_return(205,tuple([py_string_language._ptr, supported]))

  @functools.native_method
  def get_language_support_override(self, language:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if support override is enabled for the `language`.
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'




    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = 0
    _ret = self._ptr.call_with_return(206,tuple([py_string_language._ptr]))
    return _ret


  @functools.native_method
  def remove_language_support_override(self, language:'str'   ) -> None:
    r'''
				Remove language support override.
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'




    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(207,tuple([py_string_language._ptr]))

  @functools.native_method
  def get_language_support_overrides(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns list of language support overrides.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(208,tuple([]))
    return _ret


  @functools.native_method
  def set_script_support_override(self, script:'str'   , supported:'bool'   ) -> None:
    r'''
				Adds override for `Font.is_script_supported`.
			'''

    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'
    assert isinstance(supported, bool), 'supported must be bool'




    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)


    self._ptr.call_with_return(209,tuple([py_string_script._ptr, supported]))

  @functools.native_method
  def get_script_support_override(self, script:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if support override is enabled for the `script`.
			'''

    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'




    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    _ret = 0
    _ret = self._ptr.call_with_return(210,tuple([py_string_script._ptr]))
    return _ret


  @functools.native_method
  def remove_script_support_override(self, script:'str'   ) -> None:
    r'''
				Removes script support override.
			'''

    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'




    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    self._ptr.call_with_return(211,tuple([py_string_script._ptr]))

  @functools.native_method
  def get_script_support_overrides(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns list of script support overrides.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(212,tuple([]))
    return _ret


  @functools.native_method
  def set_opentype_feature_overrides(self, overrides:'Dictionary'   ) -> None:
    r''''''

    assert(not overrides is None)
    assert isinstance(overrides, Dictionary), 'overrides must be Dictionary'

    self.py__opentype_feature_overrides = overrides






    self._ptr.call_with_return(213,tuple([overrides._ptr]))

  @functools.native_method
  def get_opentype_feature_overrides(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(214,tuple([]))

    return _ret


  @functools.native_method
  def get_glyph_index(self, size:'int'   , char:'int'   , variation_selector:'int'   ) -> typing.Union[int]:
    r'''
				Returns the glyph index of a `char`, optionally modified by the `variation_selector`.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(char, (int, float)), 'char must be int or float'
    assert isinstance(variation_selector, (int, float)), 'variation_selector must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(215,tuple([size, char, variation_selector]))
    return _ret


  @functools.native_method
  def get_char_from_glyph_index(self, size:'int'   , glyph_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns character code associated with `glyph_index`, or `0` if `glyph_index` is invalid. See `get_glyph_index`.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph_index, (int, float)), 'glyph_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(216,tuple([size, glyph_index]))
    return _ret



register_cast_function('FontFile', FontFile.cast)
register_class('FontFile', FontFile)
