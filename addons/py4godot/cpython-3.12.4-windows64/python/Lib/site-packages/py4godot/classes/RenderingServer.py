# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
  import py4godot.classes.RenderingDevice as py4godot_renderingdevice 
  import py4godot.classes.Transform3DTypedArray as py4godot_transform3dtypedarray 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.ArrayTypedArray as py4godot_arraytypedarray 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.ImageTypedArray as py4godot_imagetypedarray 
  import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
import py4godot.classes.Transform3DTypedArray as py4godot_transform3dtypedarray 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.ArrayTypedArray as py4godot_arraytypedarray 
import py4godot.classes.ImageTypedArray as py4godot_imagetypedarray 
import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
from py4godot.wrappers.wrappers import CPPRenderingServerWrapper

_RenderingServer_singleton_instance = None
class TextureType:
  TEXTURE_TYPE_2D = 0
  TEXTURE_TYPE_LAYERED = 1
  TEXTURE_TYPE_3D = 2
class TextureLayeredType:
  TEXTURE_LAYERED_2D_ARRAY = 0
  TEXTURE_LAYERED_CUBEMAP = 1
  TEXTURE_LAYERED_CUBEMAP_ARRAY = 2
class CubeMapLayer:
  CUBEMAP_LAYER_LEFT = 0
  CUBEMAP_LAYER_RIGHT = 1
  CUBEMAP_LAYER_BOTTOM = 2
  CUBEMAP_LAYER_TOP = 3
  CUBEMAP_LAYER_FRONT = 4
  CUBEMAP_LAYER_BACK = 5
class ShaderMode:
  SHADER_SPATIAL = 0
  SHADER_CANVAS_ITEM = 1
  SHADER_PARTICLES = 2
  SHADER_SKY = 3
  SHADER_FOG = 4
  SHADER_MAX = 5
class ArrayType:
  ARRAY_VERTEX = 0
  ARRAY_NORMAL = 1
  ARRAY_TANGENT = 2
  ARRAY_COLOR = 3
  ARRAY_TEX_UV = 4
  ARRAY_TEX_UV2 = 5
  ARRAY_CUSTOM0 = 6
  ARRAY_CUSTOM1 = 7
  ARRAY_CUSTOM2 = 8
  ARRAY_CUSTOM3 = 9
  ARRAY_BONES = 10
  ARRAY_WEIGHTS = 11
  ARRAY_INDEX = 12
  ARRAY_MAX = 13
class ArrayCustomFormat:
  ARRAY_CUSTOM_RGBA8_UNORM = 0
  ARRAY_CUSTOM_RGBA8_SNORM = 1
  ARRAY_CUSTOM_RG_HALF = 2
  ARRAY_CUSTOM_RGBA_HALF = 3
  ARRAY_CUSTOM_R_FLOAT = 4
  ARRAY_CUSTOM_RG_FLOAT = 5
  ARRAY_CUSTOM_RGB_FLOAT = 6
  ARRAY_CUSTOM_RGBA_FLOAT = 7
  ARRAY_CUSTOM_MAX = 8
class ArrayFormat:
  ARRAY_FORMAT_VERTEX = 1
  ARRAY_FORMAT_NORMAL = 2
  ARRAY_FORMAT_TANGENT = 4
  ARRAY_FORMAT_COLOR = 8
  ARRAY_FORMAT_TEX_UV = 16
  ARRAY_FORMAT_TEX_UV2 = 32
  ARRAY_FORMAT_CUSTOM0 = 64
  ARRAY_FORMAT_CUSTOM1 = 128
  ARRAY_FORMAT_CUSTOM2 = 256
  ARRAY_FORMAT_CUSTOM3 = 512
  ARRAY_FORMAT_BONES = 1024
  ARRAY_FORMAT_WEIGHTS = 2048
  ARRAY_FORMAT_INDEX = 4096
  ARRAY_FORMAT_BLEND_SHAPE_MASK = 7
  ARRAY_FORMAT_CUSTOM_BASE = 13
  ARRAY_FORMAT_CUSTOM_BITS = 3
  ARRAY_FORMAT_CUSTOM0_SHIFT = 13
  ARRAY_FORMAT_CUSTOM1_SHIFT = 16
  ARRAY_FORMAT_CUSTOM2_SHIFT = 19
  ARRAY_FORMAT_CUSTOM3_SHIFT = 22
  ARRAY_FORMAT_CUSTOM_MASK = 7
  ARRAY_COMPRESS_FLAGS_BASE = 25
  ARRAY_FLAG_USE_2D_VERTICES = 33554432
  ARRAY_FLAG_USE_DYNAMIC_UPDATE = 67108864
  ARRAY_FLAG_USE_8_BONE_WEIGHTS = 134217728
  ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY = 268435456
  ARRAY_FLAG_COMPRESS_ATTRIBUTES = 536870912
  ARRAY_FLAG_FORMAT_VERSION_BASE = 35
  ARRAY_FLAG_FORMAT_VERSION_SHIFT = 35
  ARRAY_FLAG_FORMAT_VERSION_1 = 0
  ARRAY_FLAG_FORMAT_VERSION_2 = 34359738368
  ARRAY_FLAG_FORMAT_CURRENT_VERSION = 34359738368
  ARRAY_FLAG_FORMAT_VERSION_MASK = 255
class PrimitiveType:
  PRIMITIVE_POINTS = 0
  PRIMITIVE_LINES = 1
  PRIMITIVE_LINE_STRIP = 2
  PRIMITIVE_TRIANGLES = 3
  PRIMITIVE_TRIANGLE_STRIP = 4
  PRIMITIVE_MAX = 5
class BlendShapeMode:
  BLEND_SHAPE_MODE_NORMALIZED = 0
  BLEND_SHAPE_MODE_RELATIVE = 1
class MultimeshTransformFormat:
  MULTIMESH_TRANSFORM_2D = 0
  MULTIMESH_TRANSFORM_3D = 1
class MultimeshPhysicsInterpolationQuality:
  MULTIMESH_INTERP_QUALITY_FAST = 0
  MULTIMESH_INTERP_QUALITY_HIGH = 1
class LightProjectorFilter:
  LIGHT_PROJECTOR_FILTER_NEAREST = 0
  LIGHT_PROJECTOR_FILTER_LINEAR = 1
  LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS = 2
  LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS = 3
  LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS_ANISOTROPIC = 4
  LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS_ANISOTROPIC = 5
class LightType:
  LIGHT_DIRECTIONAL = 0
  LIGHT_OMNI = 1
  LIGHT_SPOT = 2
class LightParam:
  LIGHT_PARAM_ENERGY = 0
  LIGHT_PARAM_INDIRECT_ENERGY = 1
  LIGHT_PARAM_VOLUMETRIC_FOG_ENERGY = 2
  LIGHT_PARAM_SPECULAR = 3
  LIGHT_PARAM_RANGE = 4
  LIGHT_PARAM_SIZE = 5
  LIGHT_PARAM_ATTENUATION = 6
  LIGHT_PARAM_SPOT_ANGLE = 7
  LIGHT_PARAM_SPOT_ATTENUATION = 8
  LIGHT_PARAM_SHADOW_MAX_DISTANCE = 9
  LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET = 10
  LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET = 11
  LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET = 12
  LIGHT_PARAM_SHADOW_FADE_START = 13
  LIGHT_PARAM_SHADOW_NORMAL_BIAS = 14
  LIGHT_PARAM_SHADOW_BIAS = 15
  LIGHT_PARAM_SHADOW_PANCAKE_SIZE = 16
  LIGHT_PARAM_SHADOW_OPACITY = 17
  LIGHT_PARAM_SHADOW_BLUR = 18
  LIGHT_PARAM_TRANSMITTANCE_BIAS = 19
  LIGHT_PARAM_INTENSITY = 20
  LIGHT_PARAM_MAX = 21
class LightBakeMode:
  LIGHT_BAKE_DISABLED = 0
  LIGHT_BAKE_STATIC = 1
  LIGHT_BAKE_DYNAMIC = 2
class LightOmniShadowMode:
  LIGHT_OMNI_SHADOW_DUAL_PARABOLOID = 0
  LIGHT_OMNI_SHADOW_CUBE = 1
class LightDirectionalShadowMode:
  LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL = 0
  LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS = 1
  LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS = 2
class LightDirectionalSkyMode:
  LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_AND_SKY = 0
  LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_ONLY = 1
  LIGHT_DIRECTIONAL_SKY_MODE_SKY_ONLY = 2
class ShadowQuality:
  SHADOW_QUALITY_HARD = 0
  SHADOW_QUALITY_SOFT_VERY_LOW = 1
  SHADOW_QUALITY_SOFT_LOW = 2
  SHADOW_QUALITY_SOFT_MEDIUM = 3
  SHADOW_QUALITY_SOFT_HIGH = 4
  SHADOW_QUALITY_SOFT_ULTRA = 5
  SHADOW_QUALITY_MAX = 6
class ReflectionProbeUpdateMode:
  REFLECTION_PROBE_UPDATE_ONCE = 0
  REFLECTION_PROBE_UPDATE_ALWAYS = 1
class ReflectionProbeAmbientMode:
  REFLECTION_PROBE_AMBIENT_DISABLED = 0
  REFLECTION_PROBE_AMBIENT_ENVIRONMENT = 1
  REFLECTION_PROBE_AMBIENT_COLOR = 2
class DecalTexture:
  DECAL_TEXTURE_ALBEDO = 0
  DECAL_TEXTURE_NORMAL = 1
  DECAL_TEXTURE_ORM = 2
  DECAL_TEXTURE_EMISSION = 3
  DECAL_TEXTURE_MAX = 4
class DecalFilter:
  DECAL_FILTER_NEAREST = 0
  DECAL_FILTER_LINEAR = 1
  DECAL_FILTER_NEAREST_MIPMAPS = 2
  DECAL_FILTER_LINEAR_MIPMAPS = 3
  DECAL_FILTER_NEAREST_MIPMAPS_ANISOTROPIC = 4
  DECAL_FILTER_LINEAR_MIPMAPS_ANISOTROPIC = 5
class VoxelGIQuality:
  VOXEL_GI_QUALITY_LOW = 0
  VOXEL_GI_QUALITY_HIGH = 1
class ParticlesMode:
  PARTICLES_MODE_2D = 0
  PARTICLES_MODE_3D = 1
class ParticlesTransformAlign:
  PARTICLES_TRANSFORM_ALIGN_DISABLED = 0
  PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD = 1
  PARTICLES_TRANSFORM_ALIGN_Y_TO_VELOCITY = 2
  PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY = 3
class ParticlesDrawOrder:
  PARTICLES_DRAW_ORDER_INDEX = 0
  PARTICLES_DRAW_ORDER_LIFETIME = 1
  PARTICLES_DRAW_ORDER_REVERSE_LIFETIME = 2
  PARTICLES_DRAW_ORDER_VIEW_DEPTH = 3
class ParticlesCollisionType:
  PARTICLES_COLLISION_TYPE_SPHERE_ATTRACT = 0
  PARTICLES_COLLISION_TYPE_BOX_ATTRACT = 1
  PARTICLES_COLLISION_TYPE_VECTOR_FIELD_ATTRACT = 2
  PARTICLES_COLLISION_TYPE_SPHERE_COLLIDE = 3
  PARTICLES_COLLISION_TYPE_BOX_COLLIDE = 4
  PARTICLES_COLLISION_TYPE_SDF_COLLIDE = 5
  PARTICLES_COLLISION_TYPE_HEIGHTFIELD_COLLIDE = 6
class ParticlesCollisionHeightfieldResolution:
  PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_256 = 0
  PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_512 = 1
  PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_1024 = 2
  PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_2048 = 3
  PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_4096 = 4
  PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_8192 = 5
  PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_MAX = 6
class FogVolumeShape:
  FOG_VOLUME_SHAPE_ELLIPSOID = 0
  FOG_VOLUME_SHAPE_CONE = 1
  FOG_VOLUME_SHAPE_CYLINDER = 2
  FOG_VOLUME_SHAPE_BOX = 3
  FOG_VOLUME_SHAPE_WORLD = 4
  FOG_VOLUME_SHAPE_MAX = 5
class ViewportScaling3DMode:
  VIEWPORT_SCALING_3D_MODE_BILINEAR = 0
  VIEWPORT_SCALING_3D_MODE_FSR = 1
  VIEWPORT_SCALING_3D_MODE_FSR2 = 2
  VIEWPORT_SCALING_3D_MODE_METALFX_SPATIAL = 3
  VIEWPORT_SCALING_3D_MODE_METALFX_TEMPORAL = 4
  VIEWPORT_SCALING_3D_MODE_MAX = 5
class ViewportUpdateMode:
  VIEWPORT_UPDATE_DISABLED = 0
  VIEWPORT_UPDATE_ONCE = 1
  VIEWPORT_UPDATE_WHEN_VISIBLE = 2
  VIEWPORT_UPDATE_WHEN_PARENT_VISIBLE = 3
  VIEWPORT_UPDATE_ALWAYS = 4
class ViewportClearMode:
  VIEWPORT_CLEAR_ALWAYS = 0
  VIEWPORT_CLEAR_NEVER = 1
  VIEWPORT_CLEAR_ONLY_NEXT_FRAME = 2
class ViewportEnvironmentMode:
  VIEWPORT_ENVIRONMENT_DISABLED = 0
  VIEWPORT_ENVIRONMENT_ENABLED = 1
  VIEWPORT_ENVIRONMENT_INHERIT = 2
  VIEWPORT_ENVIRONMENT_MAX = 3
class ViewportSDFOversize:
  VIEWPORT_SDF_OVERSIZE_100_PERCENT = 0
  VIEWPORT_SDF_OVERSIZE_120_PERCENT = 1
  VIEWPORT_SDF_OVERSIZE_150_PERCENT = 2
  VIEWPORT_SDF_OVERSIZE_200_PERCENT = 3
  VIEWPORT_SDF_OVERSIZE_MAX = 4
class ViewportSDFScale:
  VIEWPORT_SDF_SCALE_100_PERCENT = 0
  VIEWPORT_SDF_SCALE_50_PERCENT = 1
  VIEWPORT_SDF_SCALE_25_PERCENT = 2
  VIEWPORT_SDF_SCALE_MAX = 3
class ViewportMSAA:
  VIEWPORT_MSAA_DISABLED = 0
  VIEWPORT_MSAA_2X = 1
  VIEWPORT_MSAA_4X = 2
  VIEWPORT_MSAA_8X = 3
  VIEWPORT_MSAA_MAX = 4
class ViewportAnisotropicFiltering:
  VIEWPORT_ANISOTROPY_DISABLED = 0
  VIEWPORT_ANISOTROPY_2X = 1
  VIEWPORT_ANISOTROPY_4X = 2
  VIEWPORT_ANISOTROPY_8X = 3
  VIEWPORT_ANISOTROPY_16X = 4
  VIEWPORT_ANISOTROPY_MAX = 5
class ViewportScreenSpaceAA:
  VIEWPORT_SCREEN_SPACE_AA_DISABLED = 0
  VIEWPORT_SCREEN_SPACE_AA_FXAA = 1
  VIEWPORT_SCREEN_SPACE_AA_SMAA = 2
  VIEWPORT_SCREEN_SPACE_AA_MAX = 3
class ViewportOcclusionCullingBuildQuality:
  VIEWPORT_OCCLUSION_BUILD_QUALITY_LOW = 0
  VIEWPORT_OCCLUSION_BUILD_QUALITY_MEDIUM = 1
  VIEWPORT_OCCLUSION_BUILD_QUALITY_HIGH = 2
class ViewportRenderInfo:
  VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME = 0
  VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME = 1
  VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME = 2
  VIEWPORT_RENDER_INFO_MAX = 3
class ViewportRenderInfoType:
  VIEWPORT_RENDER_INFO_TYPE_VISIBLE = 0
  VIEWPORT_RENDER_INFO_TYPE_SHADOW = 1
  VIEWPORT_RENDER_INFO_TYPE_CANVAS = 2
  VIEWPORT_RENDER_INFO_TYPE_MAX = 3
class ViewportDebugDraw:
  VIEWPORT_DEBUG_DRAW_DISABLED = 0
  VIEWPORT_DEBUG_DRAW_UNSHADED = 1
  VIEWPORT_DEBUG_DRAW_LIGHTING = 2
  VIEWPORT_DEBUG_DRAW_OVERDRAW = 3
  VIEWPORT_DEBUG_DRAW_WIREFRAME = 4
  VIEWPORT_DEBUG_DRAW_NORMAL_BUFFER = 5
  VIEWPORT_DEBUG_DRAW_VOXEL_GI_ALBEDO = 6
  VIEWPORT_DEBUG_DRAW_VOXEL_GI_LIGHTING = 7
  VIEWPORT_DEBUG_DRAW_VOXEL_GI_EMISSION = 8
  VIEWPORT_DEBUG_DRAW_SHADOW_ATLAS = 9
  VIEWPORT_DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS = 10
  VIEWPORT_DEBUG_DRAW_SCENE_LUMINANCE = 11
  VIEWPORT_DEBUG_DRAW_SSAO = 12
  VIEWPORT_DEBUG_DRAW_SSIL = 13
  VIEWPORT_DEBUG_DRAW_PSSM_SPLITS = 14
  VIEWPORT_DEBUG_DRAW_DECAL_ATLAS = 15
  VIEWPORT_DEBUG_DRAW_SDFGI = 16
  VIEWPORT_DEBUG_DRAW_SDFGI_PROBES = 17
  VIEWPORT_DEBUG_DRAW_GI_BUFFER = 18
  VIEWPORT_DEBUG_DRAW_DISABLE_LOD = 19
  VIEWPORT_DEBUG_DRAW_CLUSTER_OMNI_LIGHTS = 20
  VIEWPORT_DEBUG_DRAW_CLUSTER_SPOT_LIGHTS = 21
  VIEWPORT_DEBUG_DRAW_CLUSTER_DECALS = 22
  VIEWPORT_DEBUG_DRAW_CLUSTER_REFLECTION_PROBES = 23
  VIEWPORT_DEBUG_DRAW_OCCLUDERS = 24
  VIEWPORT_DEBUG_DRAW_MOTION_VECTORS = 25
  VIEWPORT_DEBUG_DRAW_INTERNAL_BUFFER = 26
class ViewportVRSMode:
  VIEWPORT_VRS_DISABLED = 0
  VIEWPORT_VRS_TEXTURE = 1
  VIEWPORT_VRS_XR = 2
  VIEWPORT_VRS_MAX = 3
class ViewportVRSUpdateMode:
  VIEWPORT_VRS_UPDATE_DISABLED = 0
  VIEWPORT_VRS_UPDATE_ONCE = 1
  VIEWPORT_VRS_UPDATE_ALWAYS = 2
  VIEWPORT_VRS_UPDATE_MAX = 3
class SkyMode:
  SKY_MODE_AUTOMATIC = 0
  SKY_MODE_QUALITY = 1
  SKY_MODE_INCREMENTAL = 2
  SKY_MODE_REALTIME = 3
class CompositorEffectFlags:
  COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_COLOR = 1
  COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_DEPTH = 2
  COMPOSITOR_EFFECT_FLAG_NEEDS_MOTION_VECTORS = 4
  COMPOSITOR_EFFECT_FLAG_NEEDS_ROUGHNESS = 8
  COMPOSITOR_EFFECT_FLAG_NEEDS_SEPARATE_SPECULAR = 16
class CompositorEffectCallbackType:
  COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_OPAQUE = 0
  COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_OPAQUE = 1
  COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_SKY = 2
  COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT = 3
  COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_TRANSPARENT = 4
  COMPOSITOR_EFFECT_CALLBACK_TYPE_ANY = -1
class EnvironmentBG:
  ENV_BG_CLEAR_COLOR = 0
  ENV_BG_COLOR = 1
  ENV_BG_SKY = 2
  ENV_BG_CANVAS = 3
  ENV_BG_KEEP = 4
  ENV_BG_CAMERA_FEED = 5
  ENV_BG_MAX = 6
class EnvironmentAmbientSource:
  ENV_AMBIENT_SOURCE_BG = 0
  ENV_AMBIENT_SOURCE_DISABLED = 1
  ENV_AMBIENT_SOURCE_COLOR = 2
  ENV_AMBIENT_SOURCE_SKY = 3
class EnvironmentReflectionSource:
  ENV_REFLECTION_SOURCE_BG = 0
  ENV_REFLECTION_SOURCE_DISABLED = 1
  ENV_REFLECTION_SOURCE_SKY = 2
class EnvironmentGlowBlendMode:
  ENV_GLOW_BLEND_MODE_ADDITIVE = 0
  ENV_GLOW_BLEND_MODE_SCREEN = 1
  ENV_GLOW_BLEND_MODE_SOFTLIGHT = 2
  ENV_GLOW_BLEND_MODE_REPLACE = 3
  ENV_GLOW_BLEND_MODE_MIX = 4
class EnvironmentFogMode:
  ENV_FOG_MODE_EXPONENTIAL = 0
  ENV_FOG_MODE_DEPTH = 1
class EnvironmentToneMapper:
  ENV_TONE_MAPPER_LINEAR = 0
  ENV_TONE_MAPPER_REINHARD = 1
  ENV_TONE_MAPPER_FILMIC = 2
  ENV_TONE_MAPPER_ACES = 3
  ENV_TONE_MAPPER_AGX = 4
class EnvironmentSSRRoughnessQuality:
  ENV_SSR_ROUGHNESS_QUALITY_DISABLED = 0
  ENV_SSR_ROUGHNESS_QUALITY_LOW = 1
  ENV_SSR_ROUGHNESS_QUALITY_MEDIUM = 2
  ENV_SSR_ROUGHNESS_QUALITY_HIGH = 3
class EnvironmentSSAOQuality:
  ENV_SSAO_QUALITY_VERY_LOW = 0
  ENV_SSAO_QUALITY_LOW = 1
  ENV_SSAO_QUALITY_MEDIUM = 2
  ENV_SSAO_QUALITY_HIGH = 3
  ENV_SSAO_QUALITY_ULTRA = 4
class EnvironmentSSILQuality:
  ENV_SSIL_QUALITY_VERY_LOW = 0
  ENV_SSIL_QUALITY_LOW = 1
  ENV_SSIL_QUALITY_MEDIUM = 2
  ENV_SSIL_QUALITY_HIGH = 3
  ENV_SSIL_QUALITY_ULTRA = 4
class EnvironmentSDFGIYScale:
  ENV_SDFGI_Y_SCALE_50_PERCENT = 0
  ENV_SDFGI_Y_SCALE_75_PERCENT = 1
  ENV_SDFGI_Y_SCALE_100_PERCENT = 2
class EnvironmentSDFGIRayCount:
  ENV_SDFGI_RAY_COUNT_4 = 0
  ENV_SDFGI_RAY_COUNT_8 = 1
  ENV_SDFGI_RAY_COUNT_16 = 2
  ENV_SDFGI_RAY_COUNT_32 = 3
  ENV_SDFGI_RAY_COUNT_64 = 4
  ENV_SDFGI_RAY_COUNT_96 = 5
  ENV_SDFGI_RAY_COUNT_128 = 6
  ENV_SDFGI_RAY_COUNT_MAX = 7
class EnvironmentSDFGIFramesToConverge:
  ENV_SDFGI_CONVERGE_IN_5_FRAMES = 0
  ENV_SDFGI_CONVERGE_IN_10_FRAMES = 1
  ENV_SDFGI_CONVERGE_IN_15_FRAMES = 2
  ENV_SDFGI_CONVERGE_IN_20_FRAMES = 3
  ENV_SDFGI_CONVERGE_IN_25_FRAMES = 4
  ENV_SDFGI_CONVERGE_IN_30_FRAMES = 5
  ENV_SDFGI_CONVERGE_MAX = 6
class EnvironmentSDFGIFramesToUpdateLight:
  ENV_SDFGI_UPDATE_LIGHT_IN_1_FRAME = 0
  ENV_SDFGI_UPDATE_LIGHT_IN_2_FRAMES = 1
  ENV_SDFGI_UPDATE_LIGHT_IN_4_FRAMES = 2
  ENV_SDFGI_UPDATE_LIGHT_IN_8_FRAMES = 3
  ENV_SDFGI_UPDATE_LIGHT_IN_16_FRAMES = 4
  ENV_SDFGI_UPDATE_LIGHT_MAX = 5
class SubSurfaceScatteringQuality:
  SUB_SURFACE_SCATTERING_QUALITY_DISABLED = 0
  SUB_SURFACE_SCATTERING_QUALITY_LOW = 1
  SUB_SURFACE_SCATTERING_QUALITY_MEDIUM = 2
  SUB_SURFACE_SCATTERING_QUALITY_HIGH = 3
class DOFBokehShape:
  DOF_BOKEH_BOX = 0
  DOF_BOKEH_HEXAGON = 1
  DOF_BOKEH_CIRCLE = 2
class DOFBlurQuality:
  DOF_BLUR_QUALITY_VERY_LOW = 0
  DOF_BLUR_QUALITY_LOW = 1
  DOF_BLUR_QUALITY_MEDIUM = 2
  DOF_BLUR_QUALITY_HIGH = 3
class InstanceType:
  INSTANCE_NONE = 0
  INSTANCE_MESH = 1
  INSTANCE_MULTIMESH = 2
  INSTANCE_PARTICLES = 3
  INSTANCE_PARTICLES_COLLISION = 4
  INSTANCE_LIGHT = 5
  INSTANCE_REFLECTION_PROBE = 6
  INSTANCE_DECAL = 7
  INSTANCE_VOXEL_GI = 8
  INSTANCE_LIGHTMAP = 9
  INSTANCE_OCCLUDER = 10
  INSTANCE_VISIBLITY_NOTIFIER = 11
  INSTANCE_FOG_VOLUME = 12
  INSTANCE_MAX = 13
  INSTANCE_GEOMETRY_MASK = 14
class InstanceFlags:
  INSTANCE_FLAG_USE_BAKED_LIGHT = 0
  INSTANCE_FLAG_USE_DYNAMIC_GI = 1
  INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE = 2
  INSTANCE_FLAG_IGNORE_OCCLUSION_CULLING = 3
  INSTANCE_FLAG_MAX = 4
class ShadowCastingSetting:
  SHADOW_CASTING_SETTING_OFF = 0
  SHADOW_CASTING_SETTING_ON = 1
  SHADOW_CASTING_SETTING_DOUBLE_SIDED = 2
  SHADOW_CASTING_SETTING_SHADOWS_ONLY = 3
class VisibilityRangeFadeMode:
  VISIBILITY_RANGE_FADE_DISABLED = 0
  VISIBILITY_RANGE_FADE_SELF = 1
  VISIBILITY_RANGE_FADE_DEPENDENCIES = 2
class BakeChannels:
  BAKE_CHANNEL_ALBEDO_ALPHA = 0
  BAKE_CHANNEL_NORMAL = 1
  BAKE_CHANNEL_ORM = 2
  BAKE_CHANNEL_EMISSION = 3
class CanvasTextureChannel:
  CANVAS_TEXTURE_CHANNEL_DIFFUSE = 0
  CANVAS_TEXTURE_CHANNEL_NORMAL = 1
  CANVAS_TEXTURE_CHANNEL_SPECULAR = 2
class NinePatchAxisMode:
  NINE_PATCH_STRETCH = 0
  NINE_PATCH_TILE = 1
  NINE_PATCH_TILE_FIT = 2
class CanvasItemTextureFilter:
  CANVAS_ITEM_TEXTURE_FILTER_DEFAULT = 0
  CANVAS_ITEM_TEXTURE_FILTER_NEAREST = 1
  CANVAS_ITEM_TEXTURE_FILTER_LINEAR = 2
  CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 3
  CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 4
  CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC = 5
  CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC = 6
  CANVAS_ITEM_TEXTURE_FILTER_MAX = 7
class CanvasItemTextureRepeat:
  CANVAS_ITEM_TEXTURE_REPEAT_DEFAULT = 0
  CANVAS_ITEM_TEXTURE_REPEAT_DISABLED = 1
  CANVAS_ITEM_TEXTURE_REPEAT_ENABLED = 2
  CANVAS_ITEM_TEXTURE_REPEAT_MIRROR = 3
  CANVAS_ITEM_TEXTURE_REPEAT_MAX = 4
class CanvasGroupMode:
  CANVAS_GROUP_MODE_DISABLED = 0
  CANVAS_GROUP_MODE_CLIP_ONLY = 1
  CANVAS_GROUP_MODE_CLIP_AND_DRAW = 2
  CANVAS_GROUP_MODE_TRANSPARENT = 3
class CanvasLightMode:
  CANVAS_LIGHT_MODE_POINT = 0
  CANVAS_LIGHT_MODE_DIRECTIONAL = 1
class CanvasLightBlendMode:
  CANVAS_LIGHT_BLEND_MODE_ADD = 0
  CANVAS_LIGHT_BLEND_MODE_SUB = 1
  CANVAS_LIGHT_BLEND_MODE_MIX = 2
class CanvasLightShadowFilter:
  CANVAS_LIGHT_FILTER_NONE = 0
  CANVAS_LIGHT_FILTER_PCF5 = 1
  CANVAS_LIGHT_FILTER_PCF13 = 2
  CANVAS_LIGHT_FILTER_MAX = 3
class CanvasOccluderPolygonCullMode:
  CANVAS_OCCLUDER_POLYGON_CULL_DISABLED = 0
  CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE = 1
  CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE = 2
class GlobalShaderParameterType:
  GLOBAL_VAR_TYPE_BOOL = 0
  GLOBAL_VAR_TYPE_BVEC2 = 1
  GLOBAL_VAR_TYPE_BVEC3 = 2
  GLOBAL_VAR_TYPE_BVEC4 = 3
  GLOBAL_VAR_TYPE_INT = 4
  GLOBAL_VAR_TYPE_IVEC2 = 5
  GLOBAL_VAR_TYPE_IVEC3 = 6
  GLOBAL_VAR_TYPE_IVEC4 = 7
  GLOBAL_VAR_TYPE_RECT2I = 8
  GLOBAL_VAR_TYPE_UINT = 9
  GLOBAL_VAR_TYPE_UVEC2 = 10
  GLOBAL_VAR_TYPE_UVEC3 = 11
  GLOBAL_VAR_TYPE_UVEC4 = 12
  GLOBAL_VAR_TYPE_FLOAT = 13
  GLOBAL_VAR_TYPE_VEC2 = 14
  GLOBAL_VAR_TYPE_VEC3 = 15
  GLOBAL_VAR_TYPE_VEC4 = 16
  GLOBAL_VAR_TYPE_COLOR = 17
  GLOBAL_VAR_TYPE_RECT2 = 18
  GLOBAL_VAR_TYPE_MAT2 = 19
  GLOBAL_VAR_TYPE_MAT3 = 20
  GLOBAL_VAR_TYPE_MAT4 = 21
  GLOBAL_VAR_TYPE_TRANSFORM_2D = 22
  GLOBAL_VAR_TYPE_TRANSFORM = 23
  GLOBAL_VAR_TYPE_SAMPLER2D = 24
  GLOBAL_VAR_TYPE_SAMPLER2DARRAY = 25
  GLOBAL_VAR_TYPE_SAMPLER3D = 26
  GLOBAL_VAR_TYPE_SAMPLERCUBE = 27
  GLOBAL_VAR_TYPE_SAMPLEREXT = 28
  GLOBAL_VAR_TYPE_MAX = 29
class RenderingInfo:
  RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME = 0
  RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME = 1
  RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME = 2
  RENDERING_INFO_TEXTURE_MEM_USED = 3
  RENDERING_INFO_BUFFER_MEM_USED = 4
  RENDERING_INFO_VIDEO_MEM_USED = 5
  RENDERING_INFO_PIPELINE_COMPILATIONS_CANVAS = 6
  RENDERING_INFO_PIPELINE_COMPILATIONS_MESH = 7
  RENDERING_INFO_PIPELINE_COMPILATIONS_SURFACE = 8
  RENDERING_INFO_PIPELINE_COMPILATIONS_DRAW = 9
  RENDERING_INFO_PIPELINE_COMPILATIONS_SPECIALIZATION = 10
class PipelineSource:
  PIPELINE_SOURCE_CANVAS = 0
  PIPELINE_SOURCE_MESH = 1
  PIPELINE_SOURCE_SURFACE = 2
  PIPELINE_SOURCE_DRAW = 3
  PIPELINE_SOURCE_SPECIALIZATION = 4
  PIPELINE_SOURCE_MAX = 5
class Features:
  FEATURE_SHADERS = 0
  FEATURE_MULTITHREADED = 1


class RenderingServer(py4godot_object.Object):
  r'''
		The rendering server is the API backend for everything visible. The whole scene system mounts on it to display. The rendering server is completely opaque: the internals are entirely implementation-specific and cannot be accessed.
		The rendering server can be used to bypass the scene/`Node` system entirely. This can improve performance in cases where the scene system is the bottleneck, but won't improve performance otherwise (for instance, if the GPU is already fully utilized).
		Resources are created using the `*_create` functions. These functions return `RID`s which are not references to the objects themselves, but opaque _pointers_ towards these objects.
		All objects are drawn to a viewport. You can use the `Viewport` attached to the `SceneTree` or you can create one yourself with `viewport_create`. When using a custom scenario or canvas, the scenario or canvas needs to be attached to the viewport using `viewport_set_scenario` or `viewport_attach_canvas`.
		**Scenarios:** In 3D, all visual objects must be associated with a scenario. The scenario is a visual representation of the world. If accessing the rendering server from a running game, the scenario can be accessed from the scene tree from any `Node3D` node with `Node3D.get_world_3d`. Otherwise, a scenario can be created with `scenario_create`.
		Similarly, in 2D, a canvas is needed to draw all canvas items.
		**3D:** In 3D, all visible objects are comprised of a resource and an instance. A resource can be a mesh, a particle system, a light, or any other 3D object. In order to be visible resources must be attached to an instance using `instance_set_base`. The instance must also be attached to the scenario using `instance_set_scenario` in order to be visible. RenderingServer methods that don't have a prefix are usually 3D-specific (but not always).
		**2D:** In 2D, all visible objects are some form of canvas item. In order to be visible, a canvas item needs to be the child of a canvas attached to a viewport, or it needs to be the child of another canvas item that is eventually attached to the canvas. 2D-specific RenderingServer methods generally start with `canvas_*`.
		**Headless mode:** Starting the engine with the `--headless` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url` disables all rendering and window management functions. Most functions from `RenderingServer` will return dummy values in this case.
	'''
  NO_INDEX_ARRAY:typing.ClassVar[int]

  ARRAY_WEIGHTS_SIZE:typing.ClassVar[int]

  CANVAS_ITEM_Z_MIN:typing.ClassVar[int]

  CANVAS_ITEM_Z_MAX:typing.ClassVar[int]

  CANVAS_LAYER_MIN:typing.ClassVar[int]

  CANVAS_LAYER_MAX:typing.ClassVar[int]

  MAX_GLOW_LEVELS:typing.ClassVar[int]

  MAX_CURSORS:typing.ClassVar[int]

  MAX_2D_DIRECTIONAL_LIGHTS:typing.ClassVar[int]

  MAX_MESH_SURFACES:typing.ClassVar[int]

  MATERIAL_RENDER_PRIORITY_MIN:typing.ClassVar[int]

  MATERIAL_RENDER_PRIORITY_MAX:typing.ClassVar[int]

  ARRAY_CUSTOM_COUNT:typing.ClassVar[int]

  PARTICLES_EMIT_FLAG_POSITION:typing.ClassVar[int]

  PARTICLES_EMIT_FLAG_ROTATION_SCALE:typing.ClassVar[int]

  PARTICLES_EMIT_FLAG_VELOCITY:typing.ClassVar[int]

  PARTICLES_EMIT_FLAG_COLOR:typing.ClassVar[int]

  PARTICLES_EMIT_FLAG_CUSTOM:typing.ClassVar[int]


  def generate_wrapper(self):
    return CPPRenderingServerWrapper()
  def init_signals(self):
    super().init_signals()
    frame_pre_draw_name = utils.py_string_to_string_name("frame_pre_draw")
    self.frame_pre_draw = signals.BuiltinSignal(self, frame_pre_draw_name)
    frame_post_draw_name = utils.py_string_to_string_name("frame_post_draw")
    self.frame_post_draw = signals.BuiltinSignal(self, frame_post_draw_name)

  @staticmethod
  def construct_without_init():
    cls = RenderingServer.__new__(RenderingServer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RenderingServer'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderingServer.construct_without_init()
    cls._ptr = CPPRenderingServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderingServer.construct_without_init()
    cls._ptr = CPPRenderingServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _RenderingServer_singleton_instance
    if _RenderingServer_singleton_instance is None:
      singleton = RenderingServer()
      singleton._ptr = constructor(684,0, ())
      _RenderingServer_singleton_instance = singleton
    return _RenderingServer_singleton_instance

  @property
  def render_loop_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_render_loop_enabled()
    return _ret
  @render_loop_enabled.setter
  def render_loop_enabled(self,  value:'bool'):
    self.set_render_loop_enabled(value)
  @functools.native_method
  def texture_2d_create(self, image:'py4godot_image.Image'   ) -> typing.Union['RID']:
    r'''
				Creates a 2-dimensional texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `Texture2D`.
				**Note:** Not to be confused with `RenderingDevice.texture_create`, which creates the graphics API's own texture type as opposed to the Godot-specific `Texture2D` resource.
			'''

    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([image._ptr]))
    return _ret


  @functools.native_method
  def texture_2d_layered_create(self, layers:'py4godot_imagetypedarray.ImageTypedArray'   , layered_type:'int'  ) -> typing.Union['RID']:
    r'''
				Creates a 2-dimensional layered texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_layered_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `TextureLayered`.
			'''

    assert isinstance(layers, get_class('ImageTypedArray')), 'layers must be ImageTypedArray'
    assert isinstance(layered_type, (int, float)), 'layered_type must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([layers._ptr, layered_type]))
    return _ret


  @functools.native_method
  def texture_3d_create(self, format:'int'  , width:'int'   , height:'int'   , depth:'int'   , mipmaps:'bool'   , data:'py4godot_imagetypedarray.ImageTypedArray'   ) -> typing.Union['RID']:
    r'''
				**Note:** The equivalent resource is `Texture3D`.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(depth, (int, float)), 'depth must be int or float'
    assert isinstance(mipmaps, bool), 'mipmaps must be bool'
    assert isinstance(data, get_class('ImageTypedArray')), 'data must be ImageTypedArray'











    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([format, width, height, depth, mipmaps, data._ptr]))
    return _ret


  @functools.native_method
  def texture_proxy_create(self, base:'RID'   ) -> typing.Union['RID']:
    r'''
				This method does nothing and always returns an invalid `RID`.
			'''

    assert(not base is None)
    assert isinstance(base, RID), 'base must be RID'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([base._ptr]))
    return _ret


  @functools.native_method
  def texture_create_from_native_handle(self, type:'int'  , format:'int'  , native_handle:'int'   , width:'int'   , height:'int'   , depth:'int'   , layers:'int' =1  , layered_type:'int'  =0) -> typing.Union['RID']:
    r'''
				Creates a texture based on a native handle that was created outside of Godot's renderer.
				**Note:** If using only the rendering device renderer, it's recommend to use `RenderingDevice.texture_create_from_extension` together with `RenderingServer.texture_rd_create`, rather than this method. It will give you much more control over the texture's format and usage.
			'''



    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(native_handle, (int, float)), 'native_handle must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(depth, (int, float)), 'depth must be int or float'
    assert isinstance(layers, (int, float)), 'layers must be int or float'
    assert isinstance(layered_type, (int, float)), 'layered_type must be int or float'













    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([type, format, native_handle, width, height, depth, layers, layered_type]))
    return _ret


  @functools.native_method
  def texture_2d_update(self, texture:'RID'   , image:'py4godot_image.Image'   , layer:'int'   ) -> None:
    r'''
				Updates the texture specified by the `texture` `RID` with the data in `image`. A `layer` must also be specified, which should be `0` when updating a single-layer texture (`Texture2D`).
				**Note:** The `image` must have the same width, height and format as the current `texture` data. Otherwise, an error will be printed and the original texture won't be modified. If you need to use different width, height or format, use `texture_replace` instead.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'
    assert isinstance(layer, (int, float)), 'layer must be int or float'








    self._ptr.call_with_return(54,tuple([texture._ptr, image._ptr, layer]))

  @functools.native_method
  def texture_3d_update(self, texture:'RID'   , data:'py4godot_imagetypedarray.ImageTypedArray'   ) -> None:
    r'''
				Updates the texture specified by the `texture` `RID`'s data with the data in `data`. All the texture's layers must be replaced at once.
				**Note:** The `texture` must have the same width, height, depth and format as the current texture data. Otherwise, an error will be printed and the original texture won't be modified. If you need to use different width, height, depth or format, use `texture_replace` instead.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(data, get_class('ImageTypedArray')), 'data must be ImageTypedArray'







    self._ptr.call_with_return(55,tuple([texture._ptr, data._ptr]))

  @functools.native_method
  def texture_proxy_update(self, texture:'RID'   , proxy_to:'RID'   ) -> None:
    r'''
				This method does nothing.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not proxy_to is None)
    assert isinstance(proxy_to, RID), 'proxy_to must be RID'







    self._ptr.call_with_return(56,tuple([texture._ptr, proxy_to._ptr]))

  @functools.native_method
  def texture_2d_placeholder_create(self) -> typing.Union['RID']:
    r'''
				Creates a placeholder for a 2-dimensional layered texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_layered_*` RenderingServer functions, although it does nothing when used. See also `texture_2d_layered_placeholder_create`.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `PlaceholderTexture2D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def texture_2d_layered_placeholder_create(self, layered_type:'int'  ) -> typing.Union['RID']:
    r'''
				Creates a placeholder for a 2-dimensional layered texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_layered_*` RenderingServer functions, although it does nothing when used. See also `texture_2d_placeholder_create`.
				**Note:** The equivalent resource is `PlaceholderTextureLayered`.
			'''

    assert isinstance(layered_type, (int, float)), 'layered_type must be int or float'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([layered_type]))
    return _ret


  @functools.native_method
  def texture_3d_placeholder_create(self) -> typing.Union['RID']:
    r'''
				Creates a placeholder for a 3-dimensional texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_3d_*` RenderingServer functions, although it does nothing when used.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `PlaceholderTexture3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([]))
    return _ret


  @functools.native_method
  def texture_2d_get(self, texture:'RID'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns an `Image` instance from the given `texture` `RID`.
				**Example:** Get the test texture from `get_test_texture` and apply it to a `Sprite2D` node:
				```gdscript
				var texture_rid = RenderingServer.get_test_texture()
				var texture = ImageTexture.create_from_image(RenderingServer.texture_2d_get(texture_rid))
				$Sprite2D.texture = texture
				```
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(60,tuple([texture._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def texture_2d_layer_get(self, texture:'RID'   , layer:'int'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns an `Image` instance from the given `texture` `RID` and `layer`.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(61,tuple([texture._ptr, layer]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def texture_3d_get(self, texture:'RID'   ) -> typing.Union['py4godot_imagetypedarray.ImageTypedArray']:
    r'''
				Returns 3D texture data as an array of `Image`s for the specified texture `RID`.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = py4godot_imagetypedarray.ImageTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([texture._ptr]))
    return _ret


  @functools.native_method
  def texture_replace(self, texture:'RID'   , by_texture:'RID'   ) -> None:
    r'''
				Replaces `texture`'s texture data by the texture specified by the `by_texture` RID, without changing `texture`'s RID.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not by_texture is None)
    assert isinstance(by_texture, RID), 'by_texture must be RID'







    self._ptr.call_with_return(63,tuple([texture._ptr, by_texture._ptr]))

  @functools.native_method
  def texture_set_size_override(self, texture:'RID'   , width:'int'   , height:'int'   ) -> None:
    r'''
'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'








    self._ptr.call_with_return(64,tuple([texture._ptr, width, height]))

  @functools.native_method
  def texture_set_path(self, texture:'RID'   , path:'str'   ) -> None:
    r'''
'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    self._ptr.call_with_return(65,tuple([texture._ptr, py_string_path._ptr]))

  @functools.native_method
  def texture_get_path(self, texture:'RID'   ) -> typing.Union[str]:
    r'''
'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([texture._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def texture_get_format(self, texture:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the format for the texture.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret:int
    _ret = self._ptr.call_with_return(67,tuple([texture._ptr]))
    return _ret


  @functools.native_method
  def texture_set_force_redraw_if_visible(self, texture:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(68,tuple([texture._ptr, enable]))

  @functools.native_method
  def texture_rd_create(self, rd_texture:'RID'   , layer_type:'int'  =0) -> typing.Union['RID']:
    r'''
				Creates a new texture object based on a texture created directly on the `RenderingDevice`. If the texture contains layers, `layer_type` is used to define the layer type.
			'''



    assert(not rd_texture is None)
    assert isinstance(rd_texture, RID), 'rd_texture must be RID'
    assert isinstance(layer_type, (int, float)), 'layer_type must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(69,tuple([rd_texture._ptr, layer_type]))
    return _ret


  @functools.native_method
  def texture_get_rd_texture(self, texture:'RID'   , srgb:'bool' =False  ) -> typing.Union['RID']:
    r'''
				Returns a texture `RID` that can be used with `RenderingDevice`.
				`srgb` should be `true` when the texture uses nonlinear sRGB encoding and `false` when the texture uses linear encoding.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(srgb, bool), 'srgb must be bool'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([texture._ptr, srgb]))
    return _ret


  @functools.native_method
  def texture_get_native_handle(self, texture:'RID'   , srgb:'bool' =False  ) -> typing.Union[int]:
    r'''
				Returns the internal graphics handle for this texture object. For use when communicating with third-party APIs mostly with GDExtension.
				`srgb` should be `true` when the texture uses nonlinear sRGB encoding and `false` when the texture uses linear encoding.
				**Note:** This function returns a `uint64_t` which internally maps to a `GLuint` (OpenGL) or `VkImage` (Vulkan).
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(srgb, bool), 'srgb must be bool'







    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([texture._ptr, srgb]))
    return _ret


  @functools.native_method
  def shader_create(self) -> typing.Union['RID']:
    r'''
				Creates an empty shader and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `shader_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `Shader`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([]))
    return _ret


  @functools.native_method
  def shader_set_code(self, shader:'RID'   , code:'str'   ) -> None:
    r'''
				Sets the shader's source code (which triggers recompilation after being changed).
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'





    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)

    self._ptr.call_with_return(73,tuple([shader._ptr, py_string_code._ptr]))

  @functools.native_method
  def shader_set_path_hint(self, shader:'RID'   , path:'str'   ) -> None:
    r'''
				Sets the path hint for the specified shader. This should generally match the `Shader` resource's `Resource.resource_path`.
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    self._ptr.call_with_return(74,tuple([shader._ptr, py_string_path._ptr]))

  @functools.native_method
  def shader_get_code(self, shader:'RID'   ) -> typing.Union[str]:
    r'''
				Returns a shader's source code as a string.
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([shader._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_shader_parameter_list(self, shader:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns the parameters of a shader.
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'






    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([shader._ptr]))
    return _ret


  @functools.native_method
  def shader_get_parameter_default(self, shader:'RID'   , name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the default value for the specified shader uniform. This is usually the value written in the shader source code.
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(77,tuple([shader._ptr, py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def shader_set_default_texture_parameter(self, shader:'RID'   , name:'object'   , texture:'RID'   , index:'int' =0  ) -> None:
    r'''
				Sets a shader's default texture. Overwrites the texture given by name.
				**Note:** If the sampler array is used use `index` to access the specified texture.
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)



    self._ptr.call_with_return(78,tuple([shader._ptr, py_stringname_name._ptr, texture._ptr, index]))

  @functools.native_method
  def shader_get_default_texture_parameter(self, shader:'RID'   , name:'object'   , index:'int' =0  ) -> typing.Union['RID']:
    r'''
				Returns a default texture from a shader searched by name.
				**Note:** If the sampler array is used use `index` to access the specified texture.
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(index, (int, float)), 'index must be int or float'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([shader._ptr, py_stringname_name._ptr, index]))
    return _ret


  @functools.native_method
  def material_create(self) -> typing.Union['RID']:
    r'''
				Creates an empty material and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `material_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `Material`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def material_set_shader(self, shader_material:'RID'   , shader:'RID'   ) -> None:
    r'''
				Sets a shader material's shader.
			'''

    assert(not shader_material is None)
    assert isinstance(shader_material, RID), 'shader_material must be RID'
    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'







    self._ptr.call_with_return(81,tuple([shader_material._ptr, shader._ptr]))

  @functools.native_method
  def material_set_param(self, material:'RID'   , parameter:'object'   , value:'object'   ) -> None:
    r'''
				Sets a material's parameter.
			'''

    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'
    





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)


    self._ptr.call_with_return(82,tuple([material._ptr, py_stringname_parameter._ptr, value]))

  @functools.native_method
  def material_get_param(self, material:'RID'   , parameter:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of a certain material's parameter.
			'''

    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)

    _ret = None
    _ret = self._ptr.call_with_return(83,tuple([material._ptr, py_stringname_parameter._ptr]))
    return _ret


  @functools.native_method
  def material_set_render_priority(self, material:'RID'   , priority:'int'   ) -> None:
    r'''
				Sets a material's render priority.
			'''

    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'
    assert isinstance(priority, (int, float)), 'priority must be int or float'







    self._ptr.call_with_return(84,tuple([material._ptr, priority]))

  @functools.native_method
  def material_set_next_pass(self, material:'RID'   , next_material:'RID'   ) -> None:
    r'''
				Sets an object's next material.
			'''

    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'
    assert(not next_material is None)
    assert isinstance(next_material, RID), 'next_material must be RID'







    self._ptr.call_with_return(85,tuple([material._ptr, next_material._ptr]))

  @functools.native_method
  def mesh_create_from_surfaces(self, surfaces:'py4godot_dictionarytypedarray.DictionaryTypedArray'   , blend_shape_count:'int' =0  ) -> typing.Union['RID']:
    r'''
'''

    assert isinstance(surfaces, get_class('DictionaryTypedArray')), 'surfaces must be DictionaryTypedArray'
    assert isinstance(blend_shape_count, (int, float)), 'blend_shape_count must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([surfaces._ptr, blend_shape_count]))
    return _ret


  @functools.native_method
  def mesh_create(self) -> typing.Union['RID']:
    r'''
				Creates a new mesh and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `mesh_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this mesh to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent resource is `Mesh`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def mesh_surface_get_format_offset(self, format:'int'   , vertex_count:'int'   , array_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the offset of a given attribute by `array_index` in the start of its respective buffer.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(vertex_count, (int, float)), 'vertex_count must be int or float'
    assert isinstance(array_index, (int, float)), 'array_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([format, vertex_count, array_index]))
    return _ret


  @functools.native_method
  def mesh_surface_get_format_vertex_stride(self, format:'int'   , vertex_count:'int'   ) -> typing.Union[int]:
    r'''
				Returns the stride of the vertex positions for a mesh with given `format`. Note importantly that vertex positions are stored consecutively and are not interleaved with the other attributes in the vertex buffer (normals and tangents).
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(vertex_count, (int, float)), 'vertex_count must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([format, vertex_count]))
    return _ret


  @functools.native_method
  def mesh_surface_get_format_normal_tangent_stride(self, format:'int'   , vertex_count:'int'   ) -> typing.Union[int]:
    r'''
				Returns the stride of the combined normals and tangents for a mesh with given `format`. Note importantly that, while normals and tangents are in the vertex buffer with vertices, they are only interleaved with each other and so have a different stride than vertex positions.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(vertex_count, (int, float)), 'vertex_count must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([format, vertex_count]))
    return _ret


  @functools.native_method
  def mesh_surface_get_format_attribute_stride(self, format:'int'   , vertex_count:'int'   ) -> typing.Union[int]:
    r'''
				Returns the stride of the attribute buffer for a mesh with given `format`.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(vertex_count, (int, float)), 'vertex_count must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([format, vertex_count]))
    return _ret


  @functools.native_method
  def mesh_surface_get_format_skin_stride(self, format:'int'   , vertex_count:'int'   ) -> typing.Union[int]:
    r'''
				Returns the stride of the skin buffer for a mesh with given `format`.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(vertex_count, (int, float)), 'vertex_count must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([format, vertex_count]))
    return _ret


  @functools.native_method
  def mesh_surface_get_format_index_stride(self, format:'int'   , vertex_count:'int'   ) -> typing.Union[int]:
    r'''
				Returns the stride of the index buffer for a mesh with the given `format`.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(vertex_count, (int, float)), 'vertex_count must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([format, vertex_count]))
    return _ret


  @functools.native_method
  def mesh_add_surface(self, mesh:'RID'   , surface:'Dictionary'   ) -> None:
    r'''
'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert(not surface is None)
    assert isinstance(surface, Dictionary), 'surface must be Dictionary'







    self._ptr.call_with_return(94,tuple([mesh._ptr, surface._ptr]))

  @functools.native_method
  def mesh_add_surface_from_arrays(self, mesh:'RID'   , primitive:'int'  , arrays:'Array'   , blend_shapes:'Array' = None  , lods:'Dictionary' = None  , compress_format:'int' =0  ) -> None:
    r'''
'''
    if blend_shapes is None:
      blend_shapes = Array.new0()
    if lods is None:
      lods = Dictionary.new0()

    if blend_shapes is None:
      blend_shapes = Array.new0()
    if lods is None:
      lods = Dictionary.new0()


    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(primitive, (int, float)), 'primitive must be int or float'
    assert(not arrays is None)
    assert isinstance(arrays, Array), 'arrays must be Array'
    assert isinstance(compress_format, (int, float)), 'compress_format must be int or float'











    self._ptr.call_with_return(95,tuple([mesh._ptr, primitive, arrays._ptr, blend_shapes._ptr, lods._ptr, compress_format]))

  @functools.native_method
  def mesh_get_blend_shape_count(self, mesh:'RID'   ) -> typing.Union[int]:
    r'''
				Returns a mesh's blend shape count.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([mesh._ptr]))
    return _ret


  @functools.native_method
  def mesh_set_blend_shape_mode(self, mesh:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets a mesh's blend shape mode.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(97,tuple([mesh._ptr, mode]))

  @functools.native_method
  def mesh_get_blend_shape_mode(self, mesh:'RID'   ) -> typing.Union[int]:
    r'''
				Returns a mesh's blend shape mode.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'






    _ret:int
    _ret = self._ptr.call_with_return(98,tuple([mesh._ptr]))
    return _ret


  @functools.native_method
  def mesh_surface_set_material(self, mesh:'RID'   , surface:'int'   , material:'RID'   ) -> None:
    r'''
				Sets a mesh's surface's material.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'








    self._ptr.call_with_return(99,tuple([mesh._ptr, surface, material._ptr]))

  @functools.native_method
  def mesh_surface_get_material(self, mesh:'RID'   , surface:'int'   ) -> typing.Union['RID']:
    r'''
				Returns a mesh's surface's material.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(100,tuple([mesh._ptr, surface]))
    return _ret


  @functools.native_method
  def mesh_get_surface(self, mesh:'RID'   , surface:'int'   ) -> typing.Union['Dictionary']:
    r'''
'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([mesh._ptr, surface]))
    return _ret


  @functools.native_method
  def mesh_surface_get_arrays(self, mesh:'RID'   , surface:'int'   ) -> typing.Union['Array']:
    r'''
				Returns a mesh's surface's buffer arrays.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(102,tuple([mesh._ptr, surface]))
    return _ret


  @functools.native_method
  def mesh_surface_get_blend_shape_arrays(self, mesh:'RID'   , surface:'int'   ) -> typing.Union['py4godot_arraytypedarray.ArrayTypedArray']:
    r'''
				Returns a mesh's surface's arrays for blend shapes.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'







    _ret = py4godot_arraytypedarray.ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([mesh._ptr, surface]))
    return _ret


  @functools.native_method
  def mesh_get_surface_count(self, mesh:'RID'   ) -> typing.Union[int]:
    r'''
				Returns a mesh's number of surfaces.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([mesh._ptr]))
    return _ret


  @functools.native_method
  def mesh_set_custom_aabb(self, mesh:'RID'   , aabb:'AABB'   ) -> None:
    r'''
				Sets a mesh's custom aabb.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    self._ptr.call_with_return(105,tuple([mesh._ptr, aabb._ptr]))

  @functools.native_method
  def mesh_get_custom_aabb(self, mesh:'RID'   ) -> typing.Union['AABB']:
    r'''
				Returns a mesh's custom aabb.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'






    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(106,tuple([mesh._ptr]))
    return _ret


  @functools.native_method
  def mesh_surface_remove(self, mesh:'RID'   , surface:'int'   ) -> None:
    r'''
				Removes the surface at the given index from the Mesh, shifting surfaces with higher index down by one.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'







    self._ptr.call_with_return(107,tuple([mesh._ptr, surface]))

  @functools.native_method
  def mesh_clear(self, mesh:'RID'   ) -> None:
    r'''
				Removes all surfaces from a mesh.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'






    self._ptr.call_with_return(108,tuple([mesh._ptr]))

  @functools.native_method
  def mesh_surface_update_vertex_region(self, mesh:'RID'   , surface:'int'   , offset:'int'   , data:'PackedByteArray'   ) -> None:
    r'''
'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    self._ptr.call_with_return(109,tuple([mesh._ptr, surface, offset, data._ptr]))

  @functools.native_method
  def mesh_surface_update_attribute_region(self, mesh:'RID'   , surface:'int'   , offset:'int'   , data:'PackedByteArray'   ) -> None:
    r'''
'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    self._ptr.call_with_return(110,tuple([mesh._ptr, surface, offset, data._ptr]))

  @functools.native_method
  def mesh_surface_update_skin_region(self, mesh:'RID'   , surface:'int'   , offset:'int'   , data:'PackedByteArray'   ) -> None:
    r'''
'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    self._ptr.call_with_return(111,tuple([mesh._ptr, surface, offset, data._ptr]))

  @functools.native_method
  def mesh_surface_update_index_region(self, mesh:'RID'   , surface:'int'   , offset:'int'   , data:'PackedByteArray'   ) -> None:
    r'''
				Updates the index buffer of the mesh surface with the given `data`. The expected data are 16 or 32-bit unsigned integers, which can be determined with `mesh_surface_get_format_index_stride`.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    self._ptr.call_with_return(112,tuple([mesh._ptr, surface, offset, data._ptr]))

  @functools.native_method
  def mesh_set_shadow_mesh(self, mesh:'RID'   , shadow_mesh:'RID'   ) -> None:
    r'''
'''

    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'
    assert(not shadow_mesh is None)
    assert isinstance(shadow_mesh, RID), 'shadow_mesh must be RID'







    self._ptr.call_with_return(113,tuple([mesh._ptr, shadow_mesh._ptr]))

  @functools.native_method
  def multimesh_create(self) -> typing.Union['RID']:
    r'''
				Creates a new multimesh on the RenderingServer and returns an `RID` handle. This RID will be used in all `multimesh_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this multimesh to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent resource is `MultiMesh`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(114,tuple([]))
    return _ret


  @functools.native_method
  def multimesh_allocate_data(self, multimesh:'RID'   , instances:'int'   , transform_format:'int'  , color_format:'bool' =False  , custom_data_format:'bool' =False  , use_indirect:'bool' =False  ) -> None:
    r'''
'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(instances, (int, float)), 'instances must be int or float'
    assert isinstance(transform_format, (int, float)), 'transform_format must be int or float'
    assert isinstance(color_format, bool), 'color_format must be bool'
    assert isinstance(custom_data_format, bool), 'custom_data_format must be bool'
    assert isinstance(use_indirect, bool), 'use_indirect must be bool'











    self._ptr.call_with_return(115,tuple([multimesh._ptr, instances, transform_format, color_format, custom_data_format, use_indirect]))

  @functools.native_method
  def multimesh_get_instance_count(self, multimesh:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the number of instances allocated for this multimesh.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(116,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_set_mesh(self, multimesh:'RID'   , mesh:'RID'   ) -> None:
    r'''
				Sets the mesh to be drawn by the multimesh. Equivalent to `MultiMesh.mesh`.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'







    self._ptr.call_with_return(117,tuple([multimesh._ptr, mesh._ptr]))

  @functools.native_method
  def multimesh_instance_set_transform(self, multimesh:'RID'   , index:'int'   , transform:'Transform3D'   ) -> None:
    r'''
				Sets the `Transform3D` for this instance. Equivalent to `MultiMesh.set_instance_transform`.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'








    self._ptr.call_with_return(118,tuple([multimesh._ptr, index, transform._ptr]))

  @functools.native_method
  def multimesh_instance_set_transform_2d(self, multimesh:'RID'   , index:'int'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets the `Transform2D` for this instance. For use when multimesh is used in 2D. Equivalent to `MultiMesh.set_instance_transform_2d`.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'








    self._ptr.call_with_return(119,tuple([multimesh._ptr, index, transform._ptr]))

  @functools.native_method
  def multimesh_instance_set_color(self, multimesh:'RID'   , index:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the color by which this instance will be modulated. Equivalent to `MultiMesh.set_instance_color`.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(120,tuple([multimesh._ptr, index, color._ptr]))

  @functools.native_method
  def multimesh_instance_set_custom_data(self, multimesh:'RID'   , index:'int'   , custom_data:'Color'   ) -> None:
    r'''
				Sets the custom data for this instance. Custom data is passed as a `Color`, but is interpreted as a `vec4` in the shader. Equivalent to `MultiMesh.set_instance_custom_data`.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not custom_data is None)
    assert isinstance(custom_data, Color), 'custom_data must be Color'








    self._ptr.call_with_return(121,tuple([multimesh._ptr, index, custom_data._ptr]))

  @functools.native_method
  def multimesh_get_mesh(self, multimesh:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns the RID of the mesh that will be used in drawing this multimesh.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(122,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_get_aabb(self, multimesh:'RID'   ) -> typing.Union['AABB']:
    r'''
				Calculates and returns the axis-aligned bounding box that encloses all instances within the multimesh.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(123,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_set_custom_aabb(self, multimesh:'RID'   , aabb:'AABB'   ) -> None:
    r'''
				Sets the custom AABB for this MultiMesh resource.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    self._ptr.call_with_return(124,tuple([multimesh._ptr, aabb._ptr]))

  @functools.native_method
  def multimesh_get_custom_aabb(self, multimesh:'RID'   ) -> typing.Union['AABB']:
    r'''
				Returns the custom AABB defined for this MultiMesh resource.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(125,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_instance_get_transform(self, multimesh:'RID'   , index:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the `Transform3D` of the specified instance.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(126,tuple([multimesh._ptr, index]))
    return _ret


  @functools.native_method
  def multimesh_instance_get_transform_2d(self, multimesh:'RID'   , index:'int'   ) -> typing.Union['Transform2D']:
    r'''
				Returns the `Transform2D` of the specified instance. For use when the multimesh is set to use 2D transforms.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(127,tuple([multimesh._ptr, index]))
    return _ret


  @functools.native_method
  def multimesh_instance_get_color(self, multimesh:'RID'   , index:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the color by which the specified instance will be modulated.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(128,tuple([multimesh._ptr, index]))
    return _ret


  @functools.native_method
  def multimesh_instance_get_custom_data(self, multimesh:'RID'   , index:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the custom data associated with the specified instance.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(129,tuple([multimesh._ptr, index]))
    return _ret


  @functools.native_method
  def multimesh_set_visible_instances(self, multimesh:'RID'   , visible:'int'   ) -> None:
    r'''
				Sets the number of instances visible at a given time. If -1, all instances that have been allocated are drawn. Equivalent to `MultiMesh.visible_instance_count`.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(visible, (int, float)), 'visible must be int or float'







    self._ptr.call_with_return(130,tuple([multimesh._ptr, visible]))

  @functools.native_method
  def multimesh_get_visible_instances(self, multimesh:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the number of visible instances for this multimesh.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(131,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_set_buffer(self, multimesh:'RID'   , buffer:'PackedFloat32Array'   ) -> None:
    r'''
				Set the entire data to use for drawing the `multimesh` at once to `buffer` (such as instance transforms and colors). `buffer`'s size must match the number of instances multiplied by the per-instance data size (which depends on the enabled MultiMesh fields). Otherwise, an error message is printed and nothing is rendered. See also `multimesh_get_buffer`.
				The per-instance data size and expected data order is:
				`codeblock lang=text`
				2D:
				  - Position: 8 floats (8 floats for Transform2D)
				  - Position + Vertex color: 12 floats (8 floats for Transform2D, 4 floats for Color)
				  - Position + Custom data: 12 floats (8 floats for Transform2D, 4 floats of custom data)
				  - Position + Vertex color + Custom data: 16 floats (8 floats for Transform2D, 4 floats for Color, 4 floats of custom data)
				3D:
				  - Position: 12 floats (12 floats for Transform3D)
				  - Position + Vertex color: 16 floats (12 floats for Transform3D, 4 floats for Color)
				  - Position + Custom data: 16 floats (12 floats for Transform3D, 4 floats of custom data)
				  - Position + Vertex color + Custom data: 20 floats (12 floats for Transform3D, 4 floats for Color, 4 floats of custom data)
				```
				Instance transforms are in row-major order. Specifically:
				- For `Transform2D` the float-order is: `(x.x, y.x, padding_float, origin.x, x.y, y.y, padding_float, origin.y)`.
				- For `Transform3D` the float-order is: `(basis.x.x, basis.y.x, basis.z.x, origin.x, basis.x.y, basis.y.y, basis.z.y, origin.y, basis.x.z, basis.y.z, basis.z.z, origin.z)`.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert(not buffer is None)
    assert isinstance(buffer, PackedFloat32Array), 'buffer must be PackedFloat32Array'







    self._ptr.call_with_return(132,tuple([multimesh._ptr, buffer._ptr]))

  @functools.native_method
  def multimesh_get_command_buffer_rd_rid(self, multimesh:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns the `RenderingDevice` `RID` handle of the `MultiMesh` command buffer. This `RID` is only valid if `use_indirect` is set to `true` when allocating data through `multimesh_allocate_data`. It can be used to directly modify the instance count via buffer.
				The data structure is dependent on both how many surfaces the mesh contains and whether it is indexed or not, the buffer has 5 integers in it, with the last unused if the mesh is not indexed.
				Each of the values in the buffer correspond to these options:
				`codeblock lang=text`
				Indexed:
				  0 - indexCount;
				  1 - instanceCount;
				  2 - firstIndex;
				  3 - vertexOffset;
				  4 - firstInstance;
				Non Indexed:
				  0 - vertexCount;
				  1 - instanceCount;
				  2 - firstVertex;
				  3 - firstInstance;
				  4 - unused;
				```
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(133,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_get_buffer_rd_rid(self, multimesh:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns the `RenderingDevice` `RID` handle of the `MultiMesh`, which can be used as any other buffer on the Rendering Device.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(134,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_get_buffer(self, multimesh:'RID'   ) -> typing.Union['PackedFloat32Array']:
    r'''
				Returns the MultiMesh data (such as instance transforms, colors, etc.). See `multimesh_set_buffer` for details on the returned data.
				**Note:** If the buffer is in the engine's internal cache, it will have to be fetched from GPU memory and possibly decompressed. This means `multimesh_get_buffer` is potentially a slow operation and should be avoided whenever possible.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'






    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(135,tuple([multimesh._ptr]))
    return _ret


  @functools.native_method
  def multimesh_set_buffer_interpolated(self, multimesh:'RID'   , buffer:'PackedFloat32Array'   , buffer_previous:'PackedFloat32Array'   ) -> None:
    r'''
				Alternative version of `multimesh_set_buffer` for use with physics interpolation.
				Takes both an array of current data and an array of data for the previous physics tick.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert(not buffer is None)
    assert isinstance(buffer, PackedFloat32Array), 'buffer must be PackedFloat32Array'
    assert(not buffer_previous is None)
    assert isinstance(buffer_previous, PackedFloat32Array), 'buffer_previous must be PackedFloat32Array'








    self._ptr.call_with_return(136,tuple([multimesh._ptr, buffer._ptr, buffer_previous._ptr]))

  @functools.native_method
  def multimesh_set_physics_interpolated(self, multimesh:'RID'   , interpolated:'bool'   ) -> None:
    r'''
				Turns on and off physics interpolation for this MultiMesh resource.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(interpolated, bool), 'interpolated must be bool'







    self._ptr.call_with_return(137,tuple([multimesh._ptr, interpolated]))

  @functools.native_method
  def multimesh_set_physics_interpolation_quality(self, multimesh:'RID'   , quality:'int'  ) -> None:
    r'''
				Sets the physics interpolation quality for the `MultiMesh`.
				A value of `constant MULTIMESH_INTERP_QUALITY_FAST` gives fast but low quality interpolation, a value of `constant MULTIMESH_INTERP_QUALITY_HIGH` gives slower but higher quality interpolation.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(quality, (int, float)), 'quality must be int or float'







    self._ptr.call_with_return(138,tuple([multimesh._ptr, quality]))

  @functools.native_method
  def multimesh_instance_reset_physics_interpolation(self, multimesh:'RID'   , index:'int'   ) -> None:
    r'''
				Prevents physics interpolation for the specified instance during the current physics tick.
				This is useful when moving an instance to a new location, to give an instantaneous change rather than interpolation from the previous location.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, RID), 'multimesh must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(139,tuple([multimesh._ptr, index]))

  @functools.native_method
  def skeleton_create(self) -> typing.Union['RID']:
    r'''
				Creates a skeleton and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `skeleton_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(140,tuple([]))
    return _ret


  @functools.native_method
  def skeleton_allocate_data(self, skeleton:'RID'   , bones:'int'   , is_2d_skeleton:'bool' =False  ) -> None:
    r'''
'''

    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'
    assert isinstance(bones, (int, float)), 'bones must be int or float'
    assert isinstance(is_2d_skeleton, bool), 'is_2d_skeleton must be bool'








    self._ptr.call_with_return(141,tuple([skeleton._ptr, bones, is_2d_skeleton]))

  @functools.native_method
  def skeleton_get_bone_count(self, skeleton:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the number of bones allocated for this skeleton.
			'''

    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(142,tuple([skeleton._ptr]))
    return _ret


  @functools.native_method
  def skeleton_bone_set_transform(self, skeleton:'RID'   , bone:'int'   , transform:'Transform3D'   ) -> None:
    r'''
				Sets the `Transform3D` for a specific bone of this skeleton.
			'''

    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'
    assert isinstance(bone, (int, float)), 'bone must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'








    self._ptr.call_with_return(143,tuple([skeleton._ptr, bone, transform._ptr]))

  @functools.native_method
  def skeleton_bone_get_transform(self, skeleton:'RID'   , bone:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the `Transform3D` set for a specific bone of this skeleton.
			'''

    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'
    assert isinstance(bone, (int, float)), 'bone must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(144,tuple([skeleton._ptr, bone]))
    return _ret


  @functools.native_method
  def skeleton_bone_set_transform_2d(self, skeleton:'RID'   , bone:'int'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets the `Transform2D` for a specific bone of this skeleton.
			'''

    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'
    assert isinstance(bone, (int, float)), 'bone must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'








    self._ptr.call_with_return(145,tuple([skeleton._ptr, bone, transform._ptr]))

  @functools.native_method
  def skeleton_bone_get_transform_2d(self, skeleton:'RID'   , bone:'int'   ) -> typing.Union['Transform2D']:
    r'''
				Returns the `Transform2D` set for a specific bone of this skeleton.
			'''

    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'
    assert isinstance(bone, (int, float)), 'bone must be int or float'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(146,tuple([skeleton._ptr, bone]))
    return _ret


  @functools.native_method
  def skeleton_set_base_transform_2d(self, skeleton:'RID'   , base_transform:'Transform2D'   ) -> None:
    r'''
'''

    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'
    assert(not base_transform is None)
    assert isinstance(base_transform, Transform2D), 'base_transform must be Transform2D'







    self._ptr.call_with_return(147,tuple([skeleton._ptr, base_transform._ptr]))

  @functools.native_method
  def directional_light_create(self) -> typing.Union['RID']:
    r'''
				Creates a directional light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `light_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this directional light to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent node is `DirectionalLight3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(148,tuple([]))
    return _ret


  @functools.native_method
  def omni_light_create(self) -> typing.Union['RID']:
    r'''
				Creates a new omni light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `light_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this omni light to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent node is `OmniLight3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(149,tuple([]))
    return _ret


  @functools.native_method
  def spot_light_create(self) -> typing.Union['RID']:
    r'''
				Creates a spot light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `light_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this spot light to an instance using `instance_set_base` using the returned RID.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(150,tuple([]))
    return _ret


  @functools.native_method
  def light_set_color(self, light:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets the color of the light. Equivalent to `Light3D.light_color`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(151,tuple([light._ptr, color._ptr]))

  @functools.native_method
  def light_set_param(self, light:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
				Sets the specified 3D light parameter. Equivalent to `Light3D.set_param`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(152,tuple([light._ptr, param, value]))

  @functools.native_method
  def light_set_shadow(self, light:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, light will cast shadows. Equivalent to `Light3D.shadow_enabled`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(153,tuple([light._ptr, enabled]))

  @functools.native_method
  def light_set_projector(self, light:'RID'   , texture:'RID'   ) -> None:
    r'''
				Sets the projector texture to use for the specified 3D light. Equivalent to `Light3D.light_projector`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'







    self._ptr.call_with_return(154,tuple([light._ptr, texture._ptr]))

  @functools.native_method
  def light_set_negative(self, light:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, the 3D light will subtract light instead of adding light. Equivalent to `Light3D.light_negative`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(155,tuple([light._ptr, enable]))

  @functools.native_method
  def light_set_cull_mask(self, light:'RID'   , mask:'int'   ) -> None:
    r'''
				Sets the cull mask for this 3D light. Lights only affect objects in the selected layers. Equivalent to `Light3D.light_cull_mask`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(156,tuple([light._ptr, mask]))

  @functools.native_method
  def light_set_distance_fade(self, decal:'RID'   , enabled:'bool'   , begin:'float'   , shadow:'float'   , length:'float'   ) -> None:
    r'''
				Sets the distance fade for this 3D light. This acts as a form of level of detail (LOD) and can be used to improve performance. Equivalent to `Light3D.distance_fade_enabled`, `Light3D.distance_fade_begin`, `Light3D.distance_fade_shadow`, and `Light3D.distance_fade_length`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'
    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(shadow, (int, float)), 'shadow must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'










    self._ptr.call_with_return(157,tuple([decal._ptr, enabled, begin, shadow, length]))

  @functools.native_method
  def light_set_reverse_cull_face_mode(self, light:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, reverses the backface culling of the mesh. This can be useful when you have a flat mesh that has a light behind it. If you need to cast a shadow on both sides of the mesh, set the mesh to use double-sided shadows with `instance_geometry_set_cast_shadows_setting`. Equivalent to `Light3D.shadow_reverse_cull_face`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(158,tuple([light._ptr, enabled]))

  @functools.native_method
  def light_set_shadow_caster_mask(self, light:'RID'   , mask:'int'   ) -> None:
    r'''
				Sets the shadow caster mask for this 3D light. Shadows will only be cast using objects in the selected layers. Equivalent to `Light3D.shadow_caster_mask`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(159,tuple([light._ptr, mask]))

  @functools.native_method
  def light_set_bake_mode(self, light:'RID'   , bake_mode:'int'  ) -> None:
    r'''
				Sets the bake mode to use for the specified 3D light. Equivalent to `Light3D.light_bake_mode`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(bake_mode, (int, float)), 'bake_mode must be int or float'







    self._ptr.call_with_return(160,tuple([light._ptr, bake_mode]))

  @functools.native_method
  def light_set_max_sdfgi_cascade(self, light:'RID'   , cascade:'int'   ) -> None:
    r'''
				Sets the maximum SDFGI cascade in which the 3D light's indirect lighting is rendered. Higher values allow the light to be rendered in SDFGI further away from the camera.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(cascade, (int, float)), 'cascade must be int or float'







    self._ptr.call_with_return(161,tuple([light._ptr, cascade]))

  @functools.native_method
  def light_omni_set_shadow_mode(self, light:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets whether to use a dual paraboloid or a cubemap for the shadow map. Dual paraboloid is faster but may suffer from artifacts. Equivalent to `OmniLight3D.omni_shadow_mode`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(162,tuple([light._ptr, mode]))

  @functools.native_method
  def light_directional_set_shadow_mode(self, light:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the shadow mode for this directional light. Equivalent to `DirectionalLight3D.directional_shadow_mode`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(163,tuple([light._ptr, mode]))

  @functools.native_method
  def light_directional_set_blend_splits(self, light:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, this directional light will blend between shadow map splits resulting in a smoother transition between them. Equivalent to `DirectionalLight3D.directional_shadow_blend_splits`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(164,tuple([light._ptr, enable]))

  @functools.native_method
  def light_directional_set_sky_mode(self, light:'RID'   , mode:'int'  ) -> None:
    r'''
				If `true`, this light will not be used for anything except sky shaders. Use this for lights that impact your sky shader that you may want to hide from affecting the rest of the scene. For example, you may want to enable this when the sun in your sky shader falls below the horizon.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(165,tuple([light._ptr, mode]))

  @functools.native_method
  def light_projectors_set_filter(self, filter:'int'  ) -> None:
    r'''
				Sets the texture filter mode to use when rendering light projectors. This parameter is global and cannot be set on a per-light basis.
			'''

    assert isinstance(filter, (int, float)), 'filter must be int or float'






    self._ptr.call_with_return(166,tuple([filter]))

  @functools.native_method
  def lightmaps_set_bicubic_filter(self, enable:'bool'   ) -> None:
    r'''
				Toggles whether a bicubic filter should be used when lightmaps are sampled. This smoothens their appearance at a performance cost.
			'''

    assert isinstance(enable, bool), 'enable must be bool'






    self._ptr.call_with_return(167,tuple([enable]))

  @functools.native_method
  def positional_soft_shadow_filter_set_quality(self, quality:'int'  ) -> None:
    r'''
				Sets the filter quality for omni and spot light shadows in 3D. See also `ProjectSettings.rendering/lights_and_shadows/positional_shadow/soft_shadow_filter_quality`. This parameter is global and cannot be set on a per-viewport basis.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'






    self._ptr.call_with_return(168,tuple([quality]))

  @functools.native_method
  def directional_soft_shadow_filter_set_quality(self, quality:'int'  ) -> None:
    r'''
				Sets the filter `quality` for directional light shadows in 3D. See also `ProjectSettings.rendering/lights_and_shadows/directional_shadow/soft_shadow_filter_quality`. This parameter is global and cannot be set on a per-viewport basis.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'






    self._ptr.call_with_return(169,tuple([quality]))

  @functools.native_method
  def directional_shadow_atlas_set_size(self, size:'int'   , is_16bits:'bool'   ) -> None:
    r'''
				Sets the `size` of the directional light shadows in 3D. See also `ProjectSettings.rendering/lights_and_shadows/directional_shadow/size`. This parameter is global and cannot be set on a per-viewport basis.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(is_16bits, bool), 'is_16bits must be bool'







    self._ptr.call_with_return(170,tuple([size, is_16bits]))

  @functools.native_method
  def reflection_probe_create(self) -> typing.Union['RID']:
    r'''
				Creates a reflection probe and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `reflection_probe_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this reflection probe to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent node is `ReflectionProbe`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(171,tuple([]))
    return _ret


  @functools.native_method
  def reflection_probe_set_update_mode(self, probe:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets how often the reflection probe updates. Can either be once or every frame.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(172,tuple([probe._ptr, mode]))

  @functools.native_method
  def reflection_probe_set_intensity(self, probe:'RID'   , intensity:'float'   ) -> None:
    r'''
				Sets the intensity of the reflection probe. Intensity modulates the strength of the reflection. Equivalent to `ReflectionProbe.intensity`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(intensity, (int, float)), 'intensity must be int or float'







    self._ptr.call_with_return(173,tuple([probe._ptr, intensity]))

  @functools.native_method
  def reflection_probe_set_blend_distance(self, probe:'RID'   , blend_distance:'float'   ) -> None:
    r'''
				Sets the distance in meters over which a probe blends into the scene.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(blend_distance, (int, float)), 'blend_distance must be int or float'







    self._ptr.call_with_return(174,tuple([probe._ptr, blend_distance]))

  @functools.native_method
  def reflection_probe_set_ambient_mode(self, probe:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the reflection probe's ambient light mode. Equivalent to `ReflectionProbe.ambient_mode`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(175,tuple([probe._ptr, mode]))

  @functools.native_method
  def reflection_probe_set_ambient_color(self, probe:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets the reflection probe's custom ambient light color. Equivalent to `ReflectionProbe.ambient_color`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(176,tuple([probe._ptr, color._ptr]))

  @functools.native_method
  def reflection_probe_set_ambient_energy(self, probe:'RID'   , energy:'float'   ) -> None:
    r'''
				Sets the reflection probe's custom ambient light energy. Equivalent to `ReflectionProbe.ambient_color_energy`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(energy, (int, float)), 'energy must be int or float'







    self._ptr.call_with_return(177,tuple([probe._ptr, energy]))

  @functools.native_method
  def reflection_probe_set_max_distance(self, probe:'RID'   , distance:'float'   ) -> None:
    r'''
				Sets the max distance away from the probe an object can be before it is culled. Equivalent to `ReflectionProbe.max_distance`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(distance, (int, float)), 'distance must be int or float'







    self._ptr.call_with_return(178,tuple([probe._ptr, distance]))

  @functools.native_method
  def reflection_probe_set_size(self, probe:'RID'   , size:'Vector3'   ) -> None:
    r'''
				Sets the size of the area that the reflection probe will capture. Equivalent to `ReflectionProbe.size`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'







    self._ptr.call_with_return(179,tuple([probe._ptr, size._ptr]))

  @functools.native_method
  def reflection_probe_set_origin_offset(self, probe:'RID'   , offset:'Vector3'   ) -> None:
    r'''
				Sets the origin offset to be used when this reflection probe is in box project mode. Equivalent to `ReflectionProbe.origin_offset`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'







    self._ptr.call_with_return(180,tuple([probe._ptr, offset._ptr]))

  @functools.native_method
  def reflection_probe_set_as_interior(self, probe:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, reflections will ignore sky contribution. Equivalent to `ReflectionProbe.interior`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(181,tuple([probe._ptr, enable]))

  @functools.native_method
  def reflection_probe_set_enable_box_projection(self, probe:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, uses box projection. This can make reflections look more correct in certain situations. Equivalent to `ReflectionProbe.box_projection`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(182,tuple([probe._ptr, enable]))

  @functools.native_method
  def reflection_probe_set_enable_shadows(self, probe:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, computes shadows in the reflection probe. This makes the reflection much slower to compute. Equivalent to `ReflectionProbe.enable_shadows`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(183,tuple([probe._ptr, enable]))

  @functools.native_method
  def reflection_probe_set_cull_mask(self, probe:'RID'   , layers:'int'   ) -> None:
    r'''
				Sets the render cull mask for this reflection probe. Only instances with a matching layer will be reflected by this probe. Equivalent to `ReflectionProbe.cull_mask`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(layers, (int, float)), 'layers must be int or float'







    self._ptr.call_with_return(184,tuple([probe._ptr, layers]))

  @functools.native_method
  def reflection_probe_set_reflection_mask(self, probe:'RID'   , layers:'int'   ) -> None:
    r'''
				Sets the render reflection mask for this reflection probe. Only instances with a matching layer will have reflections applied from this probe. Equivalent to `ReflectionProbe.reflection_mask`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(layers, (int, float)), 'layers must be int or float'







    self._ptr.call_with_return(185,tuple([probe._ptr, layers]))

  @functools.native_method
  def reflection_probe_set_resolution(self, probe:'RID'   , resolution:'int'   ) -> None:
    r'''
				Deprecated. This method does nothing.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(resolution, (int, float)), 'resolution must be int or float'







    self._ptr.call_with_return(186,tuple([probe._ptr, resolution]))

  @functools.native_method
  def reflection_probe_set_mesh_lod_threshold(self, probe:'RID'   , pixels:'float'   ) -> None:
    r'''
				Sets the mesh level of detail to use in the reflection probe rendering. Higher values will use less detailed versions of meshes that have LOD variations generated, which can improve performance. Equivalent to `ReflectionProbe.mesh_lod_threshold`.
			'''

    assert(not probe is None)
    assert isinstance(probe, RID), 'probe must be RID'
    assert isinstance(pixels, (int, float)), 'pixels must be int or float'







    self._ptr.call_with_return(187,tuple([probe._ptr, pixels]))

  @functools.native_method
  def decal_create(self) -> typing.Union['RID']:
    r'''
				Creates a decal and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `decal_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this decal to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent node is `Decal`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(188,tuple([]))
    return _ret


  @functools.native_method
  def decal_set_size(self, decal:'RID'   , size:'Vector3'   ) -> None:
    r'''
				Sets the `size` of the decal specified by the `decal` RID. Equivalent to `Decal.size`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'







    self._ptr.call_with_return(189,tuple([decal._ptr, size._ptr]))

  @functools.native_method
  def decal_set_texture(self, decal:'RID'   , type:'int'  , texture:'RID'   ) -> None:
    r'''
				Sets the `texture` in the given texture `type` slot for the specified decal. Equivalent to `Decal.set_texture`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'








    self._ptr.call_with_return(190,tuple([decal._ptr, type, texture._ptr]))

  @functools.native_method
  def decal_set_emission_energy(self, decal:'RID'   , energy:'float'   ) -> None:
    r'''
				Sets the emission `energy` in the decal specified by the `decal` RID. Equivalent to `Decal.emission_energy`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(energy, (int, float)), 'energy must be int or float'







    self._ptr.call_with_return(191,tuple([decal._ptr, energy]))

  @functools.native_method
  def decal_set_albedo_mix(self, decal:'RID'   , albedo_mix:'float'   ) -> None:
    r'''
				Sets the `albedo_mix` in the decal specified by the `decal` RID. Equivalent to `Decal.albedo_mix`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(albedo_mix, (int, float)), 'albedo_mix must be int or float'







    self._ptr.call_with_return(192,tuple([decal._ptr, albedo_mix]))

  @functools.native_method
  def decal_set_modulate(self, decal:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets the color multiplier in the decal specified by the `decal` RID to `color`. Equivalent to `Decal.modulate`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(193,tuple([decal._ptr, color._ptr]))

  @functools.native_method
  def decal_set_cull_mask(self, decal:'RID'   , mask:'int'   ) -> None:
    r'''
				Sets the cull `mask` in the decal specified by the `decal` RID. Equivalent to `Decal.cull_mask`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(194,tuple([decal._ptr, mask]))

  @functools.native_method
  def decal_set_distance_fade(self, decal:'RID'   , enabled:'bool'   , begin:'float'   , length:'float'   ) -> None:
    r'''
				Sets the distance fade parameters in the decal specified by the `decal` RID. Equivalent to `Decal.distance_fade_enabled`, `Decal.distance_fade_begin` and `Decal.distance_fade_length`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'
    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'









    self._ptr.call_with_return(195,tuple([decal._ptr, enabled, begin, length]))

  @functools.native_method
  def decal_set_fade(self, decal:'RID'   , above:'float'   , below:'float'   ) -> None:
    r'''
				Sets the upper fade (`above`) and lower fade (`below`) in the decal specified by the `decal` RID. Equivalent to `Decal.upper_fade` and `Decal.lower_fade`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(above, (int, float)), 'above must be int or float'
    assert isinstance(below, (int, float)), 'below must be int or float'








    self._ptr.call_with_return(196,tuple([decal._ptr, above, below]))

  @functools.native_method
  def decal_set_normal_fade(self, decal:'RID'   , fade:'float'   ) -> None:
    r'''
				Sets the normal `fade` in the decal specified by the `decal` RID. Equivalent to `Decal.normal_fade`.
			'''

    assert(not decal is None)
    assert isinstance(decal, RID), 'decal must be RID'
    assert isinstance(fade, (int, float)), 'fade must be int or float'







    self._ptr.call_with_return(197,tuple([decal._ptr, fade]))

  @functools.native_method
  def decals_set_filter(self, filter:'int'  ) -> None:
    r'''
				Sets the texture `filter` mode to use when rendering decals. This parameter is global and cannot be set on a per-decal basis.
			'''

    assert isinstance(filter, (int, float)), 'filter must be int or float'






    self._ptr.call_with_return(198,tuple([filter]))

  @functools.native_method
  def gi_set_use_half_resolution(self, half_resolution:'bool'   ) -> None:
    r'''
				If `half_resolution` is `true`, renders `VoxelGI` and SDFGI (`Environment.sdfgi_enabled`) buffers at halved resolution on each axis (e.g. 960×540 when the viewport size is 1920×1080). This improves performance significantly when VoxelGI or SDFGI is enabled, at the cost of artifacts that may be visible on polygon edges. The loss in quality becomes less noticeable as the viewport resolution increases. `LightmapGI` rendering is not affected by this setting. Equivalent to `ProjectSettings.rendering/global_illumination/gi/use_half_resolution`.
			'''

    assert isinstance(half_resolution, bool), 'half_resolution must be bool'






    self._ptr.call_with_return(199,tuple([half_resolution]))

  @functools.native_method
  def voxel_gi_create(self) -> typing.Union['RID']:
    r'''
				Creates a new voxel-based global illumination object and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `voxel_gi_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `VoxelGI`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(200,tuple([]))
    return _ret


  @functools.native_method
  def voxel_gi_allocate_data(self, voxel_gi:'RID'   , to_cell_xform:'Transform3D'   , aabb:'AABB'   , octree_size:'Vector3i'   , octree_cells:'PackedByteArray'   , data_cells:'PackedByteArray'   , distance_field:'PackedByteArray'   , level_counts:'PackedInt32Array'   ) -> None:
    r'''
'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert(not to_cell_xform is None)
    assert isinstance(to_cell_xform, Transform3D), 'to_cell_xform must be Transform3D'
    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'
    assert(not octree_size is None)
    assert isinstance(octree_size, Vector3i), 'octree_size must be Vector3i'
    assert(not octree_cells is None)
    assert isinstance(octree_cells, PackedByteArray), 'octree_cells must be PackedByteArray'
    assert(not data_cells is None)
    assert isinstance(data_cells, PackedByteArray), 'data_cells must be PackedByteArray'
    assert(not distance_field is None)
    assert isinstance(distance_field, PackedByteArray), 'distance_field must be PackedByteArray'
    assert(not level_counts is None)
    assert isinstance(level_counts, PackedInt32Array), 'level_counts must be PackedInt32Array'













    self._ptr.call_with_return(201,tuple([voxel_gi._ptr, to_cell_xform._ptr, aabb._ptr, octree_size._ptr, octree_cells._ptr, data_cells._ptr, distance_field._ptr, level_counts._ptr]))

  @functools.native_method
  def voxel_gi_get_octree_size(self, voxel_gi:'RID'   ) -> typing.Union['Vector3i']:
    r'''
'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'






    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(202,tuple([voxel_gi._ptr]))
    return _ret


  @functools.native_method
  def voxel_gi_get_octree_cells(self, voxel_gi:'RID'   ) -> typing.Union['PackedByteArray']:
    r'''
'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'






    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(203,tuple([voxel_gi._ptr]))
    return _ret


  @functools.native_method
  def voxel_gi_get_data_cells(self, voxel_gi:'RID'   ) -> typing.Union['PackedByteArray']:
    r'''
'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'






    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(204,tuple([voxel_gi._ptr]))
    return _ret


  @functools.native_method
  def voxel_gi_get_distance_field(self, voxel_gi:'RID'   ) -> typing.Union['PackedByteArray']:
    r'''
'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'






    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(205,tuple([voxel_gi._ptr]))
    return _ret


  @functools.native_method
  def voxel_gi_get_level_counts(self, voxel_gi:'RID'   ) -> typing.Union['PackedInt32Array']:
    r'''
'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'






    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(206,tuple([voxel_gi._ptr]))
    return _ret


  @functools.native_method
  def voxel_gi_get_to_cell_xform(self, voxel_gi:'RID'   ) -> typing.Union['Transform3D']:
    r'''
'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'






    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(207,tuple([voxel_gi._ptr]))
    return _ret


  @functools.native_method
  def voxel_gi_set_dynamic_range(self, voxel_gi:'RID'   , range:'float'   ) -> None:
    r'''
				Sets the `VoxelGIData.dynamic_range` value to use on the specified `voxel_gi`'s `RID`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(range, (int, float)), 'range must be int or float'







    self._ptr.call_with_return(208,tuple([voxel_gi._ptr, range]))

  @functools.native_method
  def voxel_gi_set_propagation(self, voxel_gi:'RID'   , amount:'float'   ) -> None:
    r'''
				Sets the `VoxelGIData.propagation` value to use on the specified `voxel_gi`'s `RID`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(amount, (int, float)), 'amount must be int or float'







    self._ptr.call_with_return(209,tuple([voxel_gi._ptr, amount]))

  @functools.native_method
  def voxel_gi_set_energy(self, voxel_gi:'RID'   , energy:'float'   ) -> None:
    r'''
				Sets the `VoxelGIData.energy` value to use on the specified `voxel_gi`'s `RID`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(energy, (int, float)), 'energy must be int or float'







    self._ptr.call_with_return(210,tuple([voxel_gi._ptr, energy]))

  @functools.native_method
  def voxel_gi_set_baked_exposure_normalization(self, voxel_gi:'RID'   , baked_exposure:'float'   ) -> None:
    r'''
				Used to inform the renderer what exposure normalization value was used while baking the voxel gi. This value will be used and modulated at run time to ensure that the voxel gi maintains a consistent level of exposure even if the scene-wide exposure normalization is changed at run time. For more information see `camera_attributes_set_exposure`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(baked_exposure, (int, float)), 'baked_exposure must be int or float'







    self._ptr.call_with_return(211,tuple([voxel_gi._ptr, baked_exposure]))

  @functools.native_method
  def voxel_gi_set_bias(self, voxel_gi:'RID'   , bias:'float'   ) -> None:
    r'''
				Sets the `VoxelGIData.bias` value to use on the specified `voxel_gi`'s `RID`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(bias, (int, float)), 'bias must be int or float'







    self._ptr.call_with_return(212,tuple([voxel_gi._ptr, bias]))

  @functools.native_method
  def voxel_gi_set_normal_bias(self, voxel_gi:'RID'   , bias:'float'   ) -> None:
    r'''
				Sets the `VoxelGIData.normal_bias` value to use on the specified `voxel_gi`'s `RID`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(bias, (int, float)), 'bias must be int or float'







    self._ptr.call_with_return(213,tuple([voxel_gi._ptr, bias]))

  @functools.native_method
  def voxel_gi_set_interior(self, voxel_gi:'RID'   , enable:'bool'   ) -> None:
    r'''
				Sets the `VoxelGIData.interior` value to use on the specified `voxel_gi`'s `RID`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(214,tuple([voxel_gi._ptr, enable]))

  @functools.native_method
  def voxel_gi_set_use_two_bounces(self, voxel_gi:'RID'   , enable:'bool'   ) -> None:
    r'''
				Sets the `VoxelGIData.use_two_bounces` value to use on the specified `voxel_gi`'s `RID`.
			'''

    assert(not voxel_gi is None)
    assert isinstance(voxel_gi, RID), 'voxel_gi must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(215,tuple([voxel_gi._ptr, enable]))

  @functools.native_method
  def voxel_gi_set_quality(self, quality:'int'  ) -> None:
    r'''
				Sets the `ProjectSettings.rendering/global_illumination/voxel_gi/quality` value to use when rendering. This parameter is global and cannot be set on a per-VoxelGI basis.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'






    self._ptr.call_with_return(216,tuple([quality]))

  @functools.native_method
  def lightmap_create(self) -> typing.Union['RID']:
    r'''
				Creates a new lightmap global illumination instance and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `lightmap_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `LightmapGI`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(217,tuple([]))
    return _ret


  @functools.native_method
  def lightmap_set_textures(self, lightmap:'RID'   , light:'RID'   , uses_sh:'bool'   ) -> None:
    r'''
				Set the textures on the given `lightmap` GI instance to the texture array pointed to by the `light` RID. If the lightmap texture was baked with `LightmapGI.directional` set to `true`, then `uses_sh` must also be `true`.
			'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'
    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(uses_sh, bool), 'uses_sh must be bool'








    self._ptr.call_with_return(218,tuple([lightmap._ptr, light._ptr, uses_sh]))

  @functools.native_method
  def lightmap_set_probe_bounds(self, lightmap:'RID'   , bounds:'AABB'   ) -> None:
    r'''
'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'
    assert(not bounds is None)
    assert isinstance(bounds, AABB), 'bounds must be AABB'







    self._ptr.call_with_return(219,tuple([lightmap._ptr, bounds._ptr]))

  @functools.native_method
  def lightmap_set_probe_interior(self, lightmap:'RID'   , interior:'bool'   ) -> None:
    r'''
'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'
    assert isinstance(interior, bool), 'interior must be bool'







    self._ptr.call_with_return(220,tuple([lightmap._ptr, interior]))

  @functools.native_method
  def lightmap_set_probe_capture_data(self, lightmap:'RID'   , points:'PackedVector3Array'   , point_sh:'PackedColorArray'   , tetrahedra:'PackedInt32Array'   , bsp_tree:'PackedInt32Array'   ) -> None:
    r'''
'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'
    assert(not points is None)
    assert isinstance(points, PackedVector3Array), 'points must be PackedVector3Array'
    assert(not point_sh is None)
    assert isinstance(point_sh, PackedColorArray), 'point_sh must be PackedColorArray'
    assert(not tetrahedra is None)
    assert isinstance(tetrahedra, PackedInt32Array), 'tetrahedra must be PackedInt32Array'
    assert(not bsp_tree is None)
    assert isinstance(bsp_tree, PackedInt32Array), 'bsp_tree must be PackedInt32Array'










    self._ptr.call_with_return(221,tuple([lightmap._ptr, points._ptr, point_sh._ptr, tetrahedra._ptr, bsp_tree._ptr]))

  @functools.native_method
  def lightmap_get_probe_capture_points(self, lightmap:'RID'   ) -> typing.Union['PackedVector3Array']:
    r'''
'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'






    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(222,tuple([lightmap._ptr]))
    return _ret


  @functools.native_method
  def lightmap_get_probe_capture_sh(self, lightmap:'RID'   ) -> typing.Union['PackedColorArray']:
    r'''
'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'






    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(223,tuple([lightmap._ptr]))
    return _ret


  @functools.native_method
  def lightmap_get_probe_capture_tetrahedra(self, lightmap:'RID'   ) -> typing.Union['PackedInt32Array']:
    r'''
'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'






    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(224,tuple([lightmap._ptr]))
    return _ret


  @functools.native_method
  def lightmap_get_probe_capture_bsp_tree(self, lightmap:'RID'   ) -> typing.Union['PackedInt32Array']:
    r'''
'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'






    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(225,tuple([lightmap._ptr]))
    return _ret


  @functools.native_method
  def lightmap_set_baked_exposure_normalization(self, lightmap:'RID'   , baked_exposure:'float'   ) -> None:
    r'''
				Used to inform the renderer what exposure normalization value was used while baking the lightmap. This value will be used and modulated at run time to ensure that the lightmap maintains a consistent level of exposure even if the scene-wide exposure normalization is changed at run time. For more information see `camera_attributes_set_exposure`.
			'''

    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'
    assert isinstance(baked_exposure, (int, float)), 'baked_exposure must be int or float'







    self._ptr.call_with_return(226,tuple([lightmap._ptr, baked_exposure]))

  @functools.native_method
  def lightmap_set_probe_capture_update_speed(self, speed:'float'   ) -> None:
    r'''
'''

    assert isinstance(speed, (int, float)), 'speed must be int or float'






    self._ptr.call_with_return(227,tuple([speed]))

  @functools.native_method
  def particles_create(self) -> typing.Union['RID']:
    r'''
				Creates a GPU-based particle system and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `particles_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach these particles to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent nodes are `GPUParticles2D` and `GPUParticles3D`.
				**Note:** All `particles_*` methods only apply to GPU-based particles, not CPU-based particles. `CPUParticles2D` and `CPUParticles3D` do not have equivalent RenderingServer functions available, as these use `MultiMeshInstance2D` and `MultiMeshInstance3D` under the hood (see `multimesh_*` methods).
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(228,tuple([]))
    return _ret


  @functools.native_method
  def particles_set_mode(self, particles:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets whether the GPU particles specified by the `particles` RID should be rendered in 2D or 3D according to `mode`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(229,tuple([particles._ptr, mode]))

  @functools.native_method
  def particles_set_emitting(self, particles:'RID'   , emitting:'bool'   ) -> None:
    r'''
				If `true`, particles will emit over time. Setting to `false` does not reset the particles, but only stops their emission. Equivalent to `GPUParticles3D.emitting`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(emitting, bool), 'emitting must be bool'







    self._ptr.call_with_return(230,tuple([particles._ptr, emitting]))

  @functools.native_method
  def particles_get_emitting(self, particles:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if particles are currently set to emitting.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(231,tuple([particles._ptr]))
    return _ret


  @functools.native_method
  def particles_set_amount(self, particles:'RID'   , amount:'int'   ) -> None:
    r'''
				Sets the number of particles to be drawn and allocates the memory for them. Equivalent to `GPUParticles3D.amount`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(amount, (int, float)), 'amount must be int or float'







    self._ptr.call_with_return(232,tuple([particles._ptr, amount]))

  @functools.native_method
  def particles_set_amount_ratio(self, particles:'RID'   , ratio:'float'   ) -> None:
    r'''
				Sets the amount ratio for particles to be emitted. Equivalent to `GPUParticles3D.amount_ratio`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(ratio, (int, float)), 'ratio must be int or float'







    self._ptr.call_with_return(233,tuple([particles._ptr, ratio]))

  @functools.native_method
  def particles_set_lifetime(self, particles:'RID'   , lifetime:'float'   ) -> None:
    r'''
				Sets the lifetime of each particle in the system. Equivalent to `GPUParticles3D.lifetime`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(lifetime, (int, float)), 'lifetime must be int or float'







    self._ptr.call_with_return(234,tuple([particles._ptr, lifetime]))

  @functools.native_method
  def particles_set_one_shot(self, particles:'RID'   , one_shot:'bool'   ) -> None:
    r'''
				If `true`, particles will emit once and then stop. Equivalent to `GPUParticles3D.one_shot`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(one_shot, bool), 'one_shot must be bool'







    self._ptr.call_with_return(235,tuple([particles._ptr, one_shot]))

  @functools.native_method
  def particles_set_pre_process_time(self, particles:'RID'   , time:'float'   ) -> None:
    r'''
				Sets the preprocess time for the particles' animation. This lets you delay starting an animation until after the particles have begun emitting. Equivalent to `GPUParticles3D.preprocess`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(time, (int, float)), 'time must be int or float'







    self._ptr.call_with_return(236,tuple([particles._ptr, time]))

  @functools.native_method
  def particles_request_process_time(self, particles:'RID'   , time:'float'   ) -> None:
    r'''
				Requests particles to process for extra process time during a single frame.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(time, (int, float)), 'time must be int or float'







    self._ptr.call_with_return(237,tuple([particles._ptr, time]))

  @functools.native_method
  def particles_set_explosiveness_ratio(self, particles:'RID'   , ratio:'float'   ) -> None:
    r'''
				Sets the explosiveness ratio. Equivalent to `GPUParticles3D.explosiveness`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(ratio, (int, float)), 'ratio must be int or float'







    self._ptr.call_with_return(238,tuple([particles._ptr, ratio]))

  @functools.native_method
  def particles_set_randomness_ratio(self, particles:'RID'   , ratio:'float'   ) -> None:
    r'''
				Sets the emission randomness ratio. This randomizes the emission of particles within their phase. Equivalent to `GPUParticles3D.randomness`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(ratio, (int, float)), 'ratio must be int or float'







    self._ptr.call_with_return(239,tuple([particles._ptr, ratio]))

  @functools.native_method
  def particles_set_interp_to_end(self, particles:'RID'   , factor:'float'   ) -> None:
    r'''
				Sets the value that informs a `ParticleProcessMaterial` to rush all particles towards the end of their lifetime.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(factor, (int, float)), 'factor must be int or float'







    self._ptr.call_with_return(240,tuple([particles._ptr, factor]))

  @functools.native_method
  def particles_set_emitter_velocity(self, particles:'RID'   , velocity:'Vector3'   ) -> None:
    r'''
				Sets the velocity of a particle node, that will be used by `ParticleProcessMaterial.inherit_velocity_ratio`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert(not velocity is None)
    assert isinstance(velocity, Vector3), 'velocity must be Vector3'







    self._ptr.call_with_return(241,tuple([particles._ptr, velocity._ptr]))

  @functools.native_method
  def particles_set_custom_aabb(self, particles:'RID'   , aabb:'AABB'   ) -> None:
    r'''
				Sets a custom axis-aligned bounding box for the particle system. Equivalent to `GPUParticles3D.visibility_aabb`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    self._ptr.call_with_return(242,tuple([particles._ptr, aabb._ptr]))

  @functools.native_method
  def particles_set_speed_scale(self, particles:'RID'   , scale:'float'   ) -> None:
    r'''
				Sets the speed scale of the particle system. Equivalent to `GPUParticles3D.speed_scale`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(scale, (int, float)), 'scale must be int or float'







    self._ptr.call_with_return(243,tuple([particles._ptr, scale]))

  @functools.native_method
  def particles_set_use_local_coordinates(self, particles:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, particles use local coordinates. If `false` they use global coordinates. Equivalent to `GPUParticles3D.local_coords`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(244,tuple([particles._ptr, enable]))

  @functools.native_method
  def particles_set_process_material(self, particles:'RID'   , material:'RID'   ) -> None:
    r'''
				Sets the material for processing the particles.
				**Note:** This is not the material used to draw the materials. Equivalent to `GPUParticles3D.process_material`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'







    self._ptr.call_with_return(245,tuple([particles._ptr, material._ptr]))

  @functools.native_method
  def particles_set_fixed_fps(self, particles:'RID'   , fps:'int'   ) -> None:
    r'''
				Sets the frame rate that the particle system rendering will be fixed to. Equivalent to `GPUParticles3D.fixed_fps`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(fps, (int, float)), 'fps must be int or float'







    self._ptr.call_with_return(246,tuple([particles._ptr, fps]))

  @functools.native_method
  def particles_set_interpolate(self, particles:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(247,tuple([particles._ptr, enable]))

  @functools.native_method
  def particles_set_fractional_delta(self, particles:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, uses fractional delta which smooths the movement of the particles. Equivalent to `GPUParticles3D.fract_delta`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(248,tuple([particles._ptr, enable]))

  @functools.native_method
  def particles_set_collision_base_size(self, particles:'RID'   , size:'float'   ) -> None:
    r'''
'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'







    self._ptr.call_with_return(249,tuple([particles._ptr, size]))

  @functools.native_method
  def particles_set_transform_align(self, particles:'RID'   , align:'int'  ) -> None:
    r'''
'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(align, (int, float)), 'align must be int or float'







    self._ptr.call_with_return(250,tuple([particles._ptr, align]))

  @functools.native_method
  def particles_set_trails(self, particles:'RID'   , enable:'bool'   , length_sec:'float'   ) -> None:
    r'''
				If `enable` is `true`, enables trails for the `particles` with the specified `length_sec` in seconds. Equivalent to `GPUParticles3D.trail_enabled` and `GPUParticles3D.trail_lifetime`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(length_sec, (int, float)), 'length_sec must be int or float'








    self._ptr.call_with_return(251,tuple([particles._ptr, enable, length_sec]))

  @functools.native_method
  def particles_set_trail_bind_poses(self, particles:'RID'   , bind_poses:'py4godot_transform3dtypedarray.Transform3DTypedArray'   ) -> None:
    r'''
'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(bind_poses, get_class('Transform3DTypedArray')), 'bind_poses must be Transform3DTypedArray'







    self._ptr.call_with_return(252,tuple([particles._ptr, bind_poses._ptr]))

  @functools.native_method
  def particles_is_inactive(self, particles:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if particles are not emitting and particles are set to inactive.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(253,tuple([particles._ptr]))
    return _ret


  @functools.native_method
  def particles_request_process(self, particles:'RID'   ) -> None:
    r'''
				Add particle system to list of particle systems that need to be updated. Update will take place on the next frame, or on the next call to `instances_cull_aabb`, `instances_cull_convex`, or `instances_cull_ray`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'






    self._ptr.call_with_return(254,tuple([particles._ptr]))

  @functools.native_method
  def particles_restart(self, particles:'RID'   ) -> None:
    r'''
				Reset the particles on the next update. Equivalent to `GPUParticles3D.restart`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'






    self._ptr.call_with_return(255,tuple([particles._ptr]))

  @functools.native_method
  def particles_set_subemitter(self, particles:'RID'   , subemitter_particles:'RID'   ) -> None:
    r'''
'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert(not subemitter_particles is None)
    assert isinstance(subemitter_particles, RID), 'subemitter_particles must be RID'







    self._ptr.call_with_return(256,tuple([particles._ptr, subemitter_particles._ptr]))

  @functools.native_method
  def particles_emit(self, particles:'RID'   , transform:'Transform3D'   , velocity:'Vector3'   , color:'Color'   , custom:'Color'   , emit_flags:'int'   ) -> None:
    r'''
				Manually emits particles from the `particles` instance.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'
    assert(not velocity is None)
    assert isinstance(velocity, Vector3), 'velocity must be Vector3'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert(not custom is None)
    assert isinstance(custom, Color), 'custom must be Color'
    assert isinstance(emit_flags, (int, float)), 'emit_flags must be int or float'











    self._ptr.call_with_return(257,tuple([particles._ptr, transform._ptr, velocity._ptr, color._ptr, custom._ptr, emit_flags]))

  @functools.native_method
  def particles_set_draw_order(self, particles:'RID'   , order:'int'  ) -> None:
    r'''
				Sets the draw order of the particles. Equivalent to `GPUParticles3D.draw_order`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(order, (int, float)), 'order must be int or float'







    self._ptr.call_with_return(258,tuple([particles._ptr, order]))

  @functools.native_method
  def particles_set_draw_passes(self, particles:'RID'   , count:'int'   ) -> None:
    r'''
				Sets the number of draw passes to use. Equivalent to `GPUParticles3D.draw_passes`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(count, (int, float)), 'count must be int or float'







    self._ptr.call_with_return(259,tuple([particles._ptr, count]))

  @functools.native_method
  def particles_set_draw_pass_mesh(self, particles:'RID'   , pass_:'int'   , mesh:'RID'   ) -> None:
    r'''
				Sets the mesh to be used for the specified draw pass. Equivalent to `GPUParticles3D.draw_pass_1`, `GPUParticles3D.draw_pass_2`, `GPUParticles3D.draw_pass_3`, and `GPUParticles3D.draw_pass_4`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert isinstance(pass_, (int, float)), 'pass_ must be int or float'
    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'








    self._ptr.call_with_return(260,tuple([particles._ptr, pass_, mesh._ptr]))

  @functools.native_method
  def particles_get_current_aabb(self, particles:'RID'   ) -> typing.Union['AABB']:
    r'''
				Calculates and returns the axis-aligned bounding box that contains all the particles. Equivalent to `GPUParticles3D.capture_aabb`.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'






    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(261,tuple([particles._ptr]))
    return _ret


  @functools.native_method
  def particles_set_emission_transform(self, particles:'RID'   , transform:'Transform3D'   ) -> None:
    r'''
				Sets the `Transform3D` that will be used by the particles when they first emit.
			'''

    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'







    self._ptr.call_with_return(262,tuple([particles._ptr, transform._ptr]))

  @functools.native_method
  def particles_collision_create(self) -> typing.Union['RID']:
    r'''
				Creates a new 3D GPU particle collision or attractor and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `particles_collision_*` RenderingServer functions.
				**Note:** The equivalent nodes are `GPUParticlesCollision3D` and `GPUParticlesAttractor3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(263,tuple([]))
    return _ret


  @functools.native_method
  def particles_collision_set_collision_type(self, particles_collision:'RID'   , type:'int'  ) -> None:
    r'''
				Sets the collision or attractor shape `type` for the 3D GPU particles collision or attractor specified by the `particles_collision` RID.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(type, (int, float)), 'type must be int or float'







    self._ptr.call_with_return(264,tuple([particles_collision._ptr, type]))

  @functools.native_method
  def particles_collision_set_cull_mask(self, particles_collision:'RID'   , mask:'int'   ) -> None:
    r'''
				Sets the cull `mask` for the 3D GPU particles collision or attractor specified by the `particles_collision` RID. Equivalent to `GPUParticlesCollision3D.cull_mask` or `GPUParticlesAttractor3D.cull_mask` depending on the `particles_collision` type.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(265,tuple([particles_collision._ptr, mask]))

  @functools.native_method
  def particles_collision_set_sphere_radius(self, particles_collision:'RID'   , radius:'float'   ) -> None:
    r'''
				Sets the `radius` for the 3D GPU particles sphere collision or attractor specified by the `particles_collision` RID. Equivalent to `GPUParticlesCollisionSphere3D.radius` or `GPUParticlesAttractorSphere3D.radius` depending on the `particles_collision` type.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(radius, (int, float)), 'radius must be int or float'







    self._ptr.call_with_return(266,tuple([particles_collision._ptr, radius]))

  @functools.native_method
  def particles_collision_set_box_extents(self, particles_collision:'RID'   , extents:'Vector3'   ) -> None:
    r'''
				Sets the `extents` for the 3D GPU particles collision by the `particles_collision` RID. Equivalent to `GPUParticlesCollisionBox3D.size`, `GPUParticlesCollisionSDF3D.size`, `GPUParticlesCollisionHeightField3D.size`, `GPUParticlesAttractorBox3D.size` or `GPUParticlesAttractorVectorField3D.size` depending on the `particles_collision` type.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert(not extents is None)
    assert isinstance(extents, Vector3), 'extents must be Vector3'







    self._ptr.call_with_return(267,tuple([particles_collision._ptr, extents._ptr]))

  @functools.native_method
  def particles_collision_set_attractor_strength(self, particles_collision:'RID'   , strength:'float'   ) -> None:
    r'''
				Sets the `strength` for the 3D GPU particles attractor specified by the `particles_collision` RID. Only used for attractors, not colliders. Equivalent to `GPUParticlesAttractor3D.strength`.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(strength, (int, float)), 'strength must be int or float'







    self._ptr.call_with_return(268,tuple([particles_collision._ptr, strength]))

  @functools.native_method
  def particles_collision_set_attractor_directionality(self, particles_collision:'RID'   , amount:'float'   ) -> None:
    r'''
				Sets the directionality `amount` for the 3D GPU particles attractor specified by the `particles_collision` RID. Only used for attractors, not colliders. Equivalent to `GPUParticlesAttractor3D.directionality`.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(amount, (int, float)), 'amount must be int or float'







    self._ptr.call_with_return(269,tuple([particles_collision._ptr, amount]))

  @functools.native_method
  def particles_collision_set_attractor_attenuation(self, particles_collision:'RID'   , curve:'float'   ) -> None:
    r'''
				Sets the attenuation `curve` for the 3D GPU particles attractor specified by the `particles_collision` RID. Only used for attractors, not colliders. Equivalent to `GPUParticlesAttractor3D.attenuation`.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(curve, (int, float)), 'curve must be int or float'







    self._ptr.call_with_return(270,tuple([particles_collision._ptr, curve]))

  @functools.native_method
  def particles_collision_set_field_texture(self, particles_collision:'RID'   , texture:'RID'   ) -> None:
    r'''
				Sets the signed distance field `texture` for the 3D GPU particles collision specified by the `particles_collision` RID. Equivalent to `GPUParticlesCollisionSDF3D.texture` or `GPUParticlesAttractorVectorField3D.texture` depending on the `particles_collision` type.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'







    self._ptr.call_with_return(271,tuple([particles_collision._ptr, texture._ptr]))

  @functools.native_method
  def particles_collision_height_field_update(self, particles_collision:'RID'   ) -> None:
    r'''
				Requests an update for the 3D GPU particle collision heightfield. This may be automatically called by the 3D GPU particle collision heightfield depending on its `GPUParticlesCollisionHeightField3D.update_mode`.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'






    self._ptr.call_with_return(272,tuple([particles_collision._ptr]))

  @functools.native_method
  def particles_collision_set_height_field_resolution(self, particles_collision:'RID'   , resolution:'int'  ) -> None:
    r'''
				Sets the heightmap `resolution` for the 3D GPU particles heightfield collision specified by the `particles_collision` RID. Equivalent to `GPUParticlesCollisionHeightField3D.resolution`.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(resolution, (int, float)), 'resolution must be int or float'







    self._ptr.call_with_return(273,tuple([particles_collision._ptr, resolution]))

  @functools.native_method
  def particles_collision_set_height_field_mask(self, particles_collision:'RID'   , mask:'int'   ) -> None:
    r'''
				Sets the heightfield `mask` for the 3D GPU particles heightfield collision specified by the `particles_collision` RID. Equivalent to `GPUParticlesCollisionHeightField3D.heightfield_mask`.
			'''

    assert(not particles_collision is None)
    assert isinstance(particles_collision, RID), 'particles_collision must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(274,tuple([particles_collision._ptr, mask]))

  @functools.native_method
  def fog_volume_create(self) -> typing.Union['RID']:
    r'''
				Creates a new fog volume and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `fog_volume_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `FogVolume`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(275,tuple([]))
    return _ret


  @functools.native_method
  def fog_volume_set_shape(self, fog_volume:'RID'   , shape:'int'  ) -> None:
    r'''
				Sets the shape of the fog volume to either `constant RenderingServer.FOG_VOLUME_SHAPE_ELLIPSOID`, `constant RenderingServer.FOG_VOLUME_SHAPE_CONE`, `constant RenderingServer.FOG_VOLUME_SHAPE_CYLINDER`, `constant RenderingServer.FOG_VOLUME_SHAPE_BOX` or `constant RenderingServer.FOG_VOLUME_SHAPE_WORLD`.
			'''

    assert(not fog_volume is None)
    assert isinstance(fog_volume, RID), 'fog_volume must be RID'
    assert isinstance(shape, (int, float)), 'shape must be int or float'







    self._ptr.call_with_return(276,tuple([fog_volume._ptr, shape]))

  @functools.native_method
  def fog_volume_set_size(self, fog_volume:'RID'   , size:'Vector3'   ) -> None:
    r'''
				Sets the size of the fog volume when shape is `constant RenderingServer.FOG_VOLUME_SHAPE_ELLIPSOID`, `constant RenderingServer.FOG_VOLUME_SHAPE_CONE`, `constant RenderingServer.FOG_VOLUME_SHAPE_CYLINDER` or `constant RenderingServer.FOG_VOLUME_SHAPE_BOX`.
			'''

    assert(not fog_volume is None)
    assert isinstance(fog_volume, RID), 'fog_volume must be RID'
    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'







    self._ptr.call_with_return(277,tuple([fog_volume._ptr, size._ptr]))

  @functools.native_method
  def fog_volume_set_material(self, fog_volume:'RID'   , material:'RID'   ) -> None:
    r'''
				Sets the `Material` of the fog volume. Can be either a `FogMaterial` or a custom `ShaderMaterial`.
			'''

    assert(not fog_volume is None)
    assert isinstance(fog_volume, RID), 'fog_volume must be RID'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'







    self._ptr.call_with_return(278,tuple([fog_volume._ptr, material._ptr]))

  @functools.native_method
  def visibility_notifier_create(self) -> typing.Union['RID']:
    r'''
				Creates a new 3D visibility notifier object and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `visibility_notifier_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				To place in a scene, attach this notifier to an instance using `instance_set_base` using the returned RID.
				**Note:** The equivalent node is `VisibleOnScreenNotifier3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([]))
    return _ret


  @functools.native_method
  def visibility_notifier_set_aabb(self, notifier:'RID'   , aabb:'AABB'   ) -> None:
    r'''
'''

    assert(not notifier is None)
    assert isinstance(notifier, RID), 'notifier must be RID'
    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    self._ptr.call_with_return(280,tuple([notifier._ptr, aabb._ptr]))

  @functools.native_method
  def visibility_notifier_set_callbacks(self, notifier:'RID'   , enter_callable:'Callable'   , exit_callable:'Callable'   ) -> None:
    r'''
'''

    assert(not notifier is None)
    assert isinstance(notifier, RID), 'notifier must be RID'
    assert(not enter_callable is None)
    assert isinstance(enter_callable, Callable), 'enter_callable must be Callable'
    assert(not exit_callable is None)
    assert isinstance(exit_callable, Callable), 'exit_callable must be Callable'








    self._ptr.call_with_return(281,tuple([notifier._ptr, enter_callable._ptr, exit_callable._ptr]))

  @functools.native_method
  def occluder_create(self) -> typing.Union['RID']:
    r'''
				Creates an occluder instance and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `occluder_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `Occluder3D` (not to be confused with the `OccluderInstance3D` node).
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(282,tuple([]))
    return _ret


  @functools.native_method
  def occluder_set_mesh(self, occluder:'RID'   , vertices:'PackedVector3Array'   , indices:'PackedInt32Array'   ) -> None:
    r'''
				Sets the mesh data for the given occluder RID, which controls the shape of the occlusion culling that will be performed.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert(not vertices is None)
    assert isinstance(vertices, PackedVector3Array), 'vertices must be PackedVector3Array'
    assert(not indices is None)
    assert isinstance(indices, PackedInt32Array), 'indices must be PackedInt32Array'








    self._ptr.call_with_return(283,tuple([occluder._ptr, vertices._ptr, indices._ptr]))

  @functools.native_method
  def camera_create(self) -> typing.Union['RID']:
    r'''
				Creates a 3D camera and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `camera_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `Camera3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(284,tuple([]))
    return _ret


  @functools.native_method
  def camera_set_perspective(self, camera:'RID'   , fovy_degrees:'float'   , z_near:'float'   , z_far:'float'   ) -> None:
    r'''
				Sets camera to use perspective projection. Objects on the screen becomes smaller when they are far away.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert isinstance(fovy_degrees, (int, float)), 'fovy_degrees must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'









    self._ptr.call_with_return(285,tuple([camera._ptr, fovy_degrees, z_near, z_far]))

  @functools.native_method
  def camera_set_orthogonal(self, camera:'RID'   , size:'float'   , z_near:'float'   , z_far:'float'   ) -> None:
    r'''
				Sets camera to use orthogonal projection, also known as orthographic projection. Objects remain the same size on the screen no matter how far away they are.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'









    self._ptr.call_with_return(286,tuple([camera._ptr, size, z_near, z_far]))

  @functools.native_method
  def camera_set_frustum(self, camera:'RID'   , size:'float'   , offset:'Vector2'   , z_near:'float'   , z_far:'float'   ) -> None:
    r'''
				Sets camera to use frustum projection. This mode allows adjusting the `offset` argument to create "tilted frustum" effects.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'










    self._ptr.call_with_return(287,tuple([camera._ptr, size, offset._ptr, z_near, z_far]))

  @functools.native_method
  def camera_set_transform(self, camera:'RID'   , transform:'Transform3D'   ) -> None:
    r'''
				Sets `Transform3D` of camera.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'







    self._ptr.call_with_return(288,tuple([camera._ptr, transform._ptr]))

  @functools.native_method
  def camera_set_cull_mask(self, camera:'RID'   , layers:'int'   ) -> None:
    r'''
				Sets the cull mask associated with this camera. The cull mask describes which 3D layers are rendered by this camera. Equivalent to `Camera3D.cull_mask`.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert isinstance(layers, (int, float)), 'layers must be int or float'







    self._ptr.call_with_return(289,tuple([camera._ptr, layers]))

  @functools.native_method
  def camera_set_environment(self, camera:'RID'   , env:'RID'   ) -> None:
    r'''
				Sets the environment used by this camera. Equivalent to `Camera3D.environment`.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'







    self._ptr.call_with_return(290,tuple([camera._ptr, env._ptr]))

  @functools.native_method
  def camera_set_camera_attributes(self, camera:'RID'   , effects:'RID'   ) -> None:
    r'''
				Sets the camera_attributes created with `camera_attributes_create` to the given camera.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert(not effects is None)
    assert isinstance(effects, RID), 'effects must be RID'







    self._ptr.call_with_return(291,tuple([camera._ptr, effects._ptr]))

  @functools.native_method
  def camera_set_compositor(self, camera:'RID'   , compositor:'RID'   ) -> None:
    r'''
				Sets the compositor used by this camera. Equivalent to `Camera3D.compositor`.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert(not compositor is None)
    assert isinstance(compositor, RID), 'compositor must be RID'







    self._ptr.call_with_return(292,tuple([camera._ptr, compositor._ptr]))

  @functools.native_method
  def camera_set_use_vertical_aspect(self, camera:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, preserves the horizontal aspect ratio which is equivalent to `constant Camera3D.KEEP_WIDTH`. If `false`, preserves the vertical aspect ratio which is equivalent to `constant Camera3D.KEEP_HEIGHT`.
			'''

    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(293,tuple([camera._ptr, enable]))

  @functools.native_method
  def viewport_create(self) -> typing.Union['RID']:
    r'''
				Creates an empty viewport and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `viewport_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `Viewport`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(294,tuple([]))
    return _ret


  @functools.native_method
  def viewport_set_use_xr(self, viewport:'RID'   , use_xr:'bool'   ) -> None:
    r'''
				If `true`, the viewport uses augmented or virtual reality technologies. See `XRInterface`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(use_xr, bool), 'use_xr must be bool'







    self._ptr.call_with_return(295,tuple([viewport._ptr, use_xr]))

  @functools.native_method
  def viewport_set_size(self, viewport:'RID'   , width:'int'   , height:'int'   ) -> None:
    r'''
				Sets the viewport's width and height in pixels.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'








    self._ptr.call_with_return(296,tuple([viewport._ptr, width, height]))

  @functools.native_method
  def viewport_set_active(self, viewport:'RID'   , active:'bool'   ) -> None:
    r'''
				If `true`, sets the viewport active, else sets it inactive.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(active, bool), 'active must be bool'







    self._ptr.call_with_return(297,tuple([viewport._ptr, active]))

  @functools.native_method
  def viewport_set_parent_viewport(self, viewport:'RID'   , parent_viewport:'RID'   ) -> None:
    r'''
				Sets the viewport's parent to the viewport specified by the `parent_viewport` RID.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not parent_viewport is None)
    assert isinstance(parent_viewport, RID), 'parent_viewport must be RID'







    self._ptr.call_with_return(298,tuple([viewport._ptr, parent_viewport._ptr]))

  @functools.native_method
  def viewport_attach_to_screen(self, viewport:'RID'   , rect:'Rect2' = None  , screen:'int' =0  ) -> None:
    r'''
				Copies the viewport to a region of the screen specified by `rect`. If `viewport_set_render_direct_to_screen` is `true`, then the viewport does not use a framebuffer and the contents of the viewport are rendered directly to screen. However, note that the root viewport is drawn last, therefore it will draw over the screen. Accordingly, you must set the root viewport to an area that does not cover the area that you have attached this viewport to.
				For example, you can set the root viewport to not render at all with the following code:
				
				```gdscript
				func _ready():
					RenderingServer.viewport_attach_to_screen(get_viewport().get_viewport_rid(), Rect2())
					RenderingServer.viewport_attach_to_screen($Viewport.get_viewport_rid(), Rect2(0, 0, 600, 600))
				```
				
				Using this can result in significant optimization, especially on lower-end devices. However, it comes at the cost of having to manage your viewports manually. For further optimization, see `viewport_set_render_direct_to_screen`.
			'''
    if rect is None:
      rect = Rect2.new0()
    if rect is None:
      rect = Rect2.new0()

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(screen, (int, float)), 'screen must be int or float'








    self._ptr.call_with_return(299,tuple([viewport._ptr, rect._ptr, screen]))

  @functools.native_method
  def viewport_set_render_direct_to_screen(self, viewport:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, render the contents of the viewport directly to screen. This allows a low-level optimization where you can skip drawing a viewport to the root viewport. While this optimization can result in a significant increase in speed (especially on older devices), it comes at a cost of usability. When this is enabled, you cannot read from the viewport or from the screen_texture. You also lose the benefit of certain window settings, such as the various stretch modes. Another consequence to be aware of is that in 2D the rendering happens in window coordinates, so if you have a viewport that is double the size of the window, and you set this, then only the portion that fits within the window will be drawn, no automatic scaling is possible, even if your game scene is significantly larger than the window size.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(300,tuple([viewport._ptr, enabled]))

  @functools.native_method
  def viewport_set_canvas_cull_mask(self, viewport:'RID'   , canvas_cull_mask:'int'   ) -> None:
    r'''
				Sets the rendering mask associated with this `Viewport`. Only `CanvasItem` nodes with a matching rendering visibility layer will be rendered by this `Viewport`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(canvas_cull_mask, (int, float)), 'canvas_cull_mask must be int or float'







    self._ptr.call_with_return(301,tuple([viewport._ptr, canvas_cull_mask]))

  @functools.native_method
  def viewport_set_scaling_3d_mode(self, viewport:'RID'   , scaling_3d_mode:'int'  ) -> None:
    r'''
				Sets the 3D resolution scaling mode. Bilinear scaling renders at different resolution to either undersample or supersample the viewport. FidelityFX Super Resolution 1.0, abbreviated to FSR, is an upscaling technology that produces high quality images at fast framerates by using a spatially aware upscaling algorithm. FSR is slightly more expensive than bilinear, but it produces significantly higher image quality. FSR should be used where possible.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(scaling_3d_mode, (int, float)), 'scaling_3d_mode must be int or float'







    self._ptr.call_with_return(302,tuple([viewport._ptr, scaling_3d_mode]))

  @functools.native_method
  def viewport_set_scaling_3d_scale(self, viewport:'RID'   , scale:'float'   ) -> None:
    r'''
				Scales the 3D render buffer based on the viewport size uses an image filter specified in `enum ViewportScaling3DMode` to scale the output image to the full viewport size. Values lower than `1.0` can be used to speed up 3D rendering at the cost of quality (undersampling). Values greater than `1.0` are only valid for bilinear mode and can be used to improve 3D rendering quality at a high performance cost (supersampling). See also `enum ViewportMSAA` for multi-sample antialiasing, which is significantly cheaper but only smoothens the edges of polygons.
				When using FSR upscaling, AMD recommends exposing the following values as preset options to users "Ultra Quality: 0.77", "Quality: 0.67", "Balanced: 0.59", "Performance: 0.5" instead of exposing the entire scale.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(scale, (int, float)), 'scale must be int or float'







    self._ptr.call_with_return(303,tuple([viewport._ptr, scale]))

  @functools.native_method
  def viewport_set_fsr_sharpness(self, viewport:'RID'   , sharpness:'float'   ) -> None:
    r'''
				Determines how sharp the upscaled image will be when using the FSR upscaling mode. Sharpness halves with every whole number. Values go from 0.0 (sharpest) to 2.0. Values above 2.0 won't make a visible difference.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(sharpness, (int, float)), 'sharpness must be int or float'







    self._ptr.call_with_return(304,tuple([viewport._ptr, sharpness]))

  @functools.native_method
  def viewport_set_texture_mipmap_bias(self, viewport:'RID'   , mipmap_bias:'float'   ) -> None:
    r'''
				Affects the final texture sharpness by reading from a lower or higher mipmap (also called "texture LOD bias"). Negative values make mipmapped textures sharper but grainier when viewed at a distance, while positive values make mipmapped textures blurrier (even when up close). To get sharper textures at a distance without introducing too much graininess, set this between `-0.75` and `0.0`. Enabling temporal antialiasing (`ProjectSettings.rendering/anti_aliasing/quality/use_taa`) can help reduce the graininess visible when using negative mipmap bias.
				**Note:** When the 3D scaling mode is set to FSR 1.0, this value is used to adjust the automatic mipmap bias which is calculated internally based on the scale factor. The formula for this is `-log2(1.0 / scale) + mipmap_bias`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(mipmap_bias, (int, float)), 'mipmap_bias must be int or float'







    self._ptr.call_with_return(305,tuple([viewport._ptr, mipmap_bias]))

  @functools.native_method
  def viewport_set_anisotropic_filtering_level(self, viewport:'RID'   , anisotropic_filtering_level:'int'  ) -> None:
    r'''
				Sets the maximum number of samples to take when using anisotropic filtering on textures (as a power of two). A higher sample count will result in sharper textures at oblique angles, but is more expensive to compute. A value of `0` forcibly disables anisotropic filtering, even on materials where it is enabled.
				The anisotropic filtering level also affects decals and light projectors if they are configured to use anisotropic filtering. See `ProjectSettings.rendering/textures/decals/filter` and `ProjectSettings.rendering/textures/light_projectors/filter`.
				**Note:** In 3D, for this setting to have an effect, set `BaseMaterial3D.texture_filter` to `constant BaseMaterial3D.TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC` or `constant BaseMaterial3D.TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC` on materials.
				**Note:** In 2D, for this setting to have an effect, set `CanvasItem.texture_filter` to `constant CanvasItem.TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC` or `constant CanvasItem.TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC` on the `CanvasItem` node displaying the texture (or in `CanvasTexture`). However, anisotropic filtering is rarely useful in 2D, so only enable it for textures in 2D if it makes a meaningful visual difference.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(anisotropic_filtering_level, (int, float)), 'anisotropic_filtering_level must be int or float'







    self._ptr.call_with_return(306,tuple([viewport._ptr, anisotropic_filtering_level]))

  @functools.native_method
  def viewport_set_update_mode(self, viewport:'RID'   , update_mode:'int'  ) -> None:
    r'''
				Sets when the viewport should be updated.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(update_mode, (int, float)), 'update_mode must be int or float'







    self._ptr.call_with_return(307,tuple([viewport._ptr, update_mode]))

  @functools.native_method
  def viewport_get_update_mode(self, viewport:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the viewport's update mode.
				**Warning:** Calling this from any thread other than the rendering thread will be detrimental to performance.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'






    _ret:int
    _ret = self._ptr.call_with_return(308,tuple([viewport._ptr]))
    return _ret


  @functools.native_method
  def viewport_set_clear_mode(self, viewport:'RID'   , clear_mode:'int'  ) -> None:
    r'''
				Sets the clear mode of a viewport.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(clear_mode, (int, float)), 'clear_mode must be int or float'







    self._ptr.call_with_return(309,tuple([viewport._ptr, clear_mode]))

  @functools.native_method
  def viewport_get_render_target(self, viewport:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns the render target for the viewport.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(310,tuple([viewport._ptr]))
    return _ret


  @functools.native_method
  def viewport_get_texture(self, viewport:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns the viewport's last rendered frame.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(311,tuple([viewport._ptr]))
    return _ret


  @functools.native_method
  def viewport_set_disable_3d(self, viewport:'RID'   , disable:'bool'   ) -> None:
    r'''
				If `true`, the viewport's 3D elements are not rendered.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(disable, bool), 'disable must be bool'







    self._ptr.call_with_return(312,tuple([viewport._ptr, disable]))

  @functools.native_method
  def viewport_set_disable_2d(self, viewport:'RID'   , disable:'bool'   ) -> None:
    r'''
				If `true`, the viewport's canvas (i.e. 2D and GUI elements) is not rendered.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(disable, bool), 'disable must be bool'







    self._ptr.call_with_return(313,tuple([viewport._ptr, disable]))

  @functools.native_method
  def viewport_set_environment_mode(self, viewport:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the viewport's environment mode which allows enabling or disabling rendering of 3D environment over 2D canvas. When disabled, 2D will not be affected by the environment. When enabled, 2D will be affected by the environment if the environment background mode is `constant ENV_BG_CANVAS`. The default behavior is to inherit the setting from the viewport's parent. If the topmost parent is also set to `constant VIEWPORT_ENVIRONMENT_INHERIT`, then the behavior will be the same as if it was set to `constant VIEWPORT_ENVIRONMENT_ENABLED`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(314,tuple([viewport._ptr, mode]))

  @functools.native_method
  def viewport_attach_camera(self, viewport:'RID'   , camera:'RID'   ) -> None:
    r'''
				Sets a viewport's camera.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not camera is None)
    assert isinstance(camera, RID), 'camera must be RID'







    self._ptr.call_with_return(315,tuple([viewport._ptr, camera._ptr]))

  @functools.native_method
  def viewport_set_scenario(self, viewport:'RID'   , scenario:'RID'   ) -> None:
    r'''
				Sets a viewport's scenario. The scenario contains information about environment information, reflection atlas, etc.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not scenario is None)
    assert isinstance(scenario, RID), 'scenario must be RID'







    self._ptr.call_with_return(316,tuple([viewport._ptr, scenario._ptr]))

  @functools.native_method
  def viewport_attach_canvas(self, viewport:'RID'   , canvas:'RID'   ) -> None:
    r'''
				Sets a viewport's canvas.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'







    self._ptr.call_with_return(317,tuple([viewport._ptr, canvas._ptr]))

  @functools.native_method
  def viewport_remove_canvas(self, viewport:'RID'   , canvas:'RID'   ) -> None:
    r'''
				Detaches a viewport from a canvas.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'







    self._ptr.call_with_return(318,tuple([viewport._ptr, canvas._ptr]))

  @functools.native_method
  def viewport_set_snap_2d_transforms_to_pixel(self, viewport:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, canvas item transforms (i.e. origin position) are snapped to the nearest pixel when rendering. This can lead to a crisper appearance at the cost of less smooth movement, especially when `Camera2D` smoothing is enabled. Equivalent to `ProjectSettings.rendering/2d/snap/snap_2d_transforms_to_pixel`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(319,tuple([viewport._ptr, enabled]))

  @functools.native_method
  def viewport_set_snap_2d_vertices_to_pixel(self, viewport:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, canvas item vertices (i.e. polygon points) are snapped to the nearest pixel when rendering. This can lead to a crisper appearance at the cost of less smooth movement, especially when `Camera2D` smoothing is enabled. Equivalent to `ProjectSettings.rendering/2d/snap/snap_2d_vertices_to_pixel`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(320,tuple([viewport._ptr, enabled]))

  @functools.native_method
  def viewport_set_default_canvas_item_texture_filter(self, viewport:'RID'   , filter:'int'  ) -> None:
    r'''
				Sets the default texture filtering mode for the specified `viewport` RID.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(filter, (int, float)), 'filter must be int or float'







    self._ptr.call_with_return(321,tuple([viewport._ptr, filter]))

  @functools.native_method
  def viewport_set_default_canvas_item_texture_repeat(self, viewport:'RID'   , repeat:'int'  ) -> None:
    r'''
				Sets the default texture repeat mode for the specified `viewport` RID.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(repeat, (int, float)), 'repeat must be int or float'







    self._ptr.call_with_return(322,tuple([viewport._ptr, repeat]))

  @functools.native_method
  def viewport_set_canvas_transform(self, viewport:'RID'   , canvas:'RID'   , offset:'Transform2D'   ) -> None:
    r'''
				Sets the transformation of a viewport's canvas.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not offset is None)
    assert isinstance(offset, Transform2D), 'offset must be Transform2D'








    self._ptr.call_with_return(323,tuple([viewport._ptr, canvas._ptr, offset._ptr]))

  @functools.native_method
  def viewport_set_canvas_stacking(self, viewport:'RID'   , canvas:'RID'   , layer:'int'   , sublayer:'int'   ) -> None:
    r'''
				Sets the stacking order for a viewport's canvas.
				`layer` is the actual canvas layer, while `sublayer` specifies the stacking order of the canvas among those in the same layer.
				**Note:** `layer` should be between `constant CANVAS_LAYER_MIN` and `constant CANVAS_LAYER_MAX` (inclusive). Any other value will wrap around.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(sublayer, (int, float)), 'sublayer must be int or float'









    self._ptr.call_with_return(324,tuple([viewport._ptr, canvas._ptr, layer, sublayer]))

  @functools.native_method
  def viewport_set_transparent_background(self, viewport:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, the viewport renders its background as transparent.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(325,tuple([viewport._ptr, enabled]))

  @functools.native_method
  def viewport_set_global_canvas_transform(self, viewport:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets the viewport's global transformation matrix.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(326,tuple([viewport._ptr, transform._ptr]))

  @functools.native_method
  def viewport_set_sdf_oversize_and_scale(self, viewport:'RID'   , oversize:'int'  , scale:'int'  ) -> None:
    r'''
				Sets the viewport's 2D signed distance field `ProjectSettings.rendering/2d/sdf/oversize` and `ProjectSettings.rendering/2d/sdf/scale`. This is used when sampling the signed distance field in `CanvasItem` shaders as well as `GPUParticles2D` collision. This is _not_ used by SDFGI in 3D rendering.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(oversize, (int, float)), 'oversize must be int or float'
    assert isinstance(scale, (int, float)), 'scale must be int or float'








    self._ptr.call_with_return(327,tuple([viewport._ptr, oversize, scale]))

  @functools.native_method
  def viewport_set_positional_shadow_atlas_size(self, viewport:'RID'   , size:'int'   , use_16_bits:'bool' =False  ) -> None:
    r'''
				Sets the `size` of the shadow atlas's images (used for omni and spot lights) on the viewport specified by the `viewport` RID. The value is rounded up to the nearest power of 2. If `use_16_bits` is `true`, use 16 bits for the omni/spot shadow depth map. Enabling this results in shadows having less precision and may result in shadow acne, but can lead to performance improvements on some devices.
				**Note:** If this is set to `0`, no positional shadows will be visible at all. This can improve performance significantly on low-end systems by reducing both the CPU and GPU load (as fewer draw calls are needed to draw the scene without shadows).
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(use_16_bits, bool), 'use_16_bits must be bool'








    self._ptr.call_with_return(328,tuple([viewport._ptr, size, use_16_bits]))

  @functools.native_method
  def viewport_set_positional_shadow_atlas_quadrant_subdivision(self, viewport:'RID'   , quadrant:'int'   , subdivision:'int'   ) -> None:
    r'''
				Sets the number of subdivisions to use in the specified shadow atlas `quadrant` for omni and spot shadows. See also `Viewport.set_positional_shadow_atlas_quadrant_subdiv`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(quadrant, (int, float)), 'quadrant must be int or float'
    assert isinstance(subdivision, (int, float)), 'subdivision must be int or float'








    self._ptr.call_with_return(329,tuple([viewport._ptr, quadrant, subdivision]))

  @functools.native_method
  def viewport_set_msaa_3d(self, viewport:'RID'   , msaa:'int'  ) -> None:
    r'''
				Sets the multisample antialiasing mode for 3D on the specified `viewport` RID. Equivalent to `ProjectSettings.rendering/anti_aliasing/quality/msaa_3d` or `Viewport.msaa_3d`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(msaa, (int, float)), 'msaa must be int or float'







    self._ptr.call_with_return(330,tuple([viewport._ptr, msaa]))

  @functools.native_method
  def viewport_set_msaa_2d(self, viewport:'RID'   , msaa:'int'  ) -> None:
    r'''
				Sets the multisample antialiasing mode for 2D/Canvas on the specified `viewport` RID. Equivalent to `ProjectSettings.rendering/anti_aliasing/quality/msaa_2d` or `Viewport.msaa_2d`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(msaa, (int, float)), 'msaa must be int or float'







    self._ptr.call_with_return(331,tuple([viewport._ptr, msaa]))

  @functools.native_method
  def viewport_set_use_hdr_2d(self, viewport:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, 2D rendering will use a high dynamic range (HDR) format framebuffer matching the bit depth of the 3D framebuffer. When using the Forward+ or Compatibility renderer, this will be an `RGBA16` framebuffer. When using the Mobile renderer, it will be an `RGB10_A2` framebuffer.
				Additionally, 2D rendering will be performed on linear values and will be converted using the appropriate transfer function immediately before blitting to the screen (if the Viewport is attached to the screen).
				Practically speaking, this means that the end result of the Viewport will not be clamped to the `0-1` range and can be used in 3D rendering without color encoding adjustments. This allows 2D rendering to take advantage of effects requiring high dynamic range (e.g. 2D glow) as well as substantially improves the appearance of effects requiring highly detailed gradients. This setting has the same effect as `Viewport.use_hdr_2d`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(332,tuple([viewport._ptr, enabled]))

  @functools.native_method
  def viewport_set_screen_space_aa(self, viewport:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the viewport's screen-space antialiasing mode. Equivalent to `ProjectSettings.rendering/anti_aliasing/quality/screen_space_aa` or `Viewport.screen_space_aa`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(333,tuple([viewport._ptr, mode]))

  @functools.native_method
  def viewport_set_use_taa(self, viewport:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, use temporal antialiasing. Equivalent to `ProjectSettings.rendering/anti_aliasing/quality/use_taa` or `Viewport.use_taa`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(334,tuple([viewport._ptr, enable]))

  @functools.native_method
  def viewport_set_use_debanding(self, viewport:'RID'   , enable:'bool'   ) -> None:
    r'''
				Equivalent to `Viewport.use_debanding`. See also `ProjectSettings.rendering/anti_aliasing/quality/use_debanding`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(335,tuple([viewport._ptr, enable]))

  @functools.native_method
  def viewport_set_use_occlusion_culling(self, viewport:'RID'   , enable:'bool'   ) -> None:
    r'''
				If `true`, enables occlusion culling on the specified viewport. Equivalent to `ProjectSettings.rendering/occlusion_culling/use_occlusion_culling`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(336,tuple([viewport._ptr, enable]))

  @functools.native_method
  def viewport_set_occlusion_rays_per_thread(self, rays_per_thread:'int'   ) -> None:
    r'''
				Sets the `ProjectSettings.rendering/occlusion_culling/occlusion_rays_per_thread` to use for occlusion culling. This parameter is global and cannot be set on a per-viewport basis.
			'''

    assert isinstance(rays_per_thread, (int, float)), 'rays_per_thread must be int or float'






    self._ptr.call_with_return(337,tuple([rays_per_thread]))

  @functools.native_method
  def viewport_set_occlusion_culling_build_quality(self, quality:'int'  ) -> None:
    r'''
				Sets the `ProjectSettings.rendering/occlusion_culling/bvh_build_quality` to use for occlusion culling. This parameter is global and cannot be set on a per-viewport basis.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'






    self._ptr.call_with_return(338,tuple([quality]))

  @functools.native_method
  def viewport_get_render_info(self, viewport:'RID'   , type:'int'  , info:'int'  ) -> typing.Union[int]:
    r'''
				Returns a statistic about the rendering engine which can be used for performance profiling. This is separated into render pass `type`s, each of them having the same `info`s you can query (different passes will return different values).
				See also `get_rendering_info`, which returns global information across all viewports.
				**Note:** Viewport rendering information is not available until at least 2 frames have been rendered by the engine. If rendering information is not available, `viewport_get_render_info` returns `0`. To print rendering information in `_ready()` successfully, use the following:
				```gdscript
				func _ready():
					for _i in 2:
						await get_tree().process_frame

					print(
							RenderingServer.viewport_get_render_info(get_viewport().get_viewport_rid(),
							RenderingServer.VIEWPORT_RENDER_INFO_TYPE_VISIBLE,
							RenderingServer.VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME)
					)
				```
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(info, (int, float)), 'info must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(339,tuple([viewport._ptr, type, info]))
    return _ret


  @functools.native_method
  def viewport_set_debug_draw(self, viewport:'RID'   , draw:'int'  ) -> None:
    r'''
				Sets the debug draw mode of a viewport.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(draw, (int, float)), 'draw must be int or float'







    self._ptr.call_with_return(340,tuple([viewport._ptr, draw]))

  @functools.native_method
  def viewport_set_measure_render_time(self, viewport:'RID'   , enable:'bool'   ) -> None:
    r'''
				Sets the measurement for the given `viewport` RID (obtained using `Viewport.get_viewport_rid`). Once enabled, `viewport_get_measured_render_time_cpu` and `viewport_get_measured_render_time_gpu` will return values greater than `0.0` when queried with the given `viewport`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(341,tuple([viewport._ptr, enable]))

  @functools.native_method
  def viewport_get_measured_render_time_cpu(self, viewport:'RID'   ) -> typing.Union[float]:
    r'''
				Returns the CPU time taken to render the last frame in milliseconds. This _only_ includes time spent in rendering-related operations; scripts' `_process` functions and other engine subsystems are not included in this readout. To get a complete readout of CPU time spent to render the scene, sum the render times of all viewports that are drawn every frame plus `get_frame_setup_time_cpu`. Unlike `Engine.get_frames_per_second`, this method will accurately reflect CPU utilization even if framerate is capped via V-Sync or `Engine.max_fps`. See also `viewport_get_measured_render_time_gpu`.
				**Note:** Requires measurements to be enabled on the specified `viewport` using `viewport_set_measure_render_time`. Otherwise, this method returns `0.0`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(342,tuple([viewport._ptr]))
    return _ret


  @functools.native_method
  def viewport_get_measured_render_time_gpu(self, viewport:'RID'   ) -> typing.Union[float]:
    r'''
				Returns the GPU time taken to render the last frame in milliseconds. To get a complete readout of GPU time spent to render the scene, sum the render times of all viewports that are drawn every frame. Unlike `Engine.get_frames_per_second`, this method accurately reflects GPU utilization even if framerate is capped via V-Sync or `Engine.max_fps`. See also `viewport_get_measured_render_time_cpu`.
				**Note:** Requires measurements to be enabled on the specified `viewport` using `viewport_set_measure_render_time`. Otherwise, this method returns `0.0`.
				**Note:** When GPU utilization is low enough during a certain period of time, GPUs will decrease their power state (which in turn decreases core and memory clock speeds). This can cause the reported GPU time to increase if GPU utilization is kept low enough by a framerate cap (compared to what it would be at the GPU's highest power state). Keep this in mind when benchmarking using `viewport_get_measured_render_time_gpu`. This behavior can be overridden in the graphics driver settings at the cost of higher power usage.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(343,tuple([viewport._ptr]))
    return _ret


  @functools.native_method
  def viewport_set_vrs_mode(self, viewport:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the Variable Rate Shading (VRS) mode for the viewport. If the GPU does not support VRS, this property is ignored. Equivalent to `ProjectSettings.rendering/vrs/mode`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(344,tuple([viewport._ptr, mode]))

  @functools.native_method
  def viewport_set_vrs_update_mode(self, viewport:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the update mode for Variable Rate Shading (VRS) for the viewport. VRS requires the input texture to be converted to the format usable by the VRS method supported by the hardware. The update mode defines how often this happens. If the GPU does not support VRS, or VRS is not enabled, this property is ignored.
				If set to `constant RenderingServer.VIEWPORT_VRS_UPDATE_ONCE`, the input texture is copied once and the mode is changed to `constant RenderingServer.VIEWPORT_VRS_UPDATE_DISABLED`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(345,tuple([viewport._ptr, mode]))

  @functools.native_method
  def viewport_set_vrs_texture(self, viewport:'RID'   , texture:'RID'   ) -> None:
    r'''
				The texture to use when the VRS mode is set to `constant RenderingServer.VIEWPORT_VRS_TEXTURE`. Equivalent to `ProjectSettings.rendering/vrs/texture`.
			'''

    assert(not viewport is None)
    assert isinstance(viewport, RID), 'viewport must be RID'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'







    self._ptr.call_with_return(346,tuple([viewport._ptr, texture._ptr]))

  @functools.native_method
  def sky_create(self) -> typing.Union['RID']:
    r'''
				Creates an empty sky and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `sky_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(347,tuple([]))
    return _ret


  @functools.native_method
  def sky_set_radiance_size(self, sky:'RID'   , radiance_size:'int'   ) -> None:
    r'''
				Sets the `radiance_size` of the sky specified by the `sky` RID (in pixels). Equivalent to `Sky.radiance_size`.
			'''

    assert(not sky is None)
    assert isinstance(sky, RID), 'sky must be RID'
    assert isinstance(radiance_size, (int, float)), 'radiance_size must be int or float'







    self._ptr.call_with_return(348,tuple([sky._ptr, radiance_size]))

  @functools.native_method
  def sky_set_mode(self, sky:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the process `mode` of the sky specified by the `sky` RID. Equivalent to `Sky.process_mode`.
			'''

    assert(not sky is None)
    assert isinstance(sky, RID), 'sky must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(349,tuple([sky._ptr, mode]))

  @functools.native_method
  def sky_set_material(self, sky:'RID'   , material:'RID'   ) -> None:
    r'''
				Sets the material that the sky uses to render the background, ambient and reflection maps.
			'''

    assert(not sky is None)
    assert isinstance(sky, RID), 'sky must be RID'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'







    self._ptr.call_with_return(350,tuple([sky._ptr, material._ptr]))

  @functools.native_method
  def sky_bake_panorama(self, sky:'RID'   , energy:'float'   , bake_irradiance:'bool'   , size:'Vector2i'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Generates and returns an `Image` containing the radiance map for the specified `sky` RID. This supports built-in sky material and custom sky shaders. If `bake_irradiance` is `true`, the irradiance map is saved instead of the radiance map. The radiance map is used to render reflected light, while the irradiance map is used to render ambient light. See also `environment_bake_panorama`.
				**Note:** The image is saved using linear encoding without any tonemapping performed, which means it will look too dark if viewed directly in an image editor. `energy` values above `1.0` can be used to brighten the resulting image.
				**Note:** `size` should be a 2:1 aspect ratio for the generated panorama to have square pixels. For radiance maps, there is no point in using a height greater than `Sky.radiance_size`, as it won't increase detail. Irradiance maps only contain low-frequency data, so there is usually no point in going past a size of 128×64 pixels when saving an irradiance map.
			'''

    assert(not sky is None)
    assert isinstance(sky, RID), 'sky must be RID'
    assert isinstance(energy, (int, float)), 'energy must be int or float'
    assert isinstance(bake_irradiance, bool), 'bake_irradiance must be bool'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(351,tuple([sky._ptr, energy, bake_irradiance, size._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def compositor_effect_create(self) -> typing.Union['RID']:
    r'''
				Creates a new rendering effect and adds it to the RenderingServer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(352,tuple([]))
    return _ret


  @functools.native_method
  def compositor_effect_set_enabled(self, effect:'RID'   , enabled:'bool'   ) -> None:
    r'''
				Enables/disables this rendering effect.
			'''

    assert(not effect is None)
    assert isinstance(effect, RID), 'effect must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(353,tuple([effect._ptr, enabled]))

  @functools.native_method
  def compositor_effect_set_callback(self, effect:'RID'   , callback_type:'int'  , callback:'Callable'   ) -> None:
    r'''
				Sets the callback type (`callback_type`) and callback method(`callback`) for this rendering effect.
			'''

    assert(not effect is None)
    assert isinstance(effect, RID), 'effect must be RID'
    assert isinstance(callback_type, (int, float)), 'callback_type must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(354,tuple([effect._ptr, callback_type, callback._ptr]))

  @functools.native_method
  def compositor_effect_set_flag(self, effect:'RID'   , flag:'int'  , set:'bool'   ) -> None:
    r'''
				Sets the flag (`flag`) for this rendering effect to `true` or `false` (`set`).
			'''

    assert(not effect is None)
    assert isinstance(effect, RID), 'effect must be RID'
    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(set, bool), 'set must be bool'








    self._ptr.call_with_return(355,tuple([effect._ptr, flag, set]))

  @functools.native_method
  def compositor_create(self) -> typing.Union['RID']:
    r'''
				Creates a new compositor and adds it to the RenderingServer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(356,tuple([]))
    return _ret


  @functools.native_method
  def compositor_set_compositor_effects(self, compositor:'RID'   , effects:'py4godot_ridtypedarray.RIDTypedArray'   ) -> None:
    r'''
				Sets the compositor effects for the specified compositor RID. `effects` should be an array containing RIDs created with `compositor_effect_create`.
			'''

    assert(not compositor is None)
    assert isinstance(compositor, RID), 'compositor must be RID'
    assert isinstance(effects, get_class('RIDTypedArray')), 'effects must be RIDTypedArray'







    self._ptr.call_with_return(357,tuple([compositor._ptr, effects._ptr]))

  @functools.native_method
  def environment_create(self) -> typing.Union['RID']:
    r'''
				Creates an environment and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `environment_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `Environment`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(358,tuple([]))
    return _ret


  @functools.native_method
  def environment_set_background(self, env:'RID'   , bg:'int'  ) -> None:
    r'''
				Sets the environment's background mode. Equivalent to `Environment.background_mode`.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(bg, (int, float)), 'bg must be int or float'







    self._ptr.call_with_return(359,tuple([env._ptr, bg]))

  @functools.native_method
  def environment_set_camera_id(self, env:'RID'   , id:'int'   ) -> None:
    r'''
				Sets the camera ID to be used as environment background.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'







    self._ptr.call_with_return(360,tuple([env._ptr, id]))

  @functools.native_method
  def environment_set_sky(self, env:'RID'   , sky:'RID'   ) -> None:
    r'''
				Sets the `Sky` to be used as the environment's background when using _BGMode_ sky. Equivalent to `Environment.sky`.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert(not sky is None)
    assert isinstance(sky, RID), 'sky must be RID'







    self._ptr.call_with_return(361,tuple([env._ptr, sky._ptr]))

  @functools.native_method
  def environment_set_sky_custom_fov(self, env:'RID'   , scale:'float'   ) -> None:
    r'''
				Sets a custom field of view for the background `Sky`. Equivalent to `Environment.sky_custom_fov`.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(scale, (int, float)), 'scale must be int or float'







    self._ptr.call_with_return(362,tuple([env._ptr, scale]))

  @functools.native_method
  def environment_set_sky_orientation(self, env:'RID'   , orientation:'Basis'   ) -> None:
    r'''
				Sets the rotation of the background `Sky` expressed as a `Basis`. Equivalent to `Environment.sky_rotation`, where the rotation vector is used to construct the `Basis`.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert(not orientation is None)
    assert isinstance(orientation, Basis), 'orientation must be Basis'







    self._ptr.call_with_return(363,tuple([env._ptr, orientation._ptr]))

  @functools.native_method
  def environment_set_bg_color(self, env:'RID'   , color:'Color'   ) -> None:
    r'''
				Color displayed for clear areas of the scene. Only effective if using the `constant ENV_BG_COLOR` background mode.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(364,tuple([env._ptr, color._ptr]))

  @functools.native_method
  def environment_set_bg_energy(self, env:'RID'   , multiplier:'float'   , exposure_value:'float'   ) -> None:
    r'''
				Sets the intensity of the background color.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(multiplier, (int, float)), 'multiplier must be int or float'
    assert isinstance(exposure_value, (int, float)), 'exposure_value must be int or float'








    self._ptr.call_with_return(365,tuple([env._ptr, multiplier, exposure_value]))

  @functools.native_method
  def environment_set_canvas_max_layer(self, env:'RID'   , max_layer:'int'   ) -> None:
    r'''
				Sets the maximum layer to use if using Canvas background mode.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(max_layer, (int, float)), 'max_layer must be int or float'







    self._ptr.call_with_return(366,tuple([env._ptr, max_layer]))

  @functools.native_method
  def environment_set_ambient_light(self, env:'RID'   , color:'Color'   , ambient:'int'  =0, energy:'float' =1.0  , sky_contribution:'float' =0.0  , reflection_source:'int'  =0) -> None:
    r'''
				Sets the values to be used for ambient light rendering. See `Environment` for more details.
			'''





    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(ambient, (int, float)), 'ambient must be int or float'
    assert isinstance(energy, (int, float)), 'energy must be int or float'
    assert isinstance(sky_contribution, (int, float)), 'sky_contribution must be int or float'
    assert isinstance(reflection_source, (int, float)), 'reflection_source must be int or float'











    self._ptr.call_with_return(367,tuple([env._ptr, color._ptr, ambient, energy, sky_contribution, reflection_source]))

  @functools.native_method
  def environment_set_glow(self, env:'RID'   , enable:'bool'   , levels:'PackedFloat32Array'   , intensity:'float'   , strength:'float'   , mix:'float'   , bloom_threshold:'float'   , blend_mode:'int'  , hdr_bleed_threshold:'float'   , hdr_bleed_scale:'float'   , hdr_luminance_cap:'float'   , glow_map_strength:'float'   , glow_map:'RID'   ) -> None:
    r'''
				Configures glow for the specified environment RID. See `glow_*` properties in `Environment` for more information.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert(not levels is None)
    assert isinstance(levels, PackedFloat32Array), 'levels must be PackedFloat32Array'
    assert isinstance(intensity, (int, float)), 'intensity must be int or float'
    assert isinstance(strength, (int, float)), 'strength must be int or float'
    assert isinstance(mix, (int, float)), 'mix must be int or float'
    assert isinstance(bloom_threshold, (int, float)), 'bloom_threshold must be int or float'
    assert isinstance(blend_mode, (int, float)), 'blend_mode must be int or float'
    assert isinstance(hdr_bleed_threshold, (int, float)), 'hdr_bleed_threshold must be int or float'
    assert isinstance(hdr_bleed_scale, (int, float)), 'hdr_bleed_scale must be int or float'
    assert isinstance(hdr_luminance_cap, (int, float)), 'hdr_luminance_cap must be int or float'
    assert isinstance(glow_map_strength, (int, float)), 'glow_map_strength must be int or float'
    assert(not glow_map is None)
    assert isinstance(glow_map, RID), 'glow_map must be RID'


















    self._ptr.call_with_return(368,tuple([env._ptr, enable, levels._ptr, intensity, strength, mix, bloom_threshold, blend_mode, hdr_bleed_threshold, hdr_bleed_scale, hdr_luminance_cap, glow_map_strength, glow_map._ptr]))

  @functools.native_method
  def environment_set_tonemap(self, env:'RID'   , tone_mapper:'int'  , exposure:'float'   , white:'float'   ) -> None:
    r'''
				Sets the variables to be used with the "tonemap" post-process effect. See `Environment` for more details.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(tone_mapper, (int, float)), 'tone_mapper must be int or float'
    assert isinstance(exposure, (int, float)), 'exposure must be int or float'
    assert isinstance(white, (int, float)), 'white must be int or float'









    self._ptr.call_with_return(369,tuple([env._ptr, tone_mapper, exposure, white]))

  @functools.native_method
  def environment_set_adjustment(self, env:'RID'   , enable:'bool'   , brightness:'float'   , contrast:'float'   , saturation:'float'   , use_1d_color_correction:'bool'   , color_correction:'RID'   ) -> None:
    r'''
				Sets the values to be used with the "adjustments" post-process effect. See `Environment` for more details.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(brightness, (int, float)), 'brightness must be int or float'
    assert isinstance(contrast, (int, float)), 'contrast must be int or float'
    assert isinstance(saturation, (int, float)), 'saturation must be int or float'
    assert isinstance(use_1d_color_correction, bool), 'use_1d_color_correction must be bool'
    assert(not color_correction is None)
    assert isinstance(color_correction, RID), 'color_correction must be RID'












    self._ptr.call_with_return(370,tuple([env._ptr, enable, brightness, contrast, saturation, use_1d_color_correction, color_correction._ptr]))

  @functools.native_method
  def environment_set_ssr(self, env:'RID'   , enable:'bool'   , max_steps:'int'   , fade_in:'float'   , fade_out:'float'   , depth_tolerance:'float'   ) -> None:
    r'''
				Sets the variables to be used with the screen-space reflections (SSR) post-process effect. See `Environment` for more details.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(max_steps, (int, float)), 'max_steps must be int or float'
    assert isinstance(fade_in, (int, float)), 'fade_in must be int or float'
    assert isinstance(fade_out, (int, float)), 'fade_out must be int or float'
    assert isinstance(depth_tolerance, (int, float)), 'depth_tolerance must be int or float'











    self._ptr.call_with_return(371,tuple([env._ptr, enable, max_steps, fade_in, fade_out, depth_tolerance]))

  @functools.native_method
  def environment_set_ssao(self, env:'RID'   , enable:'bool'   , radius:'float'   , intensity:'float'   , power:'float'   , detail:'float'   , horizon:'float'   , sharpness:'float'   , light_affect:'float'   , ao_channel_affect:'float'   ) -> None:
    r'''
				Sets the variables to be used with the screen-space ambient occlusion (SSAO) post-process effect. See `Environment` for more details.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(radius, (int, float)), 'radius must be int or float'
    assert isinstance(intensity, (int, float)), 'intensity must be int or float'
    assert isinstance(power, (int, float)), 'power must be int or float'
    assert isinstance(detail, (int, float)), 'detail must be int or float'
    assert isinstance(horizon, (int, float)), 'horizon must be int or float'
    assert isinstance(sharpness, (int, float)), 'sharpness must be int or float'
    assert isinstance(light_affect, (int, float)), 'light_affect must be int or float'
    assert isinstance(ao_channel_affect, (int, float)), 'ao_channel_affect must be int or float'















    self._ptr.call_with_return(372,tuple([env._ptr, enable, radius, intensity, power, detail, horizon, sharpness, light_affect, ao_channel_affect]))

  @functools.native_method
  def environment_set_fog(self, env:'RID'   , enable:'bool'   , light_color:'Color'   , light_energy:'float'   , sun_scatter:'float'   , density:'float'   , height:'float'   , height_density:'float'   , aerial_perspective:'float'   , sky_affect:'float'   , fog_mode:'int'  =0) -> None:
    r'''
				Configures fog for the specified environment RID. See `fog_*` properties in `Environment` for more information.
			'''



    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert(not light_color is None)
    assert isinstance(light_color, Color), 'light_color must be Color'
    assert isinstance(light_energy, (int, float)), 'light_energy must be int or float'
    assert isinstance(sun_scatter, (int, float)), 'sun_scatter must be int or float'
    assert isinstance(density, (int, float)), 'density must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(height_density, (int, float)), 'height_density must be int or float'
    assert isinstance(aerial_perspective, (int, float)), 'aerial_perspective must be int or float'
    assert isinstance(sky_affect, (int, float)), 'sky_affect must be int or float'
    assert isinstance(fog_mode, (int, float)), 'fog_mode must be int or float'
















    self._ptr.call_with_return(373,tuple([env._ptr, enable, light_color._ptr, light_energy, sun_scatter, density, height, height_density, aerial_perspective, sky_affect, fog_mode]))

  @functools.native_method
  def environment_set_fog_depth(self, env:'RID'   , curve:'float'   , begin:'float'   , end:'float'   ) -> None:
    r'''
				Configures fog depth for the specified environment RID. Only has an effect when the fog mode of the environment is `constant ENV_FOG_MODE_DEPTH`. See `fog_depth_*` properties in `Environment` for more information.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(curve, (int, float)), 'curve must be int or float'
    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'









    self._ptr.call_with_return(374,tuple([env._ptr, curve, begin, end]))

  @functools.native_method
  def environment_set_sdfgi(self, env:'RID'   , enable:'bool'   , cascades:'int'   , min_cell_size:'float'   , y_scale:'int'  , use_occlusion:'bool'   , bounce_feedback:'float'   , read_sky:'bool'   , energy:'float'   , normal_bias:'float'   , probe_bias:'float'   ) -> None:
    r'''
				Configures signed distance field global illumination for the specified environment RID. See `sdfgi_*` properties in `Environment` for more information.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(cascades, (int, float)), 'cascades must be int or float'
    assert isinstance(min_cell_size, (int, float)), 'min_cell_size must be int or float'
    assert isinstance(y_scale, (int, float)), 'y_scale must be int or float'
    assert isinstance(use_occlusion, bool), 'use_occlusion must be bool'
    assert isinstance(bounce_feedback, (int, float)), 'bounce_feedback must be int or float'
    assert isinstance(read_sky, bool), 'read_sky must be bool'
    assert isinstance(energy, (int, float)), 'energy must be int or float'
    assert isinstance(normal_bias, (int, float)), 'normal_bias must be int or float'
    assert isinstance(probe_bias, (int, float)), 'probe_bias must be int or float'
















    self._ptr.call_with_return(375,tuple([env._ptr, enable, cascades, min_cell_size, y_scale, use_occlusion, bounce_feedback, read_sky, energy, normal_bias, probe_bias]))

  @functools.native_method
  def environment_set_volumetric_fog(self, env:'RID'   , enable:'bool'   , density:'float'   , albedo:'Color'   , emission:'Color'   , emission_energy:'float'   , anisotropy:'float'   , length:'float'   , p_detail_spread:'float'   , gi_inject:'float'   , temporal_reprojection:'bool'   , temporal_reprojection_amount:'float'   , ambient_inject:'float'   , sky_affect:'float'   ) -> None:
    r'''
				Sets the variables to be used with the volumetric fog post-process effect. See `Environment` for more details.
			'''

    assert(not env is None)
    assert isinstance(env, RID), 'env must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(density, (int, float)), 'density must be int or float'
    assert(not albedo is None)
    assert isinstance(albedo, Color), 'albedo must be Color'
    assert(not emission is None)
    assert isinstance(emission, Color), 'emission must be Color'
    assert isinstance(emission_energy, (int, float)), 'emission_energy must be int or float'
    assert isinstance(anisotropy, (int, float)), 'anisotropy must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'
    assert isinstance(p_detail_spread, (int, float)), 'p_detail_spread must be int or float'
    assert isinstance(gi_inject, (int, float)), 'gi_inject must be int or float'
    assert isinstance(temporal_reprojection, bool), 'temporal_reprojection must be bool'
    assert isinstance(temporal_reprojection_amount, (int, float)), 'temporal_reprojection_amount must be int or float'
    assert isinstance(ambient_inject, (int, float)), 'ambient_inject must be int or float'
    assert isinstance(sky_affect, (int, float)), 'sky_affect must be int or float'



















    self._ptr.call_with_return(376,tuple([env._ptr, enable, density, albedo._ptr, emission._ptr, emission_energy, anisotropy, length, p_detail_spread, gi_inject, temporal_reprojection, temporal_reprojection_amount, ambient_inject, sky_affect]))

  @functools.native_method
  def environment_glow_set_use_bicubic_upscale(self, enable:'bool'   ) -> None:
    r'''
				If `enable` is `true`, enables bicubic upscaling for glow which improves quality at the cost of performance. Equivalent to `ProjectSettings.rendering/environment/glow/upscale_mode`.
				**Note:** This setting is only effective when using the Forward+ or Mobile rendering methods, as Compatibility uses a different glow implementation.
			'''

    assert isinstance(enable, bool), 'enable must be bool'






    self._ptr.call_with_return(377,tuple([enable]))

  @functools.native_method
  def environment_set_ssr_roughness_quality(self, quality:'int'  ) -> None:
    r'''
'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'






    self._ptr.call_with_return(378,tuple([quality]))

  @functools.native_method
  def environment_set_ssao_quality(self, quality:'int'  , half_size:'bool'   , adaptive_target:'float'   , blur_passes:'int'   , fadeout_from:'float'   , fadeout_to:'float'   ) -> None:
    r'''
				Sets the quality level of the screen-space ambient occlusion (SSAO) post-process effect. See `Environment` for more details.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'
    assert isinstance(half_size, bool), 'half_size must be bool'
    assert isinstance(adaptive_target, (int, float)), 'adaptive_target must be int or float'
    assert isinstance(blur_passes, (int, float)), 'blur_passes must be int or float'
    assert isinstance(fadeout_from, (int, float)), 'fadeout_from must be int or float'
    assert isinstance(fadeout_to, (int, float)), 'fadeout_to must be int or float'











    self._ptr.call_with_return(379,tuple([quality, half_size, adaptive_target, blur_passes, fadeout_from, fadeout_to]))

  @functools.native_method
  def environment_set_ssil_quality(self, quality:'int'  , half_size:'bool'   , adaptive_target:'float'   , blur_passes:'int'   , fadeout_from:'float'   , fadeout_to:'float'   ) -> None:
    r'''
				Sets the quality level of the screen-space indirect lighting (SSIL) post-process effect. See `Environment` for more details.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'
    assert isinstance(half_size, bool), 'half_size must be bool'
    assert isinstance(adaptive_target, (int, float)), 'adaptive_target must be int or float'
    assert isinstance(blur_passes, (int, float)), 'blur_passes must be int or float'
    assert isinstance(fadeout_from, (int, float)), 'fadeout_from must be int or float'
    assert isinstance(fadeout_to, (int, float)), 'fadeout_to must be int or float'











    self._ptr.call_with_return(380,tuple([quality, half_size, adaptive_target, blur_passes, fadeout_from, fadeout_to]))

  @functools.native_method
  def environment_set_sdfgi_ray_count(self, ray_count:'int'  ) -> None:
    r'''
				Sets the number of rays to throw per frame when computing signed distance field global illumination. Equivalent to `ProjectSettings.rendering/global_illumination/sdfgi/probe_ray_count`.
			'''

    assert isinstance(ray_count, (int, float)), 'ray_count must be int or float'






    self._ptr.call_with_return(381,tuple([ray_count]))

  @functools.native_method
  def environment_set_sdfgi_frames_to_converge(self, frames:'int'  ) -> None:
    r'''
				Sets the number of frames to use for converging signed distance field global illumination. Equivalent to `ProjectSettings.rendering/global_illumination/sdfgi/frames_to_converge`.
			'''

    assert isinstance(frames, (int, float)), 'frames must be int or float'






    self._ptr.call_with_return(382,tuple([frames]))

  @functools.native_method
  def environment_set_sdfgi_frames_to_update_light(self, frames:'int'  ) -> None:
    r'''
				Sets the update speed for dynamic lights' indirect lighting when computing signed distance field global illumination. Equivalent to `ProjectSettings.rendering/global_illumination/sdfgi/frames_to_update_lights`.
			'''

    assert isinstance(frames, (int, float)), 'frames must be int or float'






    self._ptr.call_with_return(383,tuple([frames]))

  @functools.native_method
  def environment_set_volumetric_fog_volume_size(self, size:'int'   , depth:'int'   ) -> None:
    r'''
				Sets the resolution of the volumetric fog's froxel buffer. `size` is modified by the screen's aspect ratio and then used to set the width and height of the buffer. While `depth` is directly used to set the depth of the buffer.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(depth, (int, float)), 'depth must be int or float'







    self._ptr.call_with_return(384,tuple([size, depth]))

  @functools.native_method
  def environment_set_volumetric_fog_filter_active(self, active:'bool'   ) -> None:
    r'''
				Enables filtering of the volumetric fog scattering buffer. This results in much smoother volumes with very few under-sampling artifacts.
			'''

    assert isinstance(active, bool), 'active must be bool'






    self._ptr.call_with_return(385,tuple([active]))

  @functools.native_method
  def environment_bake_panorama(self, environment:'RID'   , bake_irradiance:'bool'   , size:'Vector2i'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Generates and returns an `Image` containing the radiance map for the specified `environment` RID's sky. This supports built-in sky material and custom sky shaders. If `bake_irradiance` is `true`, the irradiance map is saved instead of the radiance map. The radiance map is used to render reflected light, while the irradiance map is used to render ambient light. See also `sky_bake_panorama`.
				**Note:** The image is saved using linear encoding without any tonemapping performed, which means it will look too dark if viewed directly in an image editor.
				**Note:** `size` should be a 2:1 aspect ratio for the generated panorama to have square pixels. For radiance maps, there is no point in using a height greater than `Sky.radiance_size`, as it won't increase detail. Irradiance maps only contain low-frequency data, so there is usually no point in going past a size of 128×64 pixels when saving an irradiance map.
			'''

    assert(not environment is None)
    assert isinstance(environment, RID), 'environment must be RID'
    assert isinstance(bake_irradiance, bool), 'bake_irradiance must be bool'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(386,tuple([environment._ptr, bake_irradiance, size._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def screen_space_roughness_limiter_set_active(self, enable:'bool'   , amount:'float'   , limit:'float'   ) -> None:
    r'''
				Sets the screen-space roughness limiter parameters, such as whether it should be enabled and its thresholds. Equivalent to `ProjectSettings.rendering/anti_aliasing/screen_space_roughness_limiter/enabled`, `ProjectSettings.rendering/anti_aliasing/screen_space_roughness_limiter/amount` and `ProjectSettings.rendering/anti_aliasing/screen_space_roughness_limiter/limit`.
			'''

    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(amount, (int, float)), 'amount must be int or float'
    assert isinstance(limit, (int, float)), 'limit must be int or float'








    self._ptr.call_with_return(387,tuple([enable, amount, limit]))

  @functools.native_method
  def sub_surface_scattering_set_quality(self, quality:'int'  ) -> None:
    r'''
				Sets `ProjectSettings.rendering/environment/subsurface_scattering/subsurface_scattering_quality` to use when rendering materials that have subsurface scattering enabled.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'






    self._ptr.call_with_return(388,tuple([quality]))

  @functools.native_method
  def sub_surface_scattering_set_scale(self, scale:'float'   , depth_scale:'float'   ) -> None:
    r'''
				Sets the `ProjectSettings.rendering/environment/subsurface_scattering/subsurface_scattering_scale` and `ProjectSettings.rendering/environment/subsurface_scattering/subsurface_scattering_depth_scale` to use when rendering materials that have subsurface scattering enabled.
			'''

    assert isinstance(scale, (int, float)), 'scale must be int or float'
    assert isinstance(depth_scale, (int, float)), 'depth_scale must be int or float'







    self._ptr.call_with_return(389,tuple([scale, depth_scale]))

  @functools.native_method
  def camera_attributes_create(self) -> typing.Union['RID']:
    r'''
				Creates a camera attributes object and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `camera_attributes_` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `CameraAttributes`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(390,tuple([]))
    return _ret


  @functools.native_method
  def camera_attributes_set_dof_blur_quality(self, quality:'int'  , use_jitter:'bool'   ) -> None:
    r'''
				Sets the quality level of the DOF blur effect to `quality`. `use_jitter` can be used to jitter samples taken during the blur pass to hide artifacts at the cost of looking more fuzzy.
			'''

    assert isinstance(quality, (int, float)), 'quality must be int or float'
    assert isinstance(use_jitter, bool), 'use_jitter must be bool'







    self._ptr.call_with_return(391,tuple([quality, use_jitter]))

  @functools.native_method
  def camera_attributes_set_dof_blur_bokeh_shape(self, shape:'int'  ) -> None:
    r'''
				Sets the shape of the DOF bokeh pattern to `shape`. Different shapes may be used to achieve artistic effect, or to meet performance targets.
			'''

    assert isinstance(shape, (int, float)), 'shape must be int or float'






    self._ptr.call_with_return(392,tuple([shape]))

  @functools.native_method
  def camera_attributes_set_dof_blur(self, camera_attributes:'RID'   , far_enable:'bool'   , far_distance:'float'   , far_transition:'float'   , near_enable:'bool'   , near_distance:'float'   , near_transition:'float'   , amount:'float'   ) -> None:
    r'''
				Sets the parameters to use with the DOF blur effect. These parameters take on the same meaning as their counterparts in `CameraAttributesPractical`.
			'''

    assert(not camera_attributes is None)
    assert isinstance(camera_attributes, RID), 'camera_attributes must be RID'
    assert isinstance(far_enable, bool), 'far_enable must be bool'
    assert isinstance(far_distance, (int, float)), 'far_distance must be int or float'
    assert isinstance(far_transition, (int, float)), 'far_transition must be int or float'
    assert isinstance(near_enable, bool), 'near_enable must be bool'
    assert isinstance(near_distance, (int, float)), 'near_distance must be int or float'
    assert isinstance(near_transition, (int, float)), 'near_transition must be int or float'
    assert isinstance(amount, (int, float)), 'amount must be int or float'













    self._ptr.call_with_return(393,tuple([camera_attributes._ptr, far_enable, far_distance, far_transition, near_enable, near_distance, near_transition, amount]))

  @functools.native_method
  def camera_attributes_set_exposure(self, camera_attributes:'RID'   , multiplier:'float'   , normalization:'float'   ) -> None:
    r'''
				Sets the exposure values that will be used by the renderers. The normalization amount is used to bake a given Exposure Value (EV) into rendering calculations to reduce the dynamic range of the scene.
				The normalization factor can be calculated from exposure value (EV100) as follows:
				```gdscript
				func get_exposure_normalization(ev100: float):
					return 1.0 / (pow(2.0, ev100) * 1.2)
				```
				The exposure value can be calculated from aperture (in f-stops), shutter speed (in seconds), and sensitivity (in ISO) as follows:
				```gdscript
				func get_exposure(aperture: float, shutter_speed: float, sensitivity: float):
					return log((aperture * aperture) / shutter_speed * (100.0 / sensitivity)) / log(2)
				```
			'''

    assert(not camera_attributes is None)
    assert isinstance(camera_attributes, RID), 'camera_attributes must be RID'
    assert isinstance(multiplier, (int, float)), 'multiplier must be int or float'
    assert isinstance(normalization, (int, float)), 'normalization must be int or float'








    self._ptr.call_with_return(394,tuple([camera_attributes._ptr, multiplier, normalization]))

  @functools.native_method
  def camera_attributes_set_auto_exposure(self, camera_attributes:'RID'   , enable:'bool'   , min_sensitivity:'float'   , max_sensitivity:'float'   , speed:'float'   , scale:'float'   ) -> None:
    r'''
				Sets the parameters to use with the auto-exposure effect. These parameters take on the same meaning as their counterparts in `CameraAttributes` and `CameraAttributesPractical`.
			'''

    assert(not camera_attributes is None)
    assert isinstance(camera_attributes, RID), 'camera_attributes must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(min_sensitivity, (int, float)), 'min_sensitivity must be int or float'
    assert isinstance(max_sensitivity, (int, float)), 'max_sensitivity must be int or float'
    assert isinstance(speed, (int, float)), 'speed must be int or float'
    assert isinstance(scale, (int, float)), 'scale must be int or float'











    self._ptr.call_with_return(395,tuple([camera_attributes._ptr, enable, min_sensitivity, max_sensitivity, speed, scale]))

  @functools.native_method
  def scenario_create(self) -> typing.Union['RID']:
    r'''
				Creates a scenario and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `scenario_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				The scenario is the 3D world that all the visual instances exist in.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(396,tuple([]))
    return _ret


  @functools.native_method
  def scenario_set_environment(self, scenario:'RID'   , environment:'RID'   ) -> None:
    r'''
				Sets the environment that will be used with this scenario. See also `Environment`.
			'''

    assert(not scenario is None)
    assert isinstance(scenario, RID), 'scenario must be RID'
    assert(not environment is None)
    assert isinstance(environment, RID), 'environment must be RID'







    self._ptr.call_with_return(397,tuple([scenario._ptr, environment._ptr]))

  @functools.native_method
  def scenario_set_fallback_environment(self, scenario:'RID'   , environment:'RID'   ) -> None:
    r'''
				Sets the fallback environment to be used by this scenario. The fallback environment is used if no environment is set. Internally, this is used by the editor to provide a default environment.
			'''

    assert(not scenario is None)
    assert isinstance(scenario, RID), 'scenario must be RID'
    assert(not environment is None)
    assert isinstance(environment, RID), 'environment must be RID'







    self._ptr.call_with_return(398,tuple([scenario._ptr, environment._ptr]))

  @functools.native_method
  def scenario_set_camera_attributes(self, scenario:'RID'   , effects:'RID'   ) -> None:
    r'''
				Sets the camera attributes (`effects`) that will be used with this scenario. See also `CameraAttributes`.
			'''

    assert(not scenario is None)
    assert isinstance(scenario, RID), 'scenario must be RID'
    assert(not effects is None)
    assert isinstance(effects, RID), 'effects must be RID'







    self._ptr.call_with_return(399,tuple([scenario._ptr, effects._ptr]))

  @functools.native_method
  def scenario_set_compositor(self, scenario:'RID'   , compositor:'RID'   ) -> None:
    r'''
				Sets the compositor (`compositor`) that will be used with this scenario. See also `Compositor`.
			'''

    assert(not scenario is None)
    assert isinstance(scenario, RID), 'scenario must be RID'
    assert(not compositor is None)
    assert isinstance(compositor, RID), 'compositor must be RID'







    self._ptr.call_with_return(400,tuple([scenario._ptr, compositor._ptr]))

  @functools.native_method
  def instance_create2(self, base:'RID'   , scenario:'RID'   ) -> typing.Union['RID']:
    r'''
				Creates a visual instance, adds it to the RenderingServer, and sets both base and scenario. It can be accessed with the RID that is returned. This RID will be used in all `instance_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method. This is a shorthand for using `instance_create` and setting the base and scenario manually.
			'''

    assert(not base is None)
    assert isinstance(base, RID), 'base must be RID'
    assert(not scenario is None)
    assert isinstance(scenario, RID), 'scenario must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(401,tuple([base._ptr, scenario._ptr]))
    return _ret


  @functools.native_method
  def instance_create(self) -> typing.Union['RID']:
    r'''
				Creates a visual instance and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `instance_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				An instance is a way of placing a 3D object in the scenario. Objects like particles, meshes, reflection probes and decals need to be associated with an instance to be visible in the scenario using `instance_set_base`.
				**Note:** The equivalent node is `VisualInstance3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(402,tuple([]))
    return _ret


  @functools.native_method
  def instance_set_base(self, instance:'RID'   , base:'RID'   ) -> None:
    r'''
				Sets the base of the instance. A base can be any of the 3D objects that are created in the RenderingServer that can be displayed. For example, any of the light types, mesh, multimesh, particle system, reflection probe, decal, lightmap, voxel GI and visibility notifiers are all types that can be set as the base of an instance in order to be displayed in the scenario.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not base is None)
    assert isinstance(base, RID), 'base must be RID'







    self._ptr.call_with_return(403,tuple([instance._ptr, base._ptr]))

  @functools.native_method
  def instance_set_scenario(self, instance:'RID'   , scenario:'RID'   ) -> None:
    r'''
				Sets the scenario that the instance is in. The scenario is the 3D world that the objects will be displayed in.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not scenario is None)
    assert isinstance(scenario, RID), 'scenario must be RID'







    self._ptr.call_with_return(404,tuple([instance._ptr, scenario._ptr]))

  @functools.native_method
  def instance_set_layer_mask(self, instance:'RID'   , mask:'int'   ) -> None:
    r'''
				Sets the render layers that this instance will be drawn to. Equivalent to `VisualInstance3D.layers`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(405,tuple([instance._ptr, mask]))

  @functools.native_method
  def instance_set_pivot_data(self, instance:'RID'   , sorting_offset:'float'   , use_aabb_center:'bool'   ) -> None:
    r'''
				Sets the sorting offset and switches between using the bounding box or instance origin for depth sorting.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(sorting_offset, (int, float)), 'sorting_offset must be int or float'
    assert isinstance(use_aabb_center, bool), 'use_aabb_center must be bool'








    self._ptr.call_with_return(406,tuple([instance._ptr, sorting_offset, use_aabb_center]))

  @functools.native_method
  def instance_set_transform(self, instance:'RID'   , transform:'Transform3D'   ) -> None:
    r'''
				Sets the world space transform of the instance. Equivalent to `Node3D.global_transform`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'







    self._ptr.call_with_return(407,tuple([instance._ptr, transform._ptr]))

  @functools.native_method
  def instance_attach_object_instance_id(self, instance:'RID'   , id:'int'   ) -> None:
    r'''
				Attaches a unique Object ID to instance. Object ID must be attached to instance for proper culling with `instances_cull_aabb`, `instances_cull_convex`, and `instances_cull_ray`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'







    self._ptr.call_with_return(408,tuple([instance._ptr, id]))

  @functools.native_method
  def instance_set_blend_shape_weight(self, instance:'RID'   , shape:'int'   , weight:'float'   ) -> None:
    r'''
				Sets the weight for a given blend shape associated with this instance.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(shape, (int, float)), 'shape must be int or float'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    self._ptr.call_with_return(409,tuple([instance._ptr, shape, weight]))

  @functools.native_method
  def instance_set_surface_override_material(self, instance:'RID'   , surface:'int'   , material:'RID'   ) -> None:
    r'''
				Sets the override material of a specific surface. Equivalent to `MeshInstance3D.set_surface_override_material`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'








    self._ptr.call_with_return(410,tuple([instance._ptr, surface, material._ptr]))

  @functools.native_method
  def instance_set_visible(self, instance:'RID'   , visible:'bool'   ) -> None:
    r'''
				Sets whether an instance is drawn or not. Equivalent to `Node3D.visible`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(visible, bool), 'visible must be bool'







    self._ptr.call_with_return(411,tuple([instance._ptr, visible]))

  @functools.native_method
  def instance_geometry_set_transparency(self, instance:'RID'   , transparency:'float'   ) -> None:
    r'''
				Sets the transparency for the given geometry instance. Equivalent to `GeometryInstance3D.transparency`.
				A transparency of `0.0` is fully opaque, while `1.0` is fully transparent. Values greater than `0.0` (exclusive) will force the geometry's materials to go through the transparent pipeline, which is slower to render and can exhibit rendering issues due to incorrect transparency sorting. However, unlike using a transparent material, setting `transparency` to a value greater than `0.0` (exclusive) will _not_ disable shadow rendering.
				In spatial shaders, `1.0 - transparency` is set as the default value of the `ALPHA` built-in.
				**Note:** `transparency` is clamped between `0.0` and `1.0`, so this property cannot be used to make transparent materials more opaque than they originally are.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(transparency, (int, float)), 'transparency must be int or float'







    self._ptr.call_with_return(412,tuple([instance._ptr, transparency]))

  @functools.native_method
  def instance_teleport(self, instance:'RID'   ) -> None:
    r'''
				Resets motion vectors and other interpolated values. Use this _after_ teleporting a mesh from one position to another to avoid ghosting artifacts.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'






    self._ptr.call_with_return(413,tuple([instance._ptr]))

  @functools.native_method
  def instance_set_custom_aabb(self, instance:'RID'   , aabb:'AABB'   ) -> None:
    r'''
				Sets a custom AABB to use when culling objects from the view frustum. Equivalent to setting `GeometryInstance3D.custom_aabb`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    self._ptr.call_with_return(414,tuple([instance._ptr, aabb._ptr]))

  @functools.native_method
  def instance_attach_skeleton(self, instance:'RID'   , skeleton:'RID'   ) -> None:
    r'''
				Attaches a skeleton to an instance. Removes the previous skeleton from the instance.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'







    self._ptr.call_with_return(415,tuple([instance._ptr, skeleton._ptr]))

  @functools.native_method
  def instance_set_extra_visibility_margin(self, instance:'RID'   , margin:'float'   ) -> None:
    r'''
				Sets a margin to increase the size of the AABB when culling objects from the view frustum. This allows you to avoid culling objects that fall outside the view frustum. Equivalent to `GeometryInstance3D.extra_cull_margin`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(margin, (int, float)), 'margin must be int or float'







    self._ptr.call_with_return(416,tuple([instance._ptr, margin]))

  @functools.native_method
  def instance_set_visibility_parent(self, instance:'RID'   , parent:'RID'   ) -> None:
    r'''
				Sets the visibility parent for the given instance. Equivalent to `Node3D.visibility_parent`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not parent is None)
    assert isinstance(parent, RID), 'parent must be RID'







    self._ptr.call_with_return(417,tuple([instance._ptr, parent._ptr]))

  @functools.native_method
  def instance_set_ignore_culling(self, instance:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, ignores both frustum and occlusion culling on the specified 3D geometry instance. This is not the same as `GeometryInstance3D.ignore_occlusion_culling`, which only ignores occlusion culling and leaves frustum culling intact.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(418,tuple([instance._ptr, enabled]))

  @functools.native_method
  def instance_geometry_set_flag(self, instance:'RID'   , flag:'int'  , enabled:'bool'   ) -> None:
    r'''
				Sets the `flag` for a given `instance` to `enabled`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(419,tuple([instance._ptr, flag, enabled]))

  @functools.native_method
  def instance_geometry_set_cast_shadows_setting(self, instance:'RID'   , shadow_casting_setting:'int'  ) -> None:
    r'''
				Sets the shadow casting setting. Equivalent to `GeometryInstance3D.cast_shadow`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(shadow_casting_setting, (int, float)), 'shadow_casting_setting must be int or float'







    self._ptr.call_with_return(420,tuple([instance._ptr, shadow_casting_setting]))

  @functools.native_method
  def instance_geometry_set_material_override(self, instance:'RID'   , material:'RID'   ) -> None:
    r'''
				Sets a material that will override the material for all surfaces on the mesh associated with this instance. Equivalent to `GeometryInstance3D.material_override`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'







    self._ptr.call_with_return(421,tuple([instance._ptr, material._ptr]))

  @functools.native_method
  def instance_geometry_set_material_overlay(self, instance:'RID'   , material:'RID'   ) -> None:
    r'''
				Sets a material that will be rendered for all surfaces on top of active materials for the mesh associated with this instance. Equivalent to `GeometryInstance3D.material_overlay`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'







    self._ptr.call_with_return(422,tuple([instance._ptr, material._ptr]))

  @functools.native_method
  def instance_geometry_set_visibility_range(self, instance:'RID'   , min:'float'   , max:'float'   , min_margin:'float'   , max_margin:'float'   , fade_mode:'int'  ) -> None:
    r'''
				Sets the visibility range values for the given geometry instance. Equivalent to `GeometryInstance3D.visibility_range_begin` and related properties.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'
    assert isinstance(min_margin, (int, float)), 'min_margin must be int or float'
    assert isinstance(max_margin, (int, float)), 'max_margin must be int or float'
    assert isinstance(fade_mode, (int, float)), 'fade_mode must be int or float'











    self._ptr.call_with_return(423,tuple([instance._ptr, min, max, min_margin, max_margin, fade_mode]))

  @functools.native_method
  def instance_geometry_set_lightmap(self, instance:'RID'   , lightmap:'RID'   , lightmap_uv_scale:'Rect2'   , lightmap_slice:'int'   ) -> None:
    r'''
				Sets the lightmap GI instance to use for the specified 3D geometry instance. The lightmap UV scale for the specified instance (equivalent to `GeometryInstance3D.gi_lightmap_scale`) and lightmap atlas slice must also be specified.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not lightmap is None)
    assert isinstance(lightmap, RID), 'lightmap must be RID'
    assert(not lightmap_uv_scale is None)
    assert isinstance(lightmap_uv_scale, Rect2), 'lightmap_uv_scale must be Rect2'
    assert isinstance(lightmap_slice, (int, float)), 'lightmap_slice must be int or float'









    self._ptr.call_with_return(424,tuple([instance._ptr, lightmap._ptr, lightmap_uv_scale._ptr, lightmap_slice]))

  @functools.native_method
  def instance_geometry_set_lod_bias(self, instance:'RID'   , lod_bias:'float'   ) -> None:
    r'''
				Sets the level of detail bias to use when rendering the specified 3D geometry instance. Higher values result in higher detail from further away. Equivalent to `GeometryInstance3D.lod_bias`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert isinstance(lod_bias, (int, float)), 'lod_bias must be int or float'







    self._ptr.call_with_return(425,tuple([instance._ptr, lod_bias]))

  @functools.native_method
  def instance_geometry_set_shader_parameter(self, instance:'RID'   , parameter:'object'   , value:'object'   ) -> None:
    r'''
				Sets the per-instance shader uniform on the specified 3D geometry instance. Equivalent to `GeometryInstance3D.set_instance_shader_parameter`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'
    





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)


    self._ptr.call_with_return(426,tuple([instance._ptr, py_stringname_parameter._ptr, value]))

  @functools.native_method
  def instance_geometry_get_shader_parameter(self, instance:'RID'   , parameter:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of the per-instance shader uniform from the specified 3D geometry instance. Equivalent to `GeometryInstance3D.get_instance_shader_parameter`.
				**Note:** Per-instance shader parameter names are case-sensitive.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)

    _ret = None
    _ret = self._ptr.call_with_return(427,tuple([instance._ptr, py_stringname_parameter._ptr]))
    return _ret


  @functools.native_method
  def instance_geometry_get_shader_parameter_default_value(self, instance:'RID'   , parameter:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the default value of the per-instance shader uniform from the specified 3D geometry instance. Equivalent to `GeometryInstance3D.get_instance_shader_parameter`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)

    _ret = None
    _ret = self._ptr.call_with_return(428,tuple([instance._ptr, py_stringname_parameter._ptr]))
    return _ret


  @functools.native_method
  def instance_geometry_get_shader_parameter_list(self, instance:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns a dictionary of per-instance shader uniform names of the per-instance shader uniform from the specified 3D geometry instance. The returned dictionary is in PropertyInfo format, with the keys `name`, `class_name`, `type`, `hint`, `hint_string` and `usage`. Equivalent to `GeometryInstance3D.get_instance_shader_parameter`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'






    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(429,tuple([instance._ptr]))
    return _ret


  @functools.native_method
  def instances_cull_aabb(self, aabb:'AABB'   , scenario:'RID' = None  ) -> typing.Union['PackedInt64Array']:
    r'''
				Returns an array of object IDs intersecting with the provided AABB. Only 3D nodes that inherit from `VisualInstance3D` are considered, such as `MeshInstance3D` or `DirectionalLight3D`. Use `@GlobalScope.instance_from_id` to obtain the actual nodes. A scenario RID must be provided, which is available in the `World3D` you want to query. This forces an update for all resources queued to update.
				**Warning:** This function is primarily intended for editor usage. For in-game use cases, prefer physics collision.
			'''
    if scenario is None:
      scenario = RID.new0()
    if scenario is None:
      scenario = RID.new0()

    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(430,tuple([aabb._ptr, scenario._ptr]))
    return _ret


  @functools.native_method
  def instances_cull_ray(self, from_:'Vector3'   , to:'Vector3'   , scenario:'RID' = None  ) -> typing.Union['PackedInt64Array']:
    r'''
				Returns an array of object IDs intersecting with the provided 3D ray. Only 3D nodes that inherit from `VisualInstance3D` are considered, such as `MeshInstance3D` or `DirectionalLight3D`. Use `@GlobalScope.instance_from_id` to obtain the actual nodes. A scenario RID must be provided, which is available in the `World3D` you want to query. This forces an update for all resources queued to update.
				**Warning:** This function is primarily intended for editor usage. For in-game use cases, prefer physics collision.
			'''
    if scenario is None:
      scenario = RID.new0()
    if scenario is None:
      scenario = RID.new0()

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'








    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(431,tuple([from_._ptr, to._ptr, scenario._ptr]))
    return _ret


  @functools.native_method
  def instances_cull_convex(self, convex:'py4godot_planetypedarray.PlaneTypedArray'   , scenario:'RID' = None  ) -> typing.Union['PackedInt64Array']:
    r'''
				Returns an array of object IDs intersecting with the provided convex shape. Only 3D nodes that inherit from `VisualInstance3D` are considered, such as `MeshInstance3D` or `DirectionalLight3D`. Use `@GlobalScope.instance_from_id` to obtain the actual nodes. A scenario RID must be provided, which is available in the `World3D` you want to query. This forces an update for all resources queued to update.
				**Warning:** This function is primarily intended for editor usage. For in-game use cases, prefer physics collision.
			'''
    if scenario is None:
      scenario = RID.new0()
    if scenario is None:
      scenario = RID.new0()

    assert isinstance(convex, get_class('PlaneTypedArray')), 'convex must be PlaneTypedArray'







    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(432,tuple([convex._ptr, scenario._ptr]))
    return _ret


  @functools.native_method
  def bake_render_uv2(self, base:'RID'   , material_overrides:'py4godot_ridtypedarray.RIDTypedArray'   , image_size:'Vector2i'   ) -> typing.Union['py4godot_imagetypedarray.ImageTypedArray']:
    r'''
				Bakes the material data of the Mesh passed in the `base` parameter with optional `material_overrides` to a set of `Image`s of size `image_size`. Returns an array of `Image`s containing material properties as specified in `enum BakeChannels`.
			'''

    assert(not base is None)
    assert isinstance(base, RID), 'base must be RID'
    assert isinstance(material_overrides, get_class('RIDTypedArray')), 'material_overrides must be RIDTypedArray'
    assert(not image_size is None)
    assert isinstance(image_size, Vector2i), 'image_size must be Vector2i'








    _ret = py4godot_imagetypedarray.ImageTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(433,tuple([base._ptr, material_overrides._ptr, image_size._ptr]))
    return _ret


  @functools.native_method
  def canvas_create(self) -> typing.Union['RID']:
    r'''
				Creates a canvas and returns the assigned `RID`. It can be accessed with the RID that is returned. This RID will be used in all `canvas_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				Canvas has no `Resource` or `Node` equivalent.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(434,tuple([]))
    return _ret


  @functools.native_method
  def canvas_set_item_mirroring(self, canvas:'RID'   , item:'RID'   , mirroring:'Vector2'   ) -> None:
    r'''
				A copy of the canvas item will be drawn with a local offset of the `mirroring`.
				**Note:** This is equivalent to calling `canvas_set_item_repeat` like `canvas_set_item_repeat(item, mirroring, 1)`, with an additional check ensuring `canvas` is a parent of `item`.
			'''

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not mirroring is None)
    assert isinstance(mirroring, Vector2), 'mirroring must be Vector2'








    self._ptr.call_with_return(435,tuple([canvas._ptr, item._ptr, mirroring._ptr]))

  @functools.native_method
  def canvas_set_item_repeat(self, item:'RID'   , repeat_size:'Vector2'   , repeat_times:'int'   ) -> None:
    r'''
				A copy of the canvas item will be drawn with a local offset of the `repeat_size` by the number of times of the `repeat_times`. As the `repeat_times` increases, the copies will spread away from the origin texture.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not repeat_size is None)
    assert isinstance(repeat_size, Vector2), 'repeat_size must be Vector2'
    assert isinstance(repeat_times, (int, float)), 'repeat_times must be int or float'








    self._ptr.call_with_return(436,tuple([item._ptr, repeat_size._ptr, repeat_times]))

  @functools.native_method
  def canvas_set_modulate(self, canvas:'RID'   , color:'Color'   ) -> None:
    r'''
				Modulates all colors in the given canvas.
			'''

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(437,tuple([canvas._ptr, color._ptr]))

  @functools.native_method
  def canvas_set_disable_scale(self, disable:'bool'   ) -> None:
    r'''
'''

    assert isinstance(disable, bool), 'disable must be bool'






    self._ptr.call_with_return(438,tuple([disable]))

  @functools.native_method
  def canvas_texture_create(self) -> typing.Union['RID']:
    r'''
				Creates a canvas texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_texture_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method. See also `texture_2d_create`.
				**Note:** The equivalent resource is `CanvasTexture` and is only meant to be used in 2D rendering, not 3D.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(439,tuple([]))
    return _ret


  @functools.native_method
  def canvas_texture_set_channel(self, canvas_texture:'RID'   , channel:'int'  , texture:'RID'   ) -> None:
    r'''
				Sets the `channel`'s `texture` for the canvas texture specified by the `canvas_texture` RID. Equivalent to `CanvasTexture.diffuse_texture`, `CanvasTexture.normal_texture` and `CanvasTexture.specular_texture`.
			'''

    assert(not canvas_texture is None)
    assert isinstance(canvas_texture, RID), 'canvas_texture must be RID'
    assert isinstance(channel, (int, float)), 'channel must be int or float'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'








    self._ptr.call_with_return(440,tuple([canvas_texture._ptr, channel, texture._ptr]))

  @functools.native_method
  def canvas_texture_set_shading_parameters(self, canvas_texture:'RID'   , base_color:'Color'   , shininess:'float'   ) -> None:
    r'''
				Sets the `base_color` and `shininess` to use for the canvas texture specified by the `canvas_texture` RID. Equivalent to `CanvasTexture.specular_color` and `CanvasTexture.specular_shininess`.
			'''

    assert(not canvas_texture is None)
    assert isinstance(canvas_texture, RID), 'canvas_texture must be RID'
    assert(not base_color is None)
    assert isinstance(base_color, Color), 'base_color must be Color'
    assert isinstance(shininess, (int, float)), 'shininess must be int or float'








    self._ptr.call_with_return(441,tuple([canvas_texture._ptr, base_color._ptr, shininess]))

  @functools.native_method
  def canvas_texture_set_texture_filter(self, canvas_texture:'RID'   , filter:'int'  ) -> None:
    r'''
				Sets the texture `filter` mode to use for the canvas texture specified by the `canvas_texture` RID.
			'''

    assert(not canvas_texture is None)
    assert isinstance(canvas_texture, RID), 'canvas_texture must be RID'
    assert isinstance(filter, (int, float)), 'filter must be int or float'







    self._ptr.call_with_return(442,tuple([canvas_texture._ptr, filter]))

  @functools.native_method
  def canvas_texture_set_texture_repeat(self, canvas_texture:'RID'   , repeat:'int'  ) -> None:
    r'''
				Sets the texture `repeat` mode to use for the canvas texture specified by the `canvas_texture` RID.
			'''

    assert(not canvas_texture is None)
    assert isinstance(canvas_texture, RID), 'canvas_texture must be RID'
    assert isinstance(repeat, (int, float)), 'repeat must be int or float'







    self._ptr.call_with_return(443,tuple([canvas_texture._ptr, repeat]))

  @functools.native_method
  def canvas_item_create(self) -> typing.Union['RID']:
    r'''
				Creates a new CanvasItem instance and returns its `RID`. It can be accessed with the RID that is returned. This RID will be used in all `canvas_item_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `CanvasItem`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(444,tuple([]))
    return _ret


  @functools.native_method
  def canvas_item_set_parent(self, item:'RID'   , parent:'RID'   ) -> None:
    r'''
				Sets a parent `CanvasItem` to the `CanvasItem`. The item will inherit transform, modulation and visibility from its parent, like `CanvasItem` nodes in the scene tree.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not parent is None)
    assert isinstance(parent, RID), 'parent must be RID'







    self._ptr.call_with_return(445,tuple([item._ptr, parent._ptr]))

  @functools.native_method
  def canvas_item_set_default_texture_filter(self, item:'RID'   , filter:'int'  ) -> None:
    r'''
				Sets the default texture filter mode for the canvas item specified by the `item` RID. Equivalent to `CanvasItem.texture_filter`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(filter, (int, float)), 'filter must be int or float'







    self._ptr.call_with_return(446,tuple([item._ptr, filter]))

  @functools.native_method
  def canvas_item_set_default_texture_repeat(self, item:'RID'   , repeat:'int'  ) -> None:
    r'''
				Sets the default texture repeat mode for the canvas item specified by the `item` RID. Equivalent to `CanvasItem.texture_repeat`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(repeat, (int, float)), 'repeat must be int or float'







    self._ptr.call_with_return(447,tuple([item._ptr, repeat]))

  @functools.native_method
  def canvas_item_set_visible(self, item:'RID'   , visible:'bool'   ) -> None:
    r'''
				Sets the visibility of the `CanvasItem`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(visible, bool), 'visible must be bool'







    self._ptr.call_with_return(448,tuple([item._ptr, visible]))

  @functools.native_method
  def canvas_item_set_light_mask(self, item:'RID'   , mask:'int'   ) -> None:
    r'''
				Sets the light `mask` for the canvas item specified by the `item` RID. Equivalent to `CanvasItem.light_mask`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(449,tuple([item._ptr, mask]))

  @functools.native_method
  def canvas_item_set_visibility_layer(self, item:'RID'   , visibility_layer:'int'   ) -> None:
    r'''
				Sets the rendering visibility layer associated with this `CanvasItem`. Only `Viewport` nodes with a matching rendering mask will render this `CanvasItem`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(visibility_layer, (int, float)), 'visibility_layer must be int or float'







    self._ptr.call_with_return(450,tuple([item._ptr, visibility_layer]))

  @functools.native_method
  def canvas_item_set_transform(self, item:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets the `transform` of the canvas item specified by the `item` RID. This affects where and how the item will be drawn. Child canvas items' transforms are multiplied by their parent's transform. Equivalent to `Node2D.transform`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(451,tuple([item._ptr, transform._ptr]))

  @functools.native_method
  def canvas_item_set_clip(self, item:'RID'   , clip:'bool'   ) -> None:
    r'''
				If `clip` is `true`, makes the canvas item specified by the `item` RID not draw anything outside of its rect's coordinates. This clipping is fast, but works only with axis-aligned rectangles. This means that rotation is ignored by the clipping rectangle. For more advanced clipping shapes, use `canvas_item_set_canvas_group_mode` instead.
				**Note:** The equivalent node functionality is found in `Label.clip_text`, `RichTextLabel` (always enabled) and more.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(clip, bool), 'clip must be bool'







    self._ptr.call_with_return(452,tuple([item._ptr, clip]))

  @functools.native_method
  def canvas_item_set_distance_field_mode(self, item:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `enabled` is `true`, enables multichannel signed distance field rendering mode for the canvas item specified by the `item` RID. This is meant to be used for font rendering, or with specially generated images using `url=https://github.com/Chlumsky/msdfgen`msdfgen`/url`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(453,tuple([item._ptr, enabled]))

  @functools.native_method
  def canvas_item_set_custom_rect(self, item:'RID'   , use_custom_rect:'bool'   , rect:'Rect2' = None  ) -> None:
    r'''
				If `use_custom_rect` is `true`, sets the custom visibility rectangle (used for culling) to `rect` for the canvas item specified by `item`. Setting a custom visibility rect can reduce CPU load when drawing lots of 2D instances. If `use_custom_rect` is `false`, automatically computes a visibility rectangle based on the canvas item's draw commands.
			'''
    if rect is None:
      rect = Rect2.new0()
    if rect is None:
      rect = Rect2.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(use_custom_rect, bool), 'use_custom_rect must be bool'








    self._ptr.call_with_return(454,tuple([item._ptr, use_custom_rect, rect._ptr]))

  @functools.native_method
  def canvas_item_set_modulate(self, item:'RID'   , color:'Color'   ) -> None:
    r'''
				Multiplies the color of the canvas item specified by the `item` RID, while affecting its children. See also `canvas_item_set_self_modulate`. Equivalent to `CanvasItem.modulate`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(455,tuple([item._ptr, color._ptr]))

  @functools.native_method
  def canvas_item_set_self_modulate(self, item:'RID'   , color:'Color'   ) -> None:
    r'''
				Multiplies the color of the canvas item specified by the `item` RID, without affecting its children. See also `canvas_item_set_modulate`. Equivalent to `CanvasItem.self_modulate`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(456,tuple([item._ptr, color._ptr]))

  @functools.native_method
  def canvas_item_set_draw_behind_parent(self, item:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `enabled` is `true`, draws the canvas item specified by the `item` RID behind its parent. Equivalent to `CanvasItem.show_behind_parent`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(457,tuple([item._ptr, enabled]))

  @functools.native_method
  def canvas_item_set_interpolated(self, item:'RID'   , interpolated:'bool'   ) -> None:
    r'''
				If `interpolated` is `true`, turns on physics interpolation for the canvas item.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(interpolated, bool), 'interpolated must be bool'







    self._ptr.call_with_return(458,tuple([item._ptr, interpolated]))

  @functools.native_method
  def canvas_item_reset_physics_interpolation(self, item:'RID'   ) -> None:
    r'''
				Prevents physics interpolation for the current physics tick.
				This is useful when moving a canvas item to a new location, to give an instantaneous change rather than interpolation from the previous location.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'






    self._ptr.call_with_return(459,tuple([item._ptr]))

  @functools.native_method
  def canvas_item_transform_physics_interpolation(self, item:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Transforms both the current and previous stored transform for a canvas item.
				This allows transforming a canvas item without creating a "glitch" in the interpolation, which is particularly useful for large worlds utilizing a shifting origin.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(460,tuple([item._ptr, transform._ptr]))

  @functools.native_method
  def canvas_item_add_line(self, item:'RID'   , from_:'Vector2'   , to:'Vector2'   , color:'Color'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a line on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_line`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not from_ is None)
    assert isinstance(from_, Vector2), 'from_ must be Vector2'
    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'











    self._ptr.call_with_return(461,tuple([item._ptr, from_._ptr, to._ptr, color._ptr, width, antialiased]))

  @functools.native_method
  def canvas_item_add_polyline(self, item:'RID'   , points:'PackedVector2Array'   , colors:'PackedColorArray'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a 2D polyline on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_polyline` and `CanvasItem.draw_polyline_colors`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'










    self._ptr.call_with_return(462,tuple([item._ptr, points._ptr, colors._ptr, width, antialiased]))

  @functools.native_method
  def canvas_item_add_multiline(self, item:'RID'   , points:'PackedVector2Array'   , colors:'PackedColorArray'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a 2D multiline on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_multiline` and `CanvasItem.draw_multiline_colors`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'










    self._ptr.call_with_return(463,tuple([item._ptr, points._ptr, colors._ptr, width, antialiased]))

  @functools.native_method
  def canvas_item_add_rect(self, item:'RID'   , rect:'Rect2'   , color:'Color'   , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a rectangle on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_rect`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(antialiased, bool), 'antialiased must be bool'









    self._ptr.call_with_return(464,tuple([item._ptr, rect._ptr, color._ptr, antialiased]))

  @functools.native_method
  def canvas_item_add_circle(self, item:'RID'   , pos:'Vector2'   , radius:'float'   , color:'Color'   , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a circle on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_circle`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(radius, (int, float)), 'radius must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(antialiased, bool), 'antialiased must be bool'










    self._ptr.call_with_return(465,tuple([item._ptr, pos._ptr, radius, color._ptr, antialiased]))

  @functools.native_method
  def canvas_item_add_texture_rect(self, item:'RID'   , rect:'Rect2'   , texture:'RID'   , tile:'bool' =False  , modulate:'Color' = None  , transpose:'bool' =False  ) -> None:
    r'''
				Draws a 2D textured rectangle on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_texture_rect` and `Texture2D.draw_rect`.
			'''
    if modulate is None:
      modulate = Color.new0()
    if modulate is None:
      modulate = Color.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(tile, bool), 'tile must be bool'
    assert isinstance(transpose, bool), 'transpose must be bool'











    self._ptr.call_with_return(466,tuple([item._ptr, rect._ptr, texture._ptr, tile, modulate._ptr, transpose]))

  @functools.native_method
  def canvas_item_add_msdf_texture_rect_region(self, item:'RID'   , rect:'Rect2'   , texture:'RID'   , src_rect:'Rect2'   , modulate:'Color' = None  , outline_size:'int' =0  , px_range:'float' =1.0  , scale:'float' =1.0  ) -> None:
    r'''
				See also `CanvasItem.draw_msdf_texture_rect_region`.
			'''
    if modulate is None:
      modulate = Color.new0()
    if modulate is None:
      modulate = Color.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2), 'src_rect must be Rect2'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert isinstance(px_range, (int, float)), 'px_range must be int or float'
    assert isinstance(scale, (int, float)), 'scale must be int or float'













    self._ptr.call_with_return(467,tuple([item._ptr, rect._ptr, texture._ptr, src_rect._ptr, modulate._ptr, outline_size, px_range, scale]))

  @functools.native_method
  def canvas_item_add_lcd_texture_rect_region(self, item:'RID'   , rect:'Rect2'   , texture:'RID'   , src_rect:'Rect2'   , modulate:'Color'   ) -> None:
    r'''
				See also `CanvasItem.draw_lcd_texture_rect_region`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2), 'src_rect must be Rect2'
    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'










    self._ptr.call_with_return(468,tuple([item._ptr, rect._ptr, texture._ptr, src_rect._ptr, modulate._ptr]))

  @functools.native_method
  def canvas_item_add_texture_rect_region(self, item:'RID'   , rect:'Rect2'   , texture:'RID'   , src_rect:'Rect2'   , modulate:'Color' = None  , transpose:'bool' =False  , clip_uv:'bool' =True  ) -> None:
    r'''
				Draws the specified region of a 2D textured rectangle on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_texture_rect_region` and `Texture2D.draw_rect_region`.
			'''
    if modulate is None:
      modulate = Color.new0()
    if modulate is None:
      modulate = Color.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2), 'src_rect must be Rect2'
    assert isinstance(transpose, bool), 'transpose must be bool'
    assert isinstance(clip_uv, bool), 'clip_uv must be bool'












    self._ptr.call_with_return(469,tuple([item._ptr, rect._ptr, texture._ptr, src_rect._ptr, modulate._ptr, transpose, clip_uv]))

  @functools.native_method
  def canvas_item_add_nine_patch(self, item:'RID'   , rect:'Rect2'   , source:'Rect2'   , texture:'RID'   , topleft:'Vector2'   , bottomright:'Vector2'   , x_axis_mode:'int'  =0, y_axis_mode:'int'  =0, draw_center:'bool' =True  , modulate:'Color' = None  ) -> None:
    r'''
				Draws a nine-patch rectangle on the `CanvasItem` pointed to by the `item` `RID`.
			'''


    if modulate is None:
      modulate = Color.new0()


    if modulate is None:
      modulate = Color.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not source is None)
    assert isinstance(source, Rect2), 'source must be Rect2'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not topleft is None)
    assert isinstance(topleft, Vector2), 'topleft must be Vector2'
    assert(not bottomright is None)
    assert isinstance(bottomright, Vector2), 'bottomright must be Vector2'
    assert isinstance(x_axis_mode, (int, float)), 'x_axis_mode must be int or float'
    assert isinstance(y_axis_mode, (int, float)), 'y_axis_mode must be int or float'
    assert isinstance(draw_center, bool), 'draw_center must be bool'















    self._ptr.call_with_return(470,tuple([item._ptr, rect._ptr, source._ptr, texture._ptr, topleft._ptr, bottomright._ptr, x_axis_mode, y_axis_mode, draw_center, modulate._ptr]))

  @functools.native_method
  def canvas_item_add_primitive(self, item:'RID'   , points:'PackedVector2Array'   , colors:'PackedColorArray'   , uvs:'PackedVector2Array'   , texture:'RID'   ) -> None:
    r'''
				Draws a 2D primitive on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_primitive`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'
    assert(not uvs is None)
    assert isinstance(uvs, PackedVector2Array), 'uvs must be PackedVector2Array'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'










    self._ptr.call_with_return(471,tuple([item._ptr, points._ptr, colors._ptr, uvs._ptr, texture._ptr]))

  @functools.native_method
  def canvas_item_add_polygon(self, item:'RID'   , points:'PackedVector2Array'   , colors:'PackedColorArray'   , uvs:'PackedVector2Array' = None  , texture:'RID' = None  ) -> None:
    r'''
				Draws a 2D polygon on the `CanvasItem` pointed to by the `item` `RID`. If you need more flexibility (such as being able to use bones), use `canvas_item_add_triangle_array` instead. See also `CanvasItem.draw_polygon`.
				**Note:** If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with `Geometry2D.triangulate_polygon` and using `CanvasItem.draw_mesh`, `CanvasItem.draw_multimesh`, or `canvas_item_add_triangle_array`.
			'''
    if uvs is None:
      uvs = PackedVector2Array.new0()
    if texture is None:
      texture = RID.new0()
    if uvs is None:
      uvs = PackedVector2Array.new0()
    if texture is None:
      texture = RID.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'










    self._ptr.call_with_return(472,tuple([item._ptr, points._ptr, colors._ptr, uvs._ptr, texture._ptr]))

  @functools.native_method
  def canvas_item_add_triangle_array(self, item:'RID'   , indices:'PackedInt32Array'   , points:'PackedVector2Array'   , colors:'PackedColorArray'   , uvs:'PackedVector2Array' = None  , bones:'PackedInt32Array' = None  , weights:'PackedFloat32Array' = None  , texture:'RID' = None  , count:'int' =-1  ) -> None:
    r'''
				Draws a triangle array on the `CanvasItem` pointed to by the `item` `RID`. This is internally used by `Line2D` and `StyleBoxFlat` for rendering. `canvas_item_add_triangle_array` is highly flexible, but more complex to use than `canvas_item_add_polygon`.
				**Note:** If `count` is set to a non-negative value, only the first `count * 3` indices (corresponding to `code skip-lint`count` triangles) will be drawn. Otherwise, all indices are drawn.
			'''
    if uvs is None:
      uvs = PackedVector2Array.new0()
    if bones is None:
      bones = PackedInt32Array.new0()
    if weights is None:
      weights = PackedFloat32Array.new0()
    if texture is None:
      texture = RID.new0()
    if uvs is None:
      uvs = PackedVector2Array.new0()
    if bones is None:
      bones = PackedInt32Array.new0()
    if weights is None:
      weights = PackedFloat32Array.new0()
    if texture is None:
      texture = RID.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not indices is None)
    assert isinstance(indices, PackedInt32Array), 'indices must be PackedInt32Array'
    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'
    assert isinstance(count, (int, float)), 'count must be int or float'














    self._ptr.call_with_return(473,tuple([item._ptr, indices._ptr, points._ptr, colors._ptr, uvs._ptr, bones._ptr, weights._ptr, texture._ptr, count]))

  @functools.native_method
  def canvas_item_add_mesh(self, item:'RID'   , mesh:'RID'   , transform:'Transform2D' = None  , modulate:'Color' = None  , texture:'RID' = None  ) -> None:
    r'''
				Draws a mesh created with `mesh_create` with given `transform`, `modulate` color, and `texture`. This is used internally by `MeshInstance2D`.
			'''
    if transform is None:
      transform = Transform2D.new0()
    if modulate is None:
      modulate = Color.new0()
    if texture is None:
      texture = RID.new0()
    if transform is None:
      transform = Transform2D.new0()
    if modulate is None:
      modulate = Color.new0()
    if texture is None:
      texture = RID.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'










    self._ptr.call_with_return(474,tuple([item._ptr, mesh._ptr, transform._ptr, modulate._ptr, texture._ptr]))

  @functools.native_method
  def canvas_item_add_multimesh(self, item:'RID'   , mesh:'RID'   , texture:'RID' = None  ) -> None:
    r'''
				Draws a 2D `MultiMesh` on the `CanvasItem` pointed to by the `item` `RID`. See also `CanvasItem.draw_multimesh`.
			'''
    if texture is None:
      texture = RID.new0()
    if texture is None:
      texture = RID.new0()

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'








    self._ptr.call_with_return(475,tuple([item._ptr, mesh._ptr, texture._ptr]))

  @functools.native_method
  def canvas_item_add_particles(self, item:'RID'   , particles:'RID'   , texture:'RID'   ) -> None:
    r'''
				Draws particles on the `CanvasItem` pointed to by the `item` `RID`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not particles is None)
    assert isinstance(particles, RID), 'particles must be RID'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'








    self._ptr.call_with_return(476,tuple([item._ptr, particles._ptr, texture._ptr]))

  @functools.native_method
  def canvas_item_add_set_transform(self, item:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets a `Transform2D` that will be used to transform subsequent canvas item commands.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(477,tuple([item._ptr, transform._ptr]))

  @functools.native_method
  def canvas_item_add_clip_ignore(self, item:'RID'   , ignore:'bool'   ) -> None:
    r'''
				If `ignore` is `true`, ignore clipping on items drawn with this canvas item until this is called again with `ignore` set to `false`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(ignore, bool), 'ignore must be bool'







    self._ptr.call_with_return(478,tuple([item._ptr, ignore]))

  @functools.native_method
  def canvas_item_add_animation_slice(self, item:'RID'   , animation_length:'float'   , slice_begin:'float'   , slice_end:'float'   , offset:'float' =0.0  ) -> None:
    r'''
				Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(animation_length, (int, float)), 'animation_length must be int or float'
    assert isinstance(slice_begin, (int, float)), 'slice_begin must be int or float'
    assert isinstance(slice_end, (int, float)), 'slice_end must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'










    self._ptr.call_with_return(479,tuple([item._ptr, animation_length, slice_begin, slice_end, offset]))

  @functools.native_method
  def canvas_item_set_sort_children_by_y(self, item:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If `enabled` is `true`, child nodes with the lowest Y position are drawn before those with a higher Y position. Y-sorting only affects children that inherit from the canvas item specified by the `item` RID, not the canvas item itself. Equivalent to `CanvasItem.y_sort_enabled`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(480,tuple([item._ptr, enabled]))

  @functools.native_method
  def canvas_item_set_z_index(self, item:'RID'   , z_index:'int'   ) -> None:
    r'''
				Sets the `CanvasItem`'s Z index, i.e. its draw order (lower indexes are drawn first).
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(z_index, (int, float)), 'z_index must be int or float'







    self._ptr.call_with_return(481,tuple([item._ptr, z_index]))

  @functools.native_method
  def canvas_item_set_z_as_relative_to_parent(self, item:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If this is enabled, the Z index of the parent will be added to the children's Z index.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(482,tuple([item._ptr, enabled]))

  @functools.native_method
  def canvas_item_set_copy_to_backbuffer(self, item:'RID'   , enabled:'bool'   , rect:'Rect2'   ) -> None:
    r'''
				Sets the `CanvasItem` to copy a rect to the backbuffer.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'








    self._ptr.call_with_return(483,tuple([item._ptr, enabled, rect._ptr]))

  @functools.native_method
  def canvas_item_attach_skeleton(self, item:'RID'   , skeleton:'RID'   ) -> None:
    r'''
				Attaches a skeleton to the `CanvasItem`. Removes the previous skeleton.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not skeleton is None)
    assert isinstance(skeleton, RID), 'skeleton must be RID'







    self._ptr.call_with_return(484,tuple([item._ptr, skeleton._ptr]))

  @functools.native_method
  def canvas_item_clear(self, item:'RID'   ) -> None:
    r'''
				Clears the `CanvasItem` and removes all commands in it.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'






    self._ptr.call_with_return(485,tuple([item._ptr]))

  @functools.native_method
  def canvas_item_set_draw_index(self, item:'RID'   , index:'int'   ) -> None:
    r'''
				Sets the index for the `CanvasItem`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(486,tuple([item._ptr, index]))

  @functools.native_method
  def canvas_item_set_material(self, item:'RID'   , material:'RID'   ) -> None:
    r'''
				Sets a new `material` to the canvas item specified by the `item` RID. Equivalent to `CanvasItem.material`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert(not material is None)
    assert isinstance(material, RID), 'material must be RID'







    self._ptr.call_with_return(487,tuple([item._ptr, material._ptr]))

  @functools.native_method
  def canvas_item_set_use_parent_material(self, item:'RID'   , enabled:'bool'   ) -> None:
    r'''
				Sets if the `CanvasItem` uses its parent's material.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(488,tuple([item._ptr, enabled]))

  @functools.native_method
  def canvas_item_set_instance_shader_parameter(self, instance:'RID'   , parameter:'object'   , value:'object'   ) -> None:
    r'''
				Sets the per-instance shader uniform on the specified canvas item instance. Equivalent to `CanvasItem.set_instance_shader_parameter`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'
    





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)


    self._ptr.call_with_return(489,tuple([instance._ptr, py_stringname_parameter._ptr, value]))

  @functools.native_method
  def canvas_item_get_instance_shader_parameter(self, instance:'RID'   , parameter:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of the per-instance shader uniform from the specified canvas item instance. Equivalent to `CanvasItem.get_instance_shader_parameter`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)

    _ret = None
    _ret = self._ptr.call_with_return(490,tuple([instance._ptr, py_stringname_parameter._ptr]))
    return _ret


  @functools.native_method
  def canvas_item_get_instance_shader_parameter_default_value(self, instance:'RID'   , parameter:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the default value of the per-instance shader uniform from the specified canvas item instance. Equivalent to `CanvasItem.get_instance_shader_parameter`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'
    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)

    _ret = None
    _ret = self._ptr.call_with_return(491,tuple([instance._ptr, py_stringname_parameter._ptr]))
    return _ret


  @functools.native_method
  def canvas_item_get_instance_shader_parameter_list(self, instance:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns a dictionary of per-instance shader uniform names of the per-instance shader uniform from the specified canvas item instance.
				The returned dictionary is in PropertyInfo format, with the keys `name`, `class_name`, `type`, `hint`, `hint_string`, and `usage`.
			'''

    assert(not instance is None)
    assert isinstance(instance, RID), 'instance must be RID'






    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(492,tuple([instance._ptr]))
    return _ret


  @functools.native_method
  def canvas_item_set_visibility_notifier(self, item:'RID'   , enable:'bool'   , area:'Rect2'   , enter_callable:'Callable'   , exit_callable:'Callable'   ) -> None:
    r'''
				Sets the given `CanvasItem` as visibility notifier. `area` defines the area of detecting visibility. `enter_callable` is called when the `CanvasItem` enters the screen, `exit_callable` is called when the `CanvasItem` exits the screen. If `enable` is `false`, the item will no longer function as notifier.
				This method can be used to manually mimic `VisibleOnScreenNotifier2D`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(enable, bool), 'enable must be bool'
    assert(not area is None)
    assert isinstance(area, Rect2), 'area must be Rect2'
    assert(not enter_callable is None)
    assert isinstance(enter_callable, Callable), 'enter_callable must be Callable'
    assert(not exit_callable is None)
    assert isinstance(exit_callable, Callable), 'exit_callable must be Callable'










    self._ptr.call_with_return(493,tuple([item._ptr, enable, area._ptr, enter_callable._ptr, exit_callable._ptr]))

  @functools.native_method
  def canvas_item_set_canvas_group_mode(self, item:'RID'   , mode:'int'  , clear_margin:'float' =5.0  , fit_empty:'bool' =False  , fit_margin:'float' =0.0  , blur_mipmaps:'bool' =False  ) -> None:
    r'''
				Sets the canvas group mode used during 2D rendering for the canvas item specified by the `item` RID. For faster but more limited clipping, use `canvas_item_set_clip` instead.
				**Note:** The equivalent node functionality is found in `CanvasGroup` and `CanvasItem.clip_children`.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'
    assert isinstance(clear_margin, (int, float)), 'clear_margin must be int or float'
    assert isinstance(fit_empty, bool), 'fit_empty must be bool'
    assert isinstance(fit_margin, (int, float)), 'fit_margin must be int or float'
    assert isinstance(blur_mipmaps, bool), 'blur_mipmaps must be bool'











    self._ptr.call_with_return(494,tuple([item._ptr, mode, clear_margin, fit_empty, fit_margin, blur_mipmaps]))

  @functools.native_method
  def debug_canvas_item_get_rect(self, item:'RID'   ) -> typing.Union['Rect2']:
    r'''
				Returns the bounding rectangle for a canvas item in local space, as calculated by the renderer. This bound is used internally for culling.
				**Warning:** This function is intended for debugging in the editor, and will pass through and return a zero `Rect2` in exported projects.
			'''

    assert(not item is None)
    assert isinstance(item, RID), 'item must be RID'






    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(495,tuple([item._ptr]))
    return _ret


  @functools.native_method
  def canvas_light_create(self) -> typing.Union['RID']:
    r'''
				Creates a canvas light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_light_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `Light2D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(496,tuple([]))
    return _ret


  @functools.native_method
  def canvas_light_attach_to_canvas(self, light:'RID'   , canvas:'RID'   ) -> None:
    r'''
				Attaches the canvas light to the canvas. Removes it from its previous canvas.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'







    self._ptr.call_with_return(497,tuple([light._ptr, canvas._ptr]))

  @functools.native_method
  def canvas_light_set_enabled(self, light:'RID'   , enabled:'bool'   ) -> None:
    r'''
				Enables or disables a canvas light.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(498,tuple([light._ptr, enabled]))

  @functools.native_method
  def canvas_light_set_texture_scale(self, light:'RID'   , scale:'float'   ) -> None:
    r'''
				Sets the scale factor of a `PointLight2D`'s texture. Equivalent to `PointLight2D.texture_scale`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(scale, (int, float)), 'scale must be int or float'







    self._ptr.call_with_return(499,tuple([light._ptr, scale]))

  @functools.native_method
  def canvas_light_set_transform(self, light:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets the canvas light's `Transform2D`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(500,tuple([light._ptr, transform._ptr]))

  @functools.native_method
  def canvas_light_set_texture(self, light:'RID'   , texture:'RID'   ) -> None:
    r'''
				Sets the texture to be used by a `PointLight2D`. Equivalent to `PointLight2D.texture`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'







    self._ptr.call_with_return(501,tuple([light._ptr, texture._ptr]))

  @functools.native_method
  def canvas_light_set_texture_offset(self, light:'RID'   , offset:'Vector2'   ) -> None:
    r'''
				Sets the offset of a `PointLight2D`'s texture. Equivalent to `PointLight2D.offset`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'







    self._ptr.call_with_return(502,tuple([light._ptr, offset._ptr]))

  @functools.native_method
  def canvas_light_set_color(self, light:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets the color for a light.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(503,tuple([light._ptr, color._ptr]))

  @functools.native_method
  def canvas_light_set_height(self, light:'RID'   , height:'float'   ) -> None:
    r'''
				Sets a canvas light's height.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(height, (int, float)), 'height must be int or float'







    self._ptr.call_with_return(504,tuple([light._ptr, height]))

  @functools.native_method
  def canvas_light_set_energy(self, light:'RID'   , energy:'float'   ) -> None:
    r'''
				Sets a canvas light's energy.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(energy, (int, float)), 'energy must be int or float'







    self._ptr.call_with_return(505,tuple([light._ptr, energy]))

  @functools.native_method
  def canvas_light_set_z_range(self, light:'RID'   , min_z:'int'   , max_z:'int'   ) -> None:
    r'''
				Sets the Z range of objects that will be affected by this light. Equivalent to `Light2D.range_z_min` and `Light2D.range_z_max`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(min_z, (int, float)), 'min_z must be int or float'
    assert isinstance(max_z, (int, float)), 'max_z must be int or float'








    self._ptr.call_with_return(506,tuple([light._ptr, min_z, max_z]))

  @functools.native_method
  def canvas_light_set_layer_range(self, light:'RID'   , min_layer:'int'   , max_layer:'int'   ) -> None:
    r'''
				The layer range that gets rendered with this light.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(min_layer, (int, float)), 'min_layer must be int or float'
    assert isinstance(max_layer, (int, float)), 'max_layer must be int or float'








    self._ptr.call_with_return(507,tuple([light._ptr, min_layer, max_layer]))

  @functools.native_method
  def canvas_light_set_item_cull_mask(self, light:'RID'   , mask:'int'   ) -> None:
    r'''
				The light mask. See `LightOccluder2D` for more information on light masks.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(508,tuple([light._ptr, mask]))

  @functools.native_method
  def canvas_light_set_item_shadow_cull_mask(self, light:'RID'   , mask:'int'   ) -> None:
    r'''
				The binary mask used to determine which layers this canvas light's shadows affects. See `LightOccluder2D` for more information on light masks.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(509,tuple([light._ptr, mask]))

  @functools.native_method
  def canvas_light_set_mode(self, light:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the mode of the canvas light.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(510,tuple([light._ptr, mode]))

  @functools.native_method
  def canvas_light_set_shadow_enabled(self, light:'RID'   , enabled:'bool'   ) -> None:
    r'''
				Enables or disables the canvas light's shadow.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(511,tuple([light._ptr, enabled]))

  @functools.native_method
  def canvas_light_set_shadow_filter(self, light:'RID'   , filter:'int'  ) -> None:
    r'''
				Sets the canvas light's shadow's filter.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(filter, (int, float)), 'filter must be int or float'







    self._ptr.call_with_return(512,tuple([light._ptr, filter]))

  @functools.native_method
  def canvas_light_set_shadow_color(self, light:'RID'   , color:'Color'   ) -> None:
    r'''
				Sets the color of the canvas light's shadow.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(513,tuple([light._ptr, color._ptr]))

  @functools.native_method
  def canvas_light_set_shadow_smooth(self, light:'RID'   , smooth:'float'   ) -> None:
    r'''
				Smoothens the shadow. The lower, the smoother.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(smooth, (int, float)), 'smooth must be int or float'







    self._ptr.call_with_return(514,tuple([light._ptr, smooth]))

  @functools.native_method
  def canvas_light_set_blend_mode(self, light:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets the blend mode for the given canvas light to `mode`. Equivalent to `Light2D.blend_mode`.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(515,tuple([light._ptr, mode]))

  @functools.native_method
  def canvas_light_set_interpolated(self, light:'RID'   , interpolated:'bool'   ) -> None:
    r'''
				If `interpolated` is `true`, turns on physics interpolation for the canvas light.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert isinstance(interpolated, bool), 'interpolated must be bool'







    self._ptr.call_with_return(516,tuple([light._ptr, interpolated]))

  @functools.native_method
  def canvas_light_reset_physics_interpolation(self, light:'RID'   ) -> None:
    r'''
				Prevents physics interpolation for the current physics tick.
				This is useful when moving a canvas item to a new location, to give an instantaneous change rather than interpolation from the previous location.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'






    self._ptr.call_with_return(517,tuple([light._ptr]))

  @functools.native_method
  def canvas_light_transform_physics_interpolation(self, light:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Transforms both the current and previous stored transform for a canvas light.
				This allows transforming a light without creating a "glitch" in the interpolation, which is particularly useful for large worlds utilizing a shifting origin.
			'''

    assert(not light is None)
    assert isinstance(light, RID), 'light must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(518,tuple([light._ptr, transform._ptr]))

  @functools.native_method
  def canvas_light_occluder_create(self) -> typing.Union['RID']:
    r'''
				Creates a light occluder and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_light_occluder_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent node is `LightOccluder2D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(519,tuple([]))
    return _ret


  @functools.native_method
  def canvas_light_occluder_attach_to_canvas(self, occluder:'RID'   , canvas:'RID'   ) -> None:
    r'''
				Attaches a light occluder to the canvas. Removes it from its previous canvas.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'







    self._ptr.call_with_return(520,tuple([occluder._ptr, canvas._ptr]))

  @functools.native_method
  def canvas_light_occluder_set_enabled(self, occluder:'RID'   , enabled:'bool'   ) -> None:
    r'''
				Enables or disables light occluder.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(521,tuple([occluder._ptr, enabled]))

  @functools.native_method
  def canvas_light_occluder_set_polygon(self, occluder:'RID'   , polygon:'RID'   ) -> None:
    r'''
				Sets a light occluder's polygon.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert(not polygon is None)
    assert isinstance(polygon, RID), 'polygon must be RID'







    self._ptr.call_with_return(522,tuple([occluder._ptr, polygon._ptr]))

  @functools.native_method
  def canvas_light_occluder_set_as_sdf_collision(self, occluder:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(523,tuple([occluder._ptr, enable]))

  @functools.native_method
  def canvas_light_occluder_set_transform(self, occluder:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets a light occluder's `Transform2D`.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(524,tuple([occluder._ptr, transform._ptr]))

  @functools.native_method
  def canvas_light_occluder_set_light_mask(self, occluder:'RID'   , mask:'int'   ) -> None:
    r'''
				The light mask. See `LightOccluder2D` for more information on light masks.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'







    self._ptr.call_with_return(525,tuple([occluder._ptr, mask]))

  @functools.native_method
  def canvas_light_occluder_set_interpolated(self, occluder:'RID'   , interpolated:'bool'   ) -> None:
    r'''
				If `interpolated` is `true`, turns on physics interpolation for the light occluder.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert isinstance(interpolated, bool), 'interpolated must be bool'







    self._ptr.call_with_return(526,tuple([occluder._ptr, interpolated]))

  @functools.native_method
  def canvas_light_occluder_reset_physics_interpolation(self, occluder:'RID'   ) -> None:
    r'''
				Prevents physics interpolation for the current physics tick.
				This is useful when moving an occluder to a new location, to give an instantaneous change rather than interpolation from the previous location.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'






    self._ptr.call_with_return(527,tuple([occluder._ptr]))

  @functools.native_method
  def canvas_light_occluder_transform_physics_interpolation(self, occluder:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Transforms both the current and previous stored transform for a light occluder.
				This allows transforming an occluder without creating a "glitch" in the interpolation, which is particularly useful for large worlds utilizing a shifting origin.
			'''

    assert(not occluder is None)
    assert isinstance(occluder, RID), 'occluder must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'







    self._ptr.call_with_return(528,tuple([occluder._ptr, transform._ptr]))

  @functools.native_method
  def canvas_occluder_polygon_create(self) -> typing.Union['RID']:
    r'''
				Creates a new light occluder polygon and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_occluder_polygon_*` RenderingServer functions.
				Once finished with your RID, you will want to free the RID using the RenderingServer's `free_rid` method.
				**Note:** The equivalent resource is `OccluderPolygon2D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(529,tuple([]))
    return _ret


  @functools.native_method
  def canvas_occluder_polygon_set_shape(self, occluder_polygon:'RID'   , shape:'PackedVector2Array'   , closed:'bool'   ) -> None:
    r'''
				Sets the shape of the occluder polygon.
			'''

    assert(not occluder_polygon is None)
    assert isinstance(occluder_polygon, RID), 'occluder_polygon must be RID'
    assert(not shape is None)
    assert isinstance(shape, PackedVector2Array), 'shape must be PackedVector2Array'
    assert isinstance(closed, bool), 'closed must be bool'








    self._ptr.call_with_return(530,tuple([occluder_polygon._ptr, shape._ptr, closed]))

  @functools.native_method
  def canvas_occluder_polygon_set_cull_mode(self, occluder_polygon:'RID'   , mode:'int'  ) -> None:
    r'''
				Sets an occluder polygon's cull mode.
			'''

    assert(not occluder_polygon is None)
    assert isinstance(occluder_polygon, RID), 'occluder_polygon must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(531,tuple([occluder_polygon._ptr, mode]))

  @functools.native_method
  def canvas_set_shadow_texture_size(self, size:'int'   ) -> None:
    r'''
				Sets the `ProjectSettings.rendering/2d/shadow_atlas/size` to use for `Light2D` shadow rendering (in pixels). The value is rounded up to the nearest power of 2.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'






    self._ptr.call_with_return(532,tuple([size]))

  @functools.native_method
  def global_shader_parameter_add(self, name:'object'   , type:'int'  , default_value:'object'   ) -> None:
    r'''
				Creates a new global shader uniform.
				**Note:** Global shader parameter names are case-sensitive.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(type, (int, float)), 'type must be int or float'
    




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)



    self._ptr.call_with_return(533,tuple([py_stringname_name._ptr, type, default_value]))

  @functools.native_method
  def global_shader_parameter_remove(self, name:'object'   ) -> None:
    r'''
				Removes the global shader uniform specified by `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(534,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def global_shader_parameter_get_list(self) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
				Returns the list of global shader uniform names.
				**Note:** `global_shader_parameter_get` has a large performance penalty as the rendering thread needs to synchronize with the calling thread, which is slow. Do not use this method during gameplay to avoid stuttering. If you need to read values in a script after setting them, consider creating an autoload where you store the values you need to query at the same time you're setting them as global parameters.
			'''




    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(535,tuple([]))
    return _ret


  @functools.native_method
  def global_shader_parameter_set(self, name:'object'   , value:'object'   ) -> None:
    r'''
				Sets the global shader uniform `name` to `value`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(536,tuple([py_stringname_name._ptr, value]))

  @functools.native_method
  def global_shader_parameter_set_override(self, name:'object'   , value:'object'   ) -> None:
    r'''
				Overrides the global shader uniform `name` with `value`. Equivalent to the `ShaderGlobalsOverride` node.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(537,tuple([py_stringname_name._ptr, value]))

  @functools.native_method
  def global_shader_parameter_get(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of the global shader uniform specified by `name`.
				**Note:** `global_shader_parameter_get` has a large performance penalty as the rendering thread needs to synchronize with the calling thread, which is slow. Do not use this method during gameplay to avoid stuttering. If you need to read values in a script after setting them, consider creating an autoload where you store the values you need to query at the same time you're setting them as global parameters.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(538,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def global_shader_parameter_get_type(self, name:'object'   ) -> typing.Union[int]:
    r'''
				Returns the type associated to the global shader uniform specified by `name`.
				**Note:** `global_shader_parameter_get` has a large performance penalty as the rendering thread needs to synchronize with the calling thread, which is slow. Do not use this method during gameplay to avoid stuttering. If you need to read values in a script after setting them, consider creating an autoload where you store the values you need to query at the same time you're setting them as global parameters.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret:int
    _ret = self._ptr.call_with_return(539,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def free_rid(self, rid:'RID'   ) -> None:
    r'''
				Tries to free an object in the RenderingServer. To avoid memory leaks, this should be called after using an object as memory management does not occur automatically when using RenderingServer directly.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'






    self._ptr.call_with_return(540,tuple([rid._ptr]))

  @functools.native_method
  def request_frame_drawn_callback(self, callable:'Callable'   ) -> None:
    r'''
				Schedules a callback to the given callable after a frame has been drawn.
			'''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'






    self._ptr.call_with_return(541,tuple([callable._ptr]))

  @functools.native_method
  def has_changed(self) -> typing.Union[bool]:
    r'''
				Returns `true` if changes have been made to the RenderingServer's data. `force_draw` is usually called if this happens.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(542,tuple([]))
    return _ret


  @functools.native_method
  def get_rendering_info(self, info:'int'  ) -> typing.Union[int]:
    r'''
				Returns a statistic about the rendering engine which can be used for performance profiling. See also `viewport_get_render_info`, which returns information specific to a viewport.
				**Note:** Only 3D rendering is currently taken into account by some of these values, such as the number of draw calls.
				**Note:** Rendering information is not available until at least 2 frames have been rendered by the engine. If rendering information is not available, `get_rendering_info` returns `0`. To print rendering information in `_ready()` successfully, use the following:
				```gdscript
				func _ready():
					for _i in 2:
						await get_tree().process_frame

					print(RenderingServer.get_rendering_info(RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME))
				```
			'''

    assert isinstance(info, (int, float)), 'info must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(543,tuple([info]))
    return _ret


  @functools.native_method
  def get_video_adapter_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the video adapter (e.g. "GeForce GTX 1080/PCIe/SSE2").
				**Note:** When running a headless or server binary, this function returns an empty string.
				**Note:** On the web platform, some browsers such as Firefox may report a different, fixed GPU name such as "GeForce GTX 980" (regardless of the user's actual GPU model). This is done to make fingerprinting more difficult.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(544,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_video_adapter_vendor(self) -> typing.Union[str]:
    r'''
				Returns the vendor of the video adapter (e.g. "NVIDIA Corporation").
				**Note:** When running a headless or server binary, this function returns an empty string.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(545,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_video_adapter_type(self) -> typing.Union[int]:
    r'''
				Returns the type of the video adapter. Since dedicated graphics cards from a given generation will _usually_ be significantly faster than integrated graphics made in the same generation, the device type can be used as a basis for automatic graphics settings adjustment. However, this is not always true, so make sure to provide users with a way to manually override graphics settings.
				**Note:** When using the OpenGL rendering driver or when running in headless mode, this function always returns `constant RenderingDevice.DEVICE_TYPE_OTHER`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(546,tuple([]))
    return _ret


  @functools.native_method
  def get_video_adapter_api_version(self) -> typing.Union[str]:
    r'''
				Returns the version of the graphics video adapter _currently in use_ (e.g. "1.2.189" for Vulkan, "3.3.0 NVIDIA 510.60.02" for OpenGL). This version may be different from the actual latest version supported by the hardware, as Godot may not always request the latest version. See also `OS.get_video_adapter_driver_info`.
				**Note:** When running a headless or server binary, this function returns an empty string.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(547,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_rendering_driver_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the current rendering driver. This can be `vulkan`, `d3d12`, `metal`, `opengl3`, `opengl3_es`, or `opengl3_angle`. See also `get_current_rendering_method`.
				When `ProjectSettings.rendering/renderer/rendering_method` is `forward_plus` or `mobile`, the rendering driver is determined by `ProjectSettings.rendering/rendering_device/driver`.
				When `ProjectSettings.rendering/renderer/rendering_method` is `gl_compatibility`, the rendering driver is determined by `ProjectSettings.rendering/gl_compatibility/driver`.
				The rendering driver is also determined by the `--rendering-driver` command line argument that overrides this project setting, or an automatic fallback that is applied depending on the hardware.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(548,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_rendering_method(self) -> typing.Union[str]:
    r'''
				Returns the name of the current rendering method. This can be `forward_plus`, `mobile`, or `gl_compatibility`. See also `get_current_rendering_driver_name`.
				The rendering method is determined by `ProjectSettings.rendering/renderer/rendering_method`, the `--rendering-method` command line argument that overrides this project setting, or an automatic fallback that is applied depending on the hardware.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(549,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def make_sphere_mesh(self, latitudes:'int'   , longitudes:'int'   , radius:'float'   ) -> typing.Union['RID']:
    r'''
				Returns a mesh of a sphere with the given number of horizontal subdivisions, vertical subdivisions and radius. See also `get_test_cube`.
			'''

    assert isinstance(latitudes, (int, float)), 'latitudes must be int or float'
    assert isinstance(longitudes, (int, float)), 'longitudes must be int or float'
    assert isinstance(radius, (int, float)), 'radius must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(550,tuple([latitudes, longitudes, radius]))
    return _ret


  @functools.native_method
  def get_test_cube(self) -> typing.Union['RID']:
    r'''
				Returns the RID of the test cube. This mesh will be created and returned on the first call to `get_test_cube`, then it will be cached for subsequent calls. See also `make_sphere_mesh`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(551,tuple([]))
    return _ret


  @functools.native_method
  def get_test_texture(self) -> typing.Union['RID']:
    r'''
				Returns the RID of a 256×256 texture with a testing pattern on it (in `constant Image.FORMAT_RGB8` format). This texture will be created and returned on the first call to `get_test_texture`, then it will be cached for subsequent calls. See also `get_white_texture`.
				**Example:** Get the test texture and apply it to a `Sprite2D` node:
				```gdscript
				var texture_rid = RenderingServer.get_test_texture()
				var texture = ImageTexture.create_from_image(RenderingServer.texture_2d_get(texture_rid))
				$Sprite2D.texture = texture
				```
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(552,tuple([]))
    return _ret


  @functools.native_method
  def get_white_texture(self) -> typing.Union['RID']:
    r'''
				Returns the ID of a 4×4 white texture (in `constant Image.FORMAT_RGB8` format). This texture will be created and returned on the first call to `get_white_texture`, then it will be cached for subsequent calls. See also `get_test_texture`.
				**Example:** Get the white texture and apply it to a `Sprite2D` node:
				```gdscript
				var texture_rid = RenderingServer.get_white_texture()
				var texture = ImageTexture.create_from_image(RenderingServer.texture_2d_get(texture_rid))
				$Sprite2D.texture = texture
				```
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(553,tuple([]))
    return _ret


  @functools.native_method
  def set_boot_image(self, image:'py4godot_image.Image'   , color:'Color'   , scale:'bool'   , use_filter:'bool' =True  ) -> None:
    r'''
				Sets a boot image. The color defines the background color. If `scale` is `true`, the image will be scaled to fit the screen size. If `use_filter` is `true`, the image will be scaled with linear interpolation. If `use_filter` is `false`, the image will be scaled with nearest-neighbor interpolation.
			'''

    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(scale, bool), 'scale must be bool'
    assert isinstance(use_filter, bool), 'use_filter must be bool'









    self._ptr.call_with_return(554,tuple([image._ptr, color._ptr, scale, use_filter]))

  @functools.native_method
  def get_default_clear_color(self) -> typing.Union['Color']:
    r'''
				Returns the default clear color which is used when a specific clear color has not been selected. See also `set_default_clear_color`.
			'''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(555,tuple([]))
    return _ret


  @functools.native_method
  def set_default_clear_color(self, color:'Color'   ) -> None:
    r'''
				Sets the default clear color which is used when a specific clear color has not been selected. See also `get_default_clear_color`.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'






    self._ptr.call_with_return(556,tuple([color._ptr]))

  @functools.native_method
  def has_os_feature(self, feature:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the OS supports a certain `feature`. Features might be `s3tc`, `etc`, and `etc2`.
			'''

    assert(not feature is None)
    assert isinstance(feature, (str, String)), 'feature must be str or String'




    assert(isinstance(feature, (str, String)))
    py_string_feature = feature if isinstance(feature, StringName) else c_utils.py_string_to_string(feature)

    _ret = 0
    _ret = self._ptr.call_with_return(557,tuple([py_string_feature._ptr]))
    return _ret


  @functools.native_method
  def set_debug_generate_wireframes(self, generate:'bool'   ) -> None:
    r'''
				If `generate` is `true`, generates debug wireframes for all meshes that are loaded when using the Compatibility renderer. By default, the engine does not generate debug wireframes at runtime, since they slow down loading of assets and take up VRAM.
				**Note:** You must call this method before loading any meshes when using the Compatibility renderer, otherwise wireframes will not be used.
			'''

    assert isinstance(generate, bool), 'generate must be bool'






    self._ptr.call_with_return(558,tuple([generate]))

  @functools.native_method
  def is_render_loop_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(559,tuple([]))

    return _ret


  @functools.native_method
  def set_render_loop_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'

    self.py__render_loop_enabled = enabled






    self._ptr.call_with_return(560,tuple([enabled]))

  @functools.native_method
  def get_frame_setup_time_cpu(self) -> typing.Union[float]:
    r'''
				Returns the time taken to setup rendering on the CPU in milliseconds. This value is shared across all viewports and does _not_ require `viewport_set_measure_render_time` to be enabled on a viewport to be queried. See also `viewport_get_measured_render_time_cpu`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(561,tuple([]))
    return _ret


  @functools.native_method
  def force_sync(self) -> None:
    r'''
				Forces a synchronization between the CPU and GPU, which may be required in certain cases. Only call this when needed, as CPU-GPU synchronization has a performance cost.
			'''




    self._ptr.call_with_return(562,tuple([]))

  @functools.native_method
  def force_draw(self, swap_buffers:'bool' =True  , frame_step:'float' =0.0  ) -> None:
    r'''
				Forces redrawing of all viewports at once. Must be called from the main thread.
			'''

    assert isinstance(swap_buffers, bool), 'swap_buffers must be bool'
    assert isinstance(frame_step, (int, float)), 'frame_step must be int or float'







    self._ptr.call_with_return(563,tuple([swap_buffers, frame_step]))

  @functools.native_method
  def get_rendering_device(self) -> typing.Union['py4godot_renderingdevice.RenderingDevice']:
    r'''
				Returns the global RenderingDevice.
				**Note:** When using the OpenGL rendering driver or when running in headless mode, this function always returns `null`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: RenderingDevice
    _ret._ptr = self._ptr.call_with_return(564,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def create_local_rendering_device(self) -> typing.Union['py4godot_renderingdevice.RenderingDevice']:
    r'''
				Creates a RenderingDevice that can be used to do draw and compute operations on a separate thread. Cannot draw to the screen nor share data with the global RenderingDevice.
				**Note:** When using the OpenGL rendering driver or when running in headless mode, this function always returns `null`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: RenderingDevice
    _ret._ptr = self._ptr.call_with_return(565,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_on_render_thread(self) -> typing.Union[bool]:
    r'''
				Returns `true` if our code is currently executing on the rendering thread.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(566,tuple([]))
    return _ret


  @functools.native_method
  def call_on_render_thread(self, callable:'Callable'   ) -> None:
    r'''
				As the RenderingServer actual logic may run on a separate thread, accessing its internals from the main (or any other) thread will result in errors. To make it easier to run code that can safely access the rendering internals (such as `RenderingDevice` and similar RD classes), push a callable via this function so it will be executed on the render thread.
			'''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'






    self._ptr.call_with_return(567,tuple([callable._ptr]))

  @functools.native_method
  def has_feature(self, feature:'int'  ) -> typing.Union[bool]:
    r'''
				This method does nothing and always returns `false`.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(568,tuple([feature]))
    return _ret



register_cast_function('RenderingServer', RenderingServer.cast)
register_class('RenderingServer', RenderingServer)
