# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AudioEffectCompressor as py4godot_audioeffectcompressor 
  import py4godot.classes.AudioEffectDelay as py4godot_audioeffectdelay 
  import py4godot.classes.AudioEffectRecord as py4godot_audioeffectrecord 
  import py4godot.classes.AudioEffectReverb as py4godot_audioeffectreverb 
  import py4godot.classes.AudioEffectDistortion as py4godot_audioeffectdistortion 
  import py4godot.classes.AudioEffectFilter as py4godot_audioeffectfilter 
  import py4godot.classes.AudioBusLayout as py4godot_audiobuslayout 
  import py4godot.classes.AudioEffectEQ6 as py4godot_audioeffecteq6 
  import py4godot.classes.AudioEffectEQ21 as py4godot_audioeffecteq21 
  import py4godot.classes.AudioEffectHighShelfFilter as py4godot_audioeffecthighshelffilter 
  import py4godot.classes.AudioEffectLowPassFilter as py4godot_audioeffectlowpassfilter 
  import py4godot.classes.AudioEffectHighPassFilter as py4godot_audioeffecthighpassfilter 
  import py4godot.classes.AudioEffectNotchFilter as py4godot_audioeffectnotchfilter 
  import py4godot.classes.AudioEffectHardLimiter as py4godot_audioeffecthardlimiter 
  import py4godot.classes.AudioEffectPanner as py4godot_audioeffectpanner 
  import py4godot.classes.AudioEffectLimiter as py4godot_audioeffectlimiter 
  import py4godot.classes.AudioEffectCapture as py4godot_audioeffectcapture 
  import py4godot.classes.AudioEffectAmplify as py4godot_audioeffectamplify 
  import py4godot.classes.AudioEffectLowShelfFilter as py4godot_audioeffectlowshelffilter 
  import py4godot.classes.AudioEffectChorus as py4godot_audioeffectchorus 
  import py4godot.classes.AudioEffectBandLimitFilter as py4godot_audioeffectbandlimitfilter 
  import py4godot.classes.AudioEffectEQ as py4godot_audioeffecteq 
  import py4godot.classes.AudioEffectPitchShift as py4godot_audioeffectpitchshift 
  import py4godot.classes.AudioEffectPhaser as py4godot_audioeffectphaser 
  import py4godot.classes.AudioEffectInstance as py4godot_audioeffectinstance 
  import py4godot.classes.AudioEffectSpectrumAnalyzerInstance as py4godot_audioeffectspectrumanalyzerinstance 
  import py4godot.classes.AudioStream as py4godot_audiostream 
  import py4godot.classes.AudioEffectSpectrumAnalyzer as py4godot_audioeffectspectrumanalyzer 
  import py4godot.classes.AudioEffectStereoEnhance as py4godot_audioeffectstereoenhance 
  import py4godot.classes.AudioEffectBandPassFilter as py4godot_audioeffectbandpassfilter 
  import py4godot.classes.AudioEffectEQ10 as py4godot_audioeffecteq10 
  import py4godot.classes.AudioEffect as py4godot_audioeffect 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPAudioServerWrapper

_AudioServer_singleton_instance = None
class SpeakerMode:
  SPEAKER_MODE_STEREO = 0
  SPEAKER_SURROUND_31 = 1
  SPEAKER_SURROUND_51 = 2
  SPEAKER_SURROUND_71 = 3
class PlaybackType:
  PLAYBACK_TYPE_DEFAULT = 0
  PLAYBACK_TYPE_STREAM = 1
  PLAYBACK_TYPE_SAMPLE = 2
  PLAYBACK_TYPE_MAX = 3


class AudioServer(py4godot_object.Object):
  r'''
		`AudioServer` is a low-level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
	'''


  def generate_wrapper(self):
    return CPPAudioServerWrapper()
  def init_signals(self):
    super().init_signals()
    bus_layout_changed_name = utils.py_string_to_string_name("bus_layout_changed")
    self.bus_layout_changed = signals.BuiltinSignal(self, bus_layout_changed_name)
    bus_renamed_name = utils.py_string_to_string_name("bus_renamed")
    self.bus_renamed = signals.BuiltinSignal(self, bus_renamed_name)

  @staticmethod
  def construct_without_init():
    cls = AudioServer.__new__(AudioServer)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AudioServer'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioServer.construct_without_init()
    cls._ptr = CPPAudioServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioServer.construct_without_init()
    cls._ptr = CPPAudioServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _AudioServer_singleton_instance
    if _AudioServer_singleton_instance is None:
      singleton = AudioServer()
      singleton._ptr = constructor(139,0, ())
      _AudioServer_singleton_instance = singleton
    return _AudioServer_singleton_instance

  @property
  def bus_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bus_count()
    return _ret
  @bus_count.setter
  def bus_count(self,  value:'int'):
    self.set_bus_count(value)
  @property
  def output_device(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_output_device()
    return _ret
  @output_device.setter
  def output_device(self,  value:'str'):
    self.set_output_device(value)
  @property
  def input_device(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_input_device()
    return _ret
  @input_device.setter
  def input_device(self,  value:'str'):
    self.set_input_device(value)
  @property
  def playback_speed_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_playback_speed_scale()
    return _ret
  @playback_speed_scale.setter
  def playback_speed_scale(self,  value:'float'):
    self.set_playback_speed_scale(value)
  @functools.native_method
  def set_bus_count(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'

    self.py__bus_count = amount






    self._ptr.call_with_return(49,tuple([amount]))

  @functools.native_method
  def get_bus_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([]))

    return _ret


  @functools.native_method
  def remove_bus(self, index:'int'   ) -> None:
    r'''
				Removes the bus at index `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    self._ptr.call_with_return(51,tuple([index]))

  @functools.native_method
  def add_bus(self, at_position:'int' =-1  ) -> None:
    r'''
				Adds a bus at `at_position`.
			'''

    assert isinstance(at_position, (int, float)), 'at_position must be int or float'






    self._ptr.call_with_return(52,tuple([at_position]))

  @functools.native_method
  def move_bus(self, index:'int'   , to_index:'int'   ) -> None:
    r'''
				Moves the bus from index `index` to index `to_index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(to_index, (int, float)), 'to_index must be int or float'







    self._ptr.call_with_return(53,tuple([index, to_index]))

  @functools.native_method
  def set_bus_name(self, bus_idx:'int'   , name:'str'   ) -> None:
    r'''
				Sets the name of the bus at index `bus_idx` to `name`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(54,tuple([bus_idx, py_string_name._ptr]))

  @functools.native_method
  def get_bus_name(self, bus_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the bus with the index `bus_idx`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([bus_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_bus_index(self, bus_name:'object'   ) -> typing.Union[int]:
    r'''
				Returns the index of the bus with the name `bus_name`. Returns `-1` if no bus with the specified name exist.
			'''

    assert(not bus_name is None)
    assert isinstance(bus_name, (str, StringName)), 'bus_name must be str or StringName'




    assert(isinstance(bus_name, (str, StringName)))
    py_stringname_bus_name = bus_name if isinstance(bus_name, StringName) else c_utils.py_string_to_string_name(bus_name)

    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([py_stringname_bus_name._ptr]))
    return _ret


  @functools.native_method
  def get_bus_channels(self, bus_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of channels of the bus at index `bus_idx`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def set_bus_volume_db(self, bus_idx:'int'   , volume_db:'float'   ) -> None:
    r'''
				Sets the volume in decibels of the bus at index `bus_idx` to `volume_db`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(volume_db, (int, float)), 'volume_db must be int or float'







    self._ptr.call_with_return(58,tuple([bus_idx, volume_db]))

  @functools.native_method
  def get_bus_volume_db(self, bus_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the volume of the bus at index `bus_idx` in dB.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def set_bus_volume_linear(self, bus_idx:'int'   , volume_linear:'float'   ) -> None:
    r'''
				Sets the volume as a linear value of the bus at index `bus_idx` to `volume_linear`.
				**Note:** Using this method is equivalent to calling `set_bus_volume_db` with the result of `@GlobalScope.linear_to_db` on a value.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(volume_linear, (int, float)), 'volume_linear must be int or float'







    self._ptr.call_with_return(60,tuple([bus_idx, volume_linear]))

  @functools.native_method
  def get_bus_volume_linear(self, bus_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the volume of the bus at index `bus_idx` as a linear value.
				**Note:** The returned value is equivalent to the result of `@GlobalScope.db_to_linear` on the result of `get_bus_volume_db`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def set_bus_send(self, bus_idx:'int'   , send:'object'   ) -> None:
    r'''
				Connects the output of the bus at `bus_idx` to the bus named `send`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert(not send is None)
    assert isinstance(send, (str, StringName)), 'send must be str or StringName'





    assert(isinstance(send, (str, StringName)))
    py_stringname_send = send if isinstance(send, StringName) else c_utils.py_string_to_string_name(send)

    self._ptr.call_with_return(62,tuple([bus_idx, py_stringname_send._ptr]))

  @functools.native_method
  def get_bus_send(self, bus_idx:'int'   ) -> typing.Union['StringName']:
    r'''
				Returns the name of the bus that the bus at index `bus_idx` sends to.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def set_bus_solo(self, bus_idx:'int'   , enable:'bool'   ) -> None:
    r'''
				If `true`, the bus at index `bus_idx` is in solo mode.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(64,tuple([bus_idx, enable]))

  @functools.native_method
  def is_bus_solo(self, bus_idx:'int'   ) -> typing.Union[bool]:
    r'''
				If `true`, the bus at index `bus_idx` is in solo mode.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def set_bus_mute(self, bus_idx:'int'   , enable:'bool'   ) -> None:
    r'''
				If `true`, the bus at index `bus_idx` is muted.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(66,tuple([bus_idx, enable]))

  @functools.native_method
  def is_bus_mute(self, bus_idx:'int'   ) -> typing.Union[bool]:
    r'''
				If `true`, the bus at index `bus_idx` is muted.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def set_bus_bypass_effects(self, bus_idx:'int'   , enable:'bool'   ) -> None:
    r'''
				If `true`, the bus at index `bus_idx` is bypassing effects.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(68,tuple([bus_idx, enable]))

  @functools.native_method
  def is_bus_bypassing_effects(self, bus_idx:'int'   ) -> typing.Union[bool]:
    r'''
				If `true`, the bus at index `bus_idx` is bypassing effects.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def add_bus_effect(self, bus_idx:'int'   , effect:'py4godot_audioeffect.AudioEffect'   , at_position:'int' =-1  ) -> None:
    r'''
				Adds an `AudioEffect` effect to the bus `bus_idx` at `at_position`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert(not effect is None)
    assert isinstance(effect, get_class('AudioEffect')), 'effect must be AudioEffect'
    assert isinstance(at_position, (int, float)), 'at_position must be int or float'








    self._ptr.call_with_return(70,tuple([bus_idx, effect._ptr, at_position]))

  @functools.native_method
  def remove_bus_effect(self, bus_idx:'int'   , effect_idx:'int'   ) -> None:
    r'''
				Removes the effect at index `effect_idx` from the bus at index `bus_idx`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(effect_idx, (int, float)), 'effect_idx must be int or float'







    self._ptr.call_with_return(71,tuple([bus_idx, effect_idx]))

  @functools.native_method
  def get_bus_effect_count(self, bus_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of effects on the bus at `bus_idx`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(72,tuple([bus_idx]))
    return _ret


  @functools.native_method
  def get_bus_effect(self, bus_idx:'int'   , effect_idx:'int'   ) -> typing.Any:
    r'''
				Returns the `AudioEffect` at position `effect_idx` in bus `bus_idx`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(effect_idx, (int, float)), 'effect_idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioEffect
    _ret._ptr = self._ptr.call_with_return(73,tuple([bus_idx, effect_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_bus_effect_instance(self, bus_idx:'int'   , effect_idx:'int'   , channel:'int' =0  ) -> typing.Union['py4godot_audioeffectinstance.AudioEffectInstance','py4godot_audioeffectspectrumanalyzerinstance.AudioEffectSpectrumAnalyzerInstance']:
    r'''
				Returns the `AudioEffectInstance` assigned to the given bus and effect indices (and optionally channel).
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(effect_idx, (int, float)), 'effect_idx must be int or float'
    assert isinstance(channel, (int, float)), 'channel must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioEffectInstance
    _ret._ptr = self._ptr.call_with_return(74,tuple([bus_idx, effect_idx, channel]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def swap_bus_effects(self, bus_idx:'int'   , effect_idx:'int'   , by_effect_idx:'int'   ) -> None:
    r'''
				Swaps the position of two effects in bus `bus_idx`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(effect_idx, (int, float)), 'effect_idx must be int or float'
    assert isinstance(by_effect_idx, (int, float)), 'by_effect_idx must be int or float'








    self._ptr.call_with_return(75,tuple([bus_idx, effect_idx, by_effect_idx]))

  @functools.native_method
  def set_bus_effect_enabled(self, bus_idx:'int'   , effect_idx:'int'   , enabled:'bool'   ) -> None:
    r'''
				If `true`, the effect at index `effect_idx` on the bus at index `bus_idx` is enabled.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(effect_idx, (int, float)), 'effect_idx must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(76,tuple([bus_idx, effect_idx, enabled]))

  @functools.native_method
  def is_bus_effect_enabled(self, bus_idx:'int'   , effect_idx:'int'   ) -> typing.Union[bool]:
    r'''
				If `true`, the effect at index `effect_idx` on the bus at index `bus_idx` is enabled.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(effect_idx, (int, float)), 'effect_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([bus_idx, effect_idx]))
    return _ret


  @functools.native_method
  def get_bus_peak_volume_left_db(self, bus_idx:'int'   , channel:'int'   ) -> typing.Union[float]:
    r'''
				Returns the peak volume of the left speaker at bus index `bus_idx` and channel index `channel`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(channel, (int, float)), 'channel must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([bus_idx, channel]))
    return _ret


  @functools.native_method
  def get_bus_peak_volume_right_db(self, bus_idx:'int'   , channel:'int'   ) -> typing.Union[float]:
    r'''
				Returns the peak volume of the right speaker at bus index `bus_idx` and channel index `channel`.
			'''

    assert isinstance(bus_idx, (int, float)), 'bus_idx must be int or float'
    assert isinstance(channel, (int, float)), 'channel must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([bus_idx, channel]))
    return _ret


  @functools.native_method
  def set_playback_speed_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'

    self.py__playback_speed_scale = scale






    self._ptr.call_with_return(80,tuple([scale]))

  @functools.native_method
  def get_playback_speed_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([]))

    return _ret


  @functools.native_method
  def lock(self) -> None:
    r'''
				Locks the audio driver's main loop.
				**Note:** Remember to unlock it afterwards.
			'''




    self._ptr.call_with_return(82,tuple([]))

  @functools.native_method
  def unlock(self) -> None:
    r'''
				Unlocks the audio driver's main loop. (After locking it, you should always unlock it.)
			'''




    self._ptr.call_with_return(83,tuple([]))

  @functools.native_method
  def get_speaker_mode(self) -> typing.Union[int]:
    r'''
				Returns the speaker configuration.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def get_mix_rate(self) -> typing.Union[float]:
    r'''
				Returns the sample rate at the output of the `AudioServer`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def get_input_mix_rate(self) -> typing.Union[float]:
    r'''
				Returns the sample rate at the input of the `AudioServer`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def get_driver_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the current audio driver. The default usually depends on the operating system, but may be overridden via the `--audio-driver` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`. `--headless` also automatically sets the audio driver to `Dummy`. See also `ProjectSettings.audio/driver/driver`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_output_device_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the names of all audio output devices detected on the system.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def get_output_device(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_output_device(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'

    self.py__output_device = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(90,tuple([py__string_name._ptr]))

  @functools.native_method
  def get_time_to_next_mix(self) -> typing.Union[float]:
    r'''
				Returns the relative time until the next mix occurs.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([]))
    return _ret


  @functools.native_method
  def get_time_since_last_mix(self) -> typing.Union[float]:
    r'''
				Returns the relative time since the last mix occurred.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))
    return _ret


  @functools.native_method
  def get_output_latency(self) -> typing.Union[float]:
    r'''
				Returns the audio driver's effective output latency. This is based on `ProjectSettings.audio/driver/output_latency`, but the exact returned value will differ depending on the operating system and audio driver.
				**Note:** This can be expensive; it is not recommended to call `get_output_latency` every frame.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))
    return _ret


  @functools.native_method
  def get_input_device_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the names of all audio input devices detected on the system.
				**Note:** `ProjectSettings.audio/driver/enable_input` must be `true` for audio input to work. See also that setting's description for caveats related to permissions and operating system privacy settings.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([]))
    return _ret


  @functools.native_method
  def get_input_device(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_input_device(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'

    self.py__input_device = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(96,tuple([py__string_name._ptr]))

  @functools.native_method
  def set_bus_layout(self, bus_layout:'py4godot_audiobuslayout.AudioBusLayout'   ) -> None:
    r'''
				Overwrites the currently used `AudioBusLayout`.
			'''

    assert(not bus_layout is None)
    assert isinstance(bus_layout, get_class('AudioBusLayout')), 'bus_layout must be AudioBusLayout'






    self._ptr.call_with_return(97,tuple([bus_layout._ptr]))

  @functools.native_method
  def generate_bus_layout(self) -> typing.Union['py4godot_audiobuslayout.AudioBusLayout']:
    r'''
				Generates an `AudioBusLayout` using the available buses and effects.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioBusLayout
    _ret._ptr = self._ptr.call_with_return(98,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_enable_tagging_used_audio_streams(self, enable:'bool'   ) -> None:
    r'''
				If set to `true`, all instances of `AudioStreamPlayback` will call `AudioStreamPlayback._tag_used_streams` every mix step.
				**Note:** This is enabled by default in the editor, as it is used by editor plugins for the audio stream previews.
			'''

    assert isinstance(enable, bool), 'enable must be bool'






    self._ptr.call_with_return(99,tuple([enable]))

  @functools.native_method
  def is_stream_registered_as_sample(self, stream:'py4godot_audiostream.AudioStream'   ) -> typing.Union[bool]:
    r'''
				If `true`, the stream is registered as a sample. The engine will not have to register it before playing the sample.
				If `false`, the stream will have to be registered before playing it. To prevent lag spikes, register the stream as sample with `register_stream_as_sample`.
			'''

    assert(not stream is None)
    assert isinstance(stream, get_class('AudioStream')), 'stream must be AudioStream'






    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([stream._ptr]))
    return _ret


  @functools.native_method
  def register_stream_as_sample(self, stream:'py4godot_audiostream.AudioStream'   ) -> None:
    r'''
				Forces the registration of a stream as a sample.
				**Note:** Lag spikes may occur when calling this method, especially on single-threaded builds. It is suggested to call this method while loading assets, where the lag spike could be masked, instead of registering the sample right before it needs to be played.
			'''

    assert(not stream is None)
    assert isinstance(stream, get_class('AudioStream')), 'stream must be AudioStream'






    self._ptr.call_with_return(101,tuple([stream._ptr]))


register_cast_function('AudioServer', AudioServer.cast)
register_class('AudioServer', AudioServer)
