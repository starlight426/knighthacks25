# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPResourceUIDWrapper

_ResourceUID_singleton_instance = None

class ResourceUID(py4godot_object.Object):
  r'''
		Resource UIDs (Unique IDentifiers) allow the engine to keep references between resources intact, even if files are renamed or moved. They can be accessed with `uid://`.
		`ResourceUID` keeps track of all registered resource UIDs in a project, generates new UIDs, and converts between their string and integer representations.
	'''
  INVALID_ID:typing.ClassVar[int]


  def generate_wrapper(self):
    return CPPResourceUIDWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ResourceUID.__new__(ResourceUID)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ResourceUID'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ResourceUID.construct_without_init()
    cls._ptr = CPPResourceUIDWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ResourceUID.construct_without_init()
    cls._ptr = CPPResourceUIDWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _ResourceUID_singleton_instance
    if _ResourceUID_singleton_instance is None:
      singleton = ResourceUID()
      singleton._ptr = constructor(708,0, ())
      _ResourceUID_singleton_instance = singleton
    return _ResourceUID_singleton_instance

  @functools.native_method
  def id_to_text(self, id:'int'   ) -> typing.Union[str]:
    r'''
				Converts the given UID to a `uid://` string value.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([id]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def text_to_id(self, text_id:'str'   ) -> typing.Union[int]:
    r'''
				Extracts the UID value from the given `uid://` string.
			'''

    assert(not text_id is None)
    assert isinstance(text_id, (str, String)), 'text_id must be str or String'




    assert(isinstance(text_id, (str, String)))
    py_string_text_id = text_id if isinstance(text_id, StringName) else c_utils.py_string_to_string(text_id)

    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([py_string_text_id._ptr]))
    return _ret


  @functools.native_method
  def create_id(self) -> typing.Union[int]:
    r'''
				Generates a random resource UID which is guaranteed to be unique within the list of currently loaded UIDs.
				In order for this UID to be registered, you must call `add_id` or `set_id`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(51,tuple([]))
    return _ret


  @functools.native_method
  def create_id_for_path(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Like `create_id`, but the UID is seeded with the provided `path` and project name. UIDs generated for that path will be always the same within the current project.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(52,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def has_id(self, id:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the given UID value is known to the cache.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([id]))
    return _ret


  @functools.native_method
  def add_id(self, id:'int'   , path:'str'   ) -> None:
    r'''
				Adds a new UID value which is mapped to the given resource path.
				Fails with an error if the UID already exists, so be sure to check `has_id` beforehand, or use `set_id` instead.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    self._ptr.call_with_return(54,tuple([id, py_string_path._ptr]))

  @functools.native_method
  def set_id(self, id:'int'   , path:'str'   ) -> None:
    r'''
				Updates the resource path of an existing UID.
				Fails with an error if the UID does not exist, so be sure to check `has_id` beforehand, or use `add_id` instead.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    self._ptr.call_with_return(55,tuple([id, py_string_path._ptr]))

  @functools.native_method
  def get_id_path(self, id:'int'   ) -> typing.Union[str]:
    r'''
				Returns the path that the given UID value refers to.
				Fails with an error if the UID does not exist, so be sure to check `has_id` beforehand.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([id]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def remove_id(self, id:'int'   ) -> None:
    r'''
				Removes a loaded UID value from the cache.
				Fails with an error if the UID does not exist, so be sure to check `has_id` beforehand.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'






    self._ptr.call_with_return(57,tuple([id]))

  @staticmethod
  def uid_to_path(uid:'str'   ) -> typing.Union[str]:
    r'''
				Converts the provided `uid` to a path. Prints an error if the UID is invalid.
			'''

    assert(not uid is None)
    assert isinstance(uid, (str, String)), 'uid must be str or String'




    assert(isinstance(uid, (str, String)))
    py_string_uid = uid if isinstance(uid, StringName) else c_utils.py_string_to_string(uid)

    _ret = String.construct_without_init()
    _ret._ptr = static_method(708,0,tuple([py_string_uid._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def path_to_uid(path:'str'   ) -> typing.Union[str]:
    r'''
				Converts the provided resource `path` to a UID. Returns the unchanged path if it has no associated UID.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'




    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = String.construct_without_init()
    _ret._ptr = static_method(708,1,tuple([py_string_path._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def ensure_path(path_or_uid:'str'   ) -> typing.Union[str]:
    r'''
				Returns a path, converting `path_or_uid` if necessary. Prints an error if provided an invalid UID.
			'''

    assert(not path_or_uid is None)
    assert isinstance(path_or_uid, (str, String)), 'path_or_uid must be str or String'




    assert(isinstance(path_or_uid, (str, String)))
    py_string_path_or_uid = path_or_uid if isinstance(path_or_uid, StringName) else c_utils.py_string_to_string(path_or_uid)

    _ret = String.construct_without_init()
    _ret._ptr = static_method(708,2,tuple([py_string_path_or_uid._ptr]))
    return utils.gd_string_to_py_string(_ret)



register_cast_function('ResourceUID', ResourceUID.cast)
register_class('ResourceUID', ResourceUID)
